import{_ as a}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as n,a as t,o as s}from"./app-DWML8MdU.js";const i={};function r(o,e){return s(),n("div",null,e[0]||(e[0]=[t(`<h1 id="" tabindex="-1"><a class="header-anchor" href="#"><span></span></a></h1><h1 id="chat" tabindex="-1"><a class="header-anchor" href="#chat"><span>chat</span></a></h1><h1 id="基本介绍" tabindex="-1"><a class="header-anchor" href="#基本介绍"><span>基本介绍</span></a></h1><p><strong>递归复杂度计算</strong>中确实有一个非常常用的工具，叫做 <strong>Master Theorem（主定理）</strong>，可以用来<strong>分析形如分治递归</strong>的时间复杂度，非常适合处理像归并排序、快速排序、二分法、树型递归等场景。</p><hr><h2 id="一、master-theorem-主定理-公式" tabindex="-1"><a class="header-anchor" href="#一、master-theorem-主定理-公式"><span>一、Master Theorem（主定理）公式</span></a></h2><p>它适用于如下形式的递归关系：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>T(n) = a * T(n/b) + f(n)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>其中：</p><ul><li><code>a</code>：每次递归分成的子问题数</li><li><code>n/b</code>：每个子问题的规模</li><li><code>f(n)</code>：除递归外，当前层的其他操作开销（比如合并、遍历等）</li></ul><hr><h2 id="二、主定理的三种情况" tabindex="-1"><a class="header-anchor" href="#二、主定理的三种情况"><span>二、主定理的三种情况</span></a></h2><p>根据 <code>f(n)</code> 和 <code>n^log_b(a)</code> 的大小关系，有三种情况：</p><hr><h3 id="情况-1-f-n-比-n-log-b-a-小" tabindex="-1"><a class="header-anchor" href="#情况-1-f-n-比-n-log-b-a-小"><span><strong>情况 1：f(n) 比 n^log_b(a) 小</strong></span></a></h3><ul><li>如果：                 <code>f(n) = O(n^c)</code>，且 <code>c &lt; log_b(a)</code></li><li>则：                  <code>T(n) = Θ(n^log_b(a))</code></li></ul><p>✅ 此时递归的<strong>子问题主导复杂度</strong>。</p><hr><h3 id="情况-2-f-n-与-n-log-b-a-相等" tabindex="-1"><a class="header-anchor" href="#情况-2-f-n-与-n-log-b-a-相等"><span><strong>情况 2：f(n) 与 n^log_b(a) 相等</strong></span></a></h3><ul><li>如果：                 <code>f(n) = Θ(n^log_b(a) * log^k(n))</code>，k ≥ 0</li><li>则：                  <code>T(n) = Θ(n^log_b(a) * log^{k+1}(n))</code></li></ul><p>✅ 此时<strong>递归和本层工作量平衡</strong>。</p><hr><h3 id="情况-3-f-n-比-n-log-b-a-大" tabindex="-1"><a class="header-anchor" href="#情况-3-f-n-比-n-log-b-a-大"><span><strong>情况 3：f(n) 比 n^log_b(a) 大</strong></span></a></h3><ul><li>如果：                 <code>f(n) = Ω(n^c)</code>，且 <code>c &gt; log_b(a)</code>，并满足“<strong>正则性条件</strong>”</li><li>则：                  <code>T(n) = Θ(f(n))</code></li></ul><p>👉 正则性条件：<code>a * f(n/b) ≤ k * f(n)</code>，其中 k &lt; 1，成立时才可以用。</p><p>✅ 此时<strong>本层的操作主导复杂度</strong>。</p><hr><h2 id="三、几个经典例子" tabindex="-1"><a class="header-anchor" href="#三、几个经典例子"><span>三、几个经典例子</span></a></h2><h3 id="✅-示例-1-归并排序" tabindex="-1"><a class="header-anchor" href="#✅-示例-1-归并排序"><span>✅ 示例 1：归并排序</span></a></h3><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>T(n) = 2T(n/2) + O(n)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><ul><li>a = 2，b = 2，f(n) = O(n)</li><li>log_b(a) = log₂2 = 1</li><li>f(n) = Θ(n)，等于 n^1</li></ul><p>➡ 属于情况 2<br> ➡ 所以 T(n) = Θ(n log n)</p><hr><h3 id="✅-示例-2-二分查找" tabindex="-1"><a class="header-anchor" href="#✅-示例-2-二分查找"><span>✅ 示例 2：二分查找</span></a></h3><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>T(n) = T(n/2) + O(1)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><ul><li>a = 1，b = 2，f(n) = O(1)</li><li>log₂1 = 0</li><li>f(n) = Θ(1)，等于 n^0</li></ul><p>➡ 属于情况 2<br> ➡ 所以 T(n) = Θ(log n)</p><hr><h3 id="✅-示例-3-暴力斐波那契" tabindex="-1"><a class="header-anchor" href="#✅-示例-3-暴力斐波那契"><span>✅ 示例 3：暴力斐波那契</span></a></h3><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>T(n) = T(n - 1) + T(n - 2) + O(1)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>这个<strong>不符合 Master Theorem</strong>格式（不是 <code>n/b</code>），就不能用主定理。</p><p>➡ 这类递归要用“递归树分析法”，复杂度约为 <code>O(2^n)</code>。</p><hr><h2 id="四、常见算法的递归关系" tabindex="-1"><a class="header-anchor" href="#四、常见算法的递归关系"><span>四、常见算法的递归关系</span></a></h2><table><thead><tr><th>算法</th><th>递归公式</th><th>时间复杂度</th></tr></thead><tbody><tr><td>归并排序</td><td>T(n) = 2T(n/2) + O(n)</td><td>Θ(n log n)</td></tr><tr><td>快速排序（平均）</td><td>T(n) = 2T(n/2) + O(n)</td><td>Θ(n log n)</td></tr><tr><td>快速排序（最坏）</td><td>T(n) = T(n - 1) + O(n)</td><td>O(n²)</td></tr><tr><td>二分查找</td><td>T(n) = T(n/2) + O(1)</td><td>O(log n)</td></tr><tr><td>Karatsuba乘法</td><td>T(n) = 3T(n/2) + O(n)</td><td>O(n^log₂3) ≈ O(n^1.59)</td></tr></tbody></table><hr><h2 id="五、小结口诀" tabindex="-1"><a class="header-anchor" href="#五、小结口诀"><span>五、小结口诀</span></a></h2><p>📌 主定理口诀版总结：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>T(n) = a T(n/b) + f(n)</span></span>
<span class="line"><span></span></span>
<span class="line"><span>比较 f(n) 与 n^log_b(a)：</span></span>
<span class="line"><span>- 小于：复杂度由递归决定（情况 1）</span></span>
<span class="line"><span>- 等于：复杂度加 log（情况 2）</span></span>
<span class="line"><span>- 大于：复杂度由本层决定（情况 3，需正则性）</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h1 id="参考资料" tabindex="-1"><a class="header-anchor" href="#参考资料"><span>参考资料</span></a></h1>`,50)]))}const h=a(i,[["render",r]]),c=JSON.parse('{"path":"/posts/leetcode/topliked-100/recursive/2020-06-06-algorithm-000-leetcode-data-struct-007-recursive-02-master-theorem-intro.html","title":"leetcode recursive 递归-02-递归复杂度计算 Master Theorem（主定理）","lang":"zh-CN","frontmatter":{"title":"leetcode recursive 递归-02-递归复杂度计算 Master Theorem（主定理）","date":"2020-06-08T00:00:00.000Z","categories":["TopLiked100"],"tags":["algorithm","sort","sf"],"published":true,"description":"chat 基本介绍 递归复杂度计算中确实有一个非常常用的工具，叫做 Master Theorem（主定理），可以用来分析形如分治递归的时间复杂度，非常适合处理像归并排序、快速排序、二分法、树型递归等场景。 一、Master Theorem（主定理）公式 它适用于如下形式的递归关系： 其中： a：每次递归分成的子问题数 n/b：每个子问题的规模 f(n)...","head":[["meta",{"property":"og:url","content":"https://houbb.github.io/leetcode-notes/posts/leetcode/topliked-100/recursive/2020-06-06-algorithm-000-leetcode-data-struct-007-recursive-02-master-theorem-intro.html"}],["meta",{"property":"og:site_name","content":"老马啸西风"}],["meta",{"property":"og:title","content":"leetcode recursive 递归-02-递归复杂度计算 Master Theorem（主定理）"}],["meta",{"property":"og:description","content":"chat 基本介绍 递归复杂度计算中确实有一个非常常用的工具，叫做 Master Theorem（主定理），可以用来分析形如分治递归的时间复杂度，非常适合处理像归并排序、快速排序、二分法、树型递归等场景。 一、Master Theorem（主定理）公式 它适用于如下形式的递归关系： 其中： a：每次递归分成的子问题数 n/b：每个子问题的规模 f(n)..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-09-24T02:52:43.000Z"}],["meta",{"property":"article:tag","content":"algorithm"}],["meta",{"property":"article:tag","content":"sort"}],["meta",{"property":"article:tag","content":"sf"}],["meta",{"property":"article:published_time","content":"2020-06-08T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2025-09-24T02:52:43.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"leetcode recursive 递归-02-递归复杂度计算 Master Theorem（主定理）\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2020-06-08T00:00:00.000Z\\",\\"dateModified\\":\\"2025-09-24T02:52:43.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"老马啸西风\\",\\"url\\":\\"https://houbb.github.io\\"}]}"]]},"git":{"createdTime":1755499309000,"updatedTime":1758682363000,"contributors":[{"name":"binbin.hou","username":"","email":"binbin.hou@huifu.com","commits":4},{"name":"bbhou","username":"bbhou","email":"1557740299@qq.com","commits":2,"url":"https://github.com/bbhou"}]},"readingTime":{"minutes":2.26,"words":679},"filePathRelative":"posts/leetcode/topliked-100/recursive/2020-06-06-algorithm-000-leetcode-data-struct-007-recursive-02-master-theorem-intro.md","localizedDate":"2020年6月8日","excerpt":"\\n<h1>chat</h1>\\n<h1>基本介绍</h1>\\n<p><strong>递归复杂度计算</strong>中确实有一个非常常用的工具，叫做 <strong>Master Theorem（主定理）</strong>，可以用来<strong>分析形如分治递归</strong>的时间复杂度，非常适合处理像归并排序、快速排序、二分法、树型递归等场景。</p>\\n<hr>\\n<h2>一、Master Theorem（主定理）公式</h2>\\n<p>它适用于如下形式的递归关系：</p>\\n<div class=\\"language- line-numbers-mode\\" data-highlighter=\\"shiki\\" data-ext=\\"\\" style=\\"--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34\\"><pre class=\\"shiki shiki-themes one-light one-dark-pro vp-code\\"><code><span class=\\"line\\"><span>T(n) = a * T(n/b) + f(n)</span></span></code></pre>\\n<div class=\\"line-numbers\\" aria-hidden=\\"true\\" style=\\"counter-reset:line-number 0\\"><div class=\\"line-number\\"></div></div></div>","autoDesc":true}');export{h as comp,c as data};
