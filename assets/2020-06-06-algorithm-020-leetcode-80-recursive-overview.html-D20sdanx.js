import{_ as i}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as s,a,o as t}from"./app-YPU-QJCm.js";const n={};function r(l,e){return t(),s("div",null,e[0]||(e[0]=[a(`<h1 id="chat" tabindex="-1"><a class="header-anchor" href="#chat"><span>chat</span></a></h1><h2 id="是什么" tabindex="-1"><a class="header-anchor" href="#是什么"><span>是什么？</span></a></h2><p>递归算法是一种在计算机科学中非常常见的解决问题的方法，它通过函数调用自身来解决问题。</p><p>递归通常将复杂的问题分解成更小的子问题，通过逐步缩小问题规模直到满足某种条件（基准情况或边界条件）停止递归调用，从而得到解答。</p><h3 id="递归的基本组成部分" tabindex="-1"><a class="header-anchor" href="#递归的基本组成部分"><span>递归的基本组成部分</span></a></h3><p>一个典型的递归算法包含两个关键部分：</p><ol><li><p><strong>基准条件（Base Case）</strong>：基准条件是递归算法停止递归的条件。它通常用于处理最简单的情况，不需要进一步分解。例如，计算阶乘时，<code>0! = 1</code> 就是基准条件。</p></li><li><p><strong>递归条件（Recursive Case）</strong>：递归条件定义了如何将问题分解为更小的子问题，并递归地调用函数自身来处理这些子问题。例如，计算阶乘时，<code>n! = n * (n - 1)!</code> 是递归条件。</p></li></ol><h3 id="递归算法的工作原理" tabindex="-1"><a class="header-anchor" href="#递归算法的工作原理"><span>递归算法的工作原理</span></a></h3><p>递归通过函数的“自调用”逐层将问题分解成子问题并推入调用栈，直到满足基准条件，然后自下而上逐步回溯计算出结果。</p><h3 id="示例-阶乘计算" tabindex="-1"><a class="header-anchor" href="#示例-阶乘计算"><span>示例：阶乘计算</span></a></h3><p>阶乘问题可以用递归来简单地描述，数学上定义为：</p><ul><li>( n! = n \\times (n-1)! )</li><li>基准条件：( 0! = 1 )</li></ul><p>在代码中，用递归实现阶乘的示例如下：</p><div class="language-python line-numbers-mode" data-highlighter="shiki" data-ext="python" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">def</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> factorial</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#986801;--shiki-light-font-style:inherit;--shiki-dark:#D19A66;--shiki-dark-font-style:italic;">n</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">):</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    if</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> n </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">==</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 0</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">:  </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># 基准条件</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        return</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 1</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    else</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">:</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        return</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> n </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">*</span><span style="--shiki-light:#383A42;--shiki-dark:#61AFEF;"> factorial</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(n </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">-</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)  </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># 递归条件</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>例如，<code>factorial(3)</code> 的计算过程如下：</p><ol><li><code>factorial(3)</code> 计算 <code>3 * factorial(2)</code></li><li><code>factorial(2)</code> 计算 <code>2 * factorial(1)</code></li><li><code>factorial(1)</code> 计算 <code>1 * factorial(0)</code></li><li><code>factorial(0)</code> 返回 <code>1</code></li><li>逐步回溯计算，得到最终结果 <code>3 * 2 * 1 * 1 = 6</code></li></ol><h3 id="递归的优缺点" tabindex="-1"><a class="header-anchor" href="#递归的优缺点"><span>递归的优缺点</span></a></h3><h4 id="优点" tabindex="-1"><a class="header-anchor" href="#优点"><span>优点</span></a></h4><ul><li><strong>简单直观</strong>：递归有助于用简单的代码结构表达复杂的算法逻辑，特别适合分治问题和树结构的操作。</li><li><strong>自然分治</strong>：递归可以轻松地将问题分解成子问题，尤其适用于分治法。</li></ul><h4 id="缺点" tabindex="-1"><a class="header-anchor" href="#缺点"><span>缺点</span></a></h4><ul><li><strong>性能开销</strong>：递归会占用较多的栈空间，因为每次递归调用都会增加一个函数调用栈。对于较大的输入规模，可能会导致栈溢出错误。</li><li><strong>可能存在冗余计算</strong>：有时递归会重复计算相同的子问题，导致效率下降。例如，使用递归计算斐波那契数列时，直接递归会重复计算相同的数值。</li></ul><h3 id="递归与动态规划" tabindex="-1"><a class="header-anchor" href="#递归与动态规划"><span>递归与动态规划</span></a></h3><p>递归与动态规划（Dynamic Programming，DP）密切相关。</p><p>通过记忆化（Memoization）和自底向上的计算方式，可以避免冗余计算，从而提升效率。</p><p>例如，使用动态规划算法计算斐波那契数列，避免了重复计算。</p><h3 id="递归的应用场景" tabindex="-1"><a class="header-anchor" href="#递归的应用场景"><span>递归的应用场景</span></a></h3><p>递归算法广泛应用于以下场景：</p><ol><li><strong>分治法</strong>：快速排序、归并排序等分治法算法。</li><li><strong>树和图的遍历</strong>：深度优先搜索（DFS）常用递归实现。</li><li><strong>组合与排列问题</strong>：如八皇后问题、子集生成等。</li><li><strong>动态规划</strong>：通过递归和记忆化实现动态规划问题，如背包问题。</li></ol><h3 id="递归优化建议" tabindex="-1"><a class="header-anchor" href="#递归优化建议"><span>递归优化建议</span></a></h3><ol><li><strong>尾递归</strong>：若语言支持尾递归优化，可将递归转换为尾递归，降低栈空间使用。</li><li><strong>记忆化</strong>：使用缓存保存已经计算过的结果，减少重复计算。</li><li><strong>迭代替换</strong>：某些场景可以用迭代替换递归，从而避免栈溢出问题。</li></ol><p>递归算法虽然简洁高效，但需要注意性能和内存的管理，通过优化可以在实际应用中取得更好的效果。</p><h1 id="参考资料" tabindex="-1"><a class="header-anchor" href="#参考资料"><span>参考资料</span></a></h1><p><a href="https://leetcode.cn/problems/hanota-lcci/description/?envType=problem-list-v2&amp;envId=recursion" target="_blank" rel="noopener noreferrer">https://leetcode.cn/problems/hanota-lcci/description/?envType=problem-list-v2&amp;envId=recursion</a></p>`,33)]))}const p=i(n,[["render",r]]),c=JSON.parse('{"path":"/posts/leetcode/history1/2020-06-06-algorithm-020-leetcode-80-recursive-overview.html","title":"80-recursive 递归","lang":"zh-CN","frontmatter":{"title":"80-recursive 递归","date":"2020-06-08T00:00:00.000Z","categories":["Algorithm"],"tags":["algorithm","greedy","leetcode"],"published":true,"description":"chat 是什么？ 递归算法是一种在计算机科学中非常常见的解决问题的方法，它通过函数调用自身来解决问题。 递归通常将复杂的问题分解成更小的子问题，通过逐步缩小问题规模直到满足某种条件（基准情况或边界条件）停止递归调用，从而得到解答。 递归的基本组成部分 一个典型的递归算法包含两个关键部分： 基准条件（Base Case）：基准条件是递归算法停止递归的条...","head":[["meta",{"property":"og:url","content":"https://houbb.github.io/leetcode-notes/posts/leetcode/history1/2020-06-06-algorithm-020-leetcode-80-recursive-overview.html"}],["meta",{"property":"og:site_name","content":"老马啸西风"}],["meta",{"property":"og:title","content":"80-recursive 递归"}],["meta",{"property":"og:description","content":"chat 是什么？ 递归算法是一种在计算机科学中非常常见的解决问题的方法，它通过函数调用自身来解决问题。 递归通常将复杂的问题分解成更小的子问题，通过逐步缩小问题规模直到满足某种条件（基准情况或边界条件）停止递归调用，从而得到解答。 递归的基本组成部分 一个典型的递归算法包含两个关键部分： 基准条件（Base Case）：基准条件是递归算法停止递归的条..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-08-22T12:19:07.000Z"}],["meta",{"property":"article:tag","content":"algorithm"}],["meta",{"property":"article:tag","content":"greedy"}],["meta",{"property":"article:tag","content":"leetcode"}],["meta",{"property":"article:published_time","content":"2020-06-08T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2025-08-22T12:19:07.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"80-recursive 递归\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2020-06-08T00:00:00.000Z\\",\\"dateModified\\":\\"2025-08-22T12:19:07.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"老马啸西风\\",\\"url\\":\\"https://houbb.github.io\\"}]}"]]},"git":{"createdTime":1755499309000,"updatedTime":1755865147000,"contributors":[{"name":"binbin.hou","username":"","email":"binbin.hou@huifu.com","commits":2},{"name":"bbhou","username":"bbhou","email":"1557740299@qq.com","commits":2,"url":"https://github.com/bbhou"}]},"readingTime":{"minutes":3.24,"words":973},"filePathRelative":"posts/leetcode/history1/2020-06-06-algorithm-020-leetcode-80-recursive-overview.md","localizedDate":"2020年6月8日","excerpt":"\\n<h2>是什么？</h2>\\n<p>递归算法是一种在计算机科学中非常常见的解决问题的方法，它通过函数调用自身来解决问题。</p>\\n<p>递归通常将复杂的问题分解成更小的子问题，通过逐步缩小问题规模直到满足某种条件（基准情况或边界条件）停止递归调用，从而得到解答。</p>\\n<h3>递归的基本组成部分</h3>\\n<p>一个典型的递归算法包含两个关键部分：</p>\\n<ol>\\n<li>\\n<p><strong>基准条件（Base Case）</strong>：基准条件是递归算法停止递归的条件。它通常用于处理最简单的情况，不需要进一步分解。例如，计算阶乘时，<code>0! = 1</code> 就是基准条件。</p>\\n</li>\\n<li>\\n<p><strong>递归条件（Recursive Case）</strong>：递归条件定义了如何将问题分解为更小的子问题，并递归地调用函数自身来处理这些子问题。例如，计算阶乘时，<code>n! = n * (n - 1)!</code> 是递归条件。</p>\\n</li>\\n</ol>","autoDesc":true}');export{p as comp,c as data};
