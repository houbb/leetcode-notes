import{_ as s}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as n,a,o as t}from"./app-YPU-QJCm.js";const l={};function e(h,i){return t(),n("div",null,i[0]||(i[0]=[a(`<h2 id="_1️⃣-并查集的本质" tabindex="-1"><a class="header-anchor" href="#_1️⃣-并查集的本质"><span>1️⃣ 并查集的本质</span></a></h2><p><strong>并查集</strong>是一种用于 <strong>动态维护不相交集合（Disjoint Sets）</strong> 的数据结构，核心目的是快速判断元素是否属于同一个集合，以及将两个集合合并。</p><ul><li><p><strong>用途</strong>：</p><ul><li>判断图中两个节点是否连通</li><li>求连通分量个数</li><li>处理网络、社交关系、群体合并等问题</li></ul></li><li><p><strong>核心思想</strong>：</p><ul><li>每个集合有一个“代表元素”（root）</li><li>每个元素只保存指向父节点的指针</li><li>查找元素的根节点可以判断是否属于同一个集合</li><li>合并两个集合就是把一个集合的根挂到另一个根上</li></ul></li></ul><hr><h2 id="_2️⃣-并查集的核心操作" tabindex="-1"><a class="header-anchor" href="#_2️⃣-并查集的核心操作"><span>2️⃣ 并查集的核心操作</span></a></h2><h3 id="_2-1-初始化" tabindex="-1"><a class="header-anchor" href="#_2-1-初始化"><span>2.1 初始化</span></a></h3><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">[] parent </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#C18401;--shiki-dark:#C678DD;"> int</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">[n]</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">for</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> (</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> i </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 0</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> i </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">&lt;</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> n</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> i</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">++</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">) parent[i] </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> i</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>每个节点自己是自己的根，表示初始 n 个独立集合。</li></ul><h3 id="_2-2-查找-find" tabindex="-1"><a class="header-anchor" href="#_2-2-查找-find"><span>2.2 查找（Find）</span></a></h3><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> find</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> x) {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    if</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> (parent[x] </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">!=</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> x) {</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">        parent[x] </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> find</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(parent[x])</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // 路径压缩</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">    }</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    return</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> parent[x]</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>目的：找到 x 所在集合的根节点</li><li><strong>路径压缩</strong>：将访问路径上的所有节点直接挂到根节点下，优化后续查询</li></ul><h3 id="_2-3-合并-union" tabindex="-1"><a class="header-anchor" href="#_2-3-合并-union"><span>2.3 合并（Union）</span></a></h3><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> union</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> x</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> int</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> y) {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    int</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> rootX </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> find</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(x)</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    int</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> rootY </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> find</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(y)</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    if</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> (rootX </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">!=</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> rootY) {</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">        parent[rootX] </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> rootY</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // 合并集合</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">    }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>把 x 所在集合和 y 所在集合合并为一个集合</li><li>可以选择按秩合并（rank）进一步优化</li></ul><h3 id="_2-4-判断是否在同一集合-可选" tabindex="-1"><a class="header-anchor" href="#_2-4-判断是否在同一集合-可选"><span>2.4 判断是否在同一集合（可选）</span></a></h3><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">boolean</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> connected</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> x</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> int</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> y) {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    return</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> find</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(x) </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">==</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> find</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(y)</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_3️⃣-并查集复杂度分析" tabindex="-1"><a class="header-anchor" href="#_3️⃣-并查集复杂度分析"><span>3️⃣ 并查集复杂度分析</span></a></h2><table><thead><tr><th>操作</th><th>复杂度</th></tr></thead><tbody><tr><td>初始化</td><td>O(n)</td></tr><tr><td>单次查找/合并</td><td>O(α(n))，α(n) 为反阿克曼函数，非常小，可视作常数</td></tr><tr><td>n 次操作</td><td>O(n α(n))，近似 O(n)</td></tr></tbody></table><blockquote><p>注意：这是经过 <strong>路径压缩 + 按秩合并</strong> 的最优复杂度。</p></blockquote><h2 id="_5️⃣-总结" tabindex="-1"><a class="header-anchor" href="#_5️⃣-总结"><span>5️⃣ 总结</span></a></h2><ul><li><p>并查集 = 动态维护不相交集合 + 快速合并</p></li><li><p>核心操作：<strong>Find（查找根）</strong> + <strong>Union（合并集合）</strong></p></li><li><p>优化技巧：</p><ul><li>路径压缩（递归或迭代）</li><li>按秩合并（rank）或按大小合并（size）</li></ul></li><li><p>适用场景：</p><ul><li>连通性判断</li><li>社交网络群体合并</li><li>Kruskal 最小生成树</li><li>省份、朋友圈、岛屿数量等问题</li></ul></li></ul><h1 id="并查集这个一般用于解决图的问题吗-还是还有其他的应用场景" tabindex="-1"><a class="header-anchor" href="#并查集这个一般用于解决图的问题吗-还是还有其他的应用场景"><span>并查集这个一般用于解决图的问题吗？还是还有其他的应用场景</span></a></h1><p>并查集（Union-Find）虽然最常见于 <strong>图的连通性问题</strong>，但它的应用远不止图论，核心是 <strong>维护动态的“不相交集合”关系”</strong>。</p><h2 id="_1️⃣-图论相关应用-最经典" tabindex="-1"><a class="header-anchor" href="#_1️⃣-图论相关应用-最经典"><span>1️⃣ 图论相关应用（最经典）</span></a></h2><ol><li><p><strong>连通性问题</strong></p><ul><li>判断两个节点是否在同一个连通分量</li><li>求图中连通分量的数量（例如 LC547 省份问题）</li></ul></li><li><p><strong>Kruskal 最小生成树</strong></p><ul><li>遍历边，判断两个端点是否属于同一个集合，避免形成环</li><li>用 Union-Find 合并集合，保证生成树不成环</li></ul></li><li><p><strong>圈 / 环检测</strong></p><ul><li>在无向图或有向图中检测是否存在环</li></ul></li><li><p><strong>网络/社交关系</strong></p><ul><li>判断两个人是否在同一个社交群体</li><li>朋友圈问题（如 LC547 变体）</li></ul></li></ol><hr><h2 id="_2️⃣-非图论的应用-更广泛" tabindex="-1"><a class="header-anchor" href="#_2️⃣-非图论的应用-更广泛"><span>2️⃣ 非图论的应用（更广泛）</span></a></h2><ol><li><p><strong>动态连通性集合</strong></p><ul><li><p>任何需要维护元素分组的场景，只要需要频繁合并集合并快速查询：</p><ul><li>例如学生分组、团队合并、任务归类等</li></ul></li></ul></li><li><p><strong>字符串或集合等归并问题</strong></p><ul><li>LC721 “账户合并”：把多个邮箱合并到同一个账户</li><li>LC839 “相似字符串群”：相似字符串归类</li></ul></li><li><p><strong>区域 / 集群 / 连通块问题</strong></p><ul><li>网格 / 矩阵中岛屿数量问题（LC200, LC695）</li><li>任何二维或多维网格的连通区域计算，都可以用 Union-Find</li></ul></li><li><p><strong>动态集合判断</strong></p><ul><li>游戏或模拟中，维护不同势力、联盟的合并与判断</li><li>动态资源管理，例如服务器分组或网络拓扑合并</li></ul></li><li><p><strong>优化搜索</strong></p><ul><li>路径压缩 + 按秩合并可以加速一些重复查询问题，例如找最小/最大组、合并后查询属性等</li></ul></li></ol><hr><h3 id="🔑-核心思想" tabindex="-1"><a class="header-anchor" href="#🔑-核心思想"><span>🔑 核心思想</span></a></h3><p>不论场景如何变化，<strong>本质都是：动态维护不相交集合，并支持快速合并和查询</strong>。</p><ul><li>**“图问题”**只是最直观的例子</li><li>**“集合归并/分组问题”**是更抽象的本质应用</li></ul><h1 id="我要如何记忆并查集呢" tabindex="-1"><a class="header-anchor" href="#我要如何记忆并查集呢"><span>我要如何记忆并查集呢？</span></a></h1><p>要记忆并查集（Union-Find），核心是抓住它的 <strong>本质、操作和优化技巧</strong>，而不是死记每一行代码。</p><p>我给你总结一个 <strong>高效记忆法</strong>，用“图+故事+口诀”的方式，容易记住又能理解。</p><hr><h2 id="_1️⃣-理解本质-记忆核心" tabindex="-1"><a class="header-anchor" href="#_1️⃣-理解本质-记忆核心"><span>1️⃣ 理解本质（记忆核心）</span></a></h2><p><strong>核心概念</strong>：</p><blockquote><p>并查集 = 动态维护不相交集合 + 快速合并 + 快速查找代表元素（根节点）</p></blockquote><p>用一句话记忆：</p><blockquote><p><strong>“每个元素都有一个根，想问关系就找根，想合并就让根连起来。”</strong></p></blockquote><p>画面化记忆：</p><ul><li>每个元素像一棵树的节点</li><li>根节点是集合的代表</li><li>合并集合 = 把一棵树挂到另一棵树的根下</li><li>查询两个元素是否在同一集合 = 找它们的根</li></ul><hr><h2 id="_2️⃣-核心操作-口诀" tabindex="-1"><a class="header-anchor" href="#_2️⃣-核心操作-口诀"><span>2️⃣ 核心操作（口诀）</span></a></h2><table><thead><tr><th>操作</th><th>功能</th><th>记忆口诀</th></tr></thead><tbody><tr><td><code>find(x)</code></td><td>找根</td><td><strong>“找根就压扁路”</strong>（路径压缩）</td></tr><tr><td><code>union(x, y)</code></td><td>合并</td><td><strong>“把两棵树连起来”</strong>（按秩或按大小）</td></tr><tr><td><code>connected(x, y)</code></td><td>判断是否同集合</td><td><strong>“看根是不是同一个”</strong></td></tr></tbody></table><p>口诀串起来：</p><blockquote><p><strong>“找根就压扁路，把两棵树连起来，看根是不是同一个。”</strong></p></blockquote><hr><h2 id="_3️⃣-优化技巧-记忆辅助" tabindex="-1"><a class="header-anchor" href="#_3️⃣-优化技巧-记忆辅助"><span>3️⃣ 优化技巧（记忆辅助）</span></a></h2><ul><li><p><strong>路径压缩（Path Compression）</strong></p><ul><li>找根时，把沿途节点都挂到根节点下</li><li>联想：像“把弯曲的路线拉直”，下一次找根更快</li></ul></li><li><p><strong>按秩/大小合并（Union by Rank/Size）</strong></p><ul><li>总是把矮树挂到高树下</li><li>联想：轻的挂到重的上面，避免树高增长</li></ul></li></ul><p>口诀：</p><blockquote><p><strong>“拉直路线、轻挂重枝”</strong></p></blockquote><hr><h2 id="_4️⃣-应用场景-便于联想记忆" tabindex="-1"><a class="header-anchor" href="#_4️⃣-应用场景-便于联想记忆"><span>4️⃣ 应用场景（便于联想记忆）</span></a></h2><ul><li><strong>图论类</strong>：省份、连通分量、最小生成树、环检测</li><li><strong>非图论类</strong>：账户合并、字符串群分组、岛屿数量、联盟/团队合并</li></ul><p>联想故事：</p><blockquote><p>想象你在学校里，每个学生最初都是独立的小团体，你可以让两个小团体合并，或者问两个人是不是同一个团体，树形结构帮你快速回答。</p></blockquote><hr><h2 id="_5️⃣-练习记忆方法" tabindex="-1"><a class="header-anchor" href="#_5️⃣-练习记忆方法"><span>5️⃣ 练习记忆方法</span></a></h2><ol><li><strong>画图</strong>：画几颗小树，模拟 <code>union</code> 和 <code>find</code>，记住路径压缩的变化</li><li><strong>写口诀</strong>：每天复述</li><li><strong>手写代码</strong>：不看答案，写出 <code>find</code> + <code>union</code></li><li><strong>结合题目</strong>：LC547、LC200、LC721，做题时把并查集用上，加深印象</li></ol><hr><p>💡 总结一句话记忆并查集：</p><blockquote><p><strong>“每个元素找根，想问关系找根，想合并挂根，路径压缩轻松快。”</strong></p></blockquote>`,64)]))}const d=s(l,[["render",e]]),k=JSON.parse('{"path":"/posts/data-struct/2025-10-01-union-find-01-intro.html","title":"并查集 union-find 入门介绍","lang":"zh-CN","frontmatter":{"title":"并查集 union-find 入门介绍","date":"2025-10-01T00:00:00.000Z","categories":["Data Struct"],"tags":["data-struct","union-find","sh"],"published":true,"description":"1️⃣ 并查集的本质 并查集是一种用于 动态维护不相交集合（Disjoint Sets） 的数据结构，核心目的是快速判断元素是否属于同一个集合，以及将两个集合合并。 用途： 判断图中两个节点是否连通 求连通分量个数 处理网络、社交关系、群体合并等问题 核心思想： 每个集合有一个“代表元素”（root） 每个元素只保存指向父节点的指针 查找元素的根节点可...","head":[["meta",{"property":"og:url","content":"https://houbb.github.io/leetcode-notes/posts/data-struct/2025-10-01-union-find-01-intro.html"}],["meta",{"property":"og:site_name","content":"老马啸西风"}],["meta",{"property":"og:title","content":"并查集 union-find 入门介绍"}],["meta",{"property":"og:description","content":"1️⃣ 并查集的本质 并查集是一种用于 动态维护不相交集合（Disjoint Sets） 的数据结构，核心目的是快速判断元素是否属于同一个集合，以及将两个集合合并。 用途： 判断图中两个节点是否连通 求连通分量个数 处理网络、社交关系、群体合并等问题 核心思想： 每个集合有一个“代表元素”（root） 每个元素只保存指向父节点的指针 查找元素的根节点可..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-10-01T15:58:23.000Z"}],["meta",{"property":"article:tag","content":"data-struct"}],["meta",{"property":"article:tag","content":"union-find"}],["meta",{"property":"article:tag","content":"sh"}],["meta",{"property":"article:published_time","content":"2025-10-01T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2025-10-01T15:58:23.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"并查集 union-find 入门介绍\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2025-10-01T00:00:00.000Z\\",\\"dateModified\\":\\"2025-10-01T15:58:23.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"老马啸西风\\",\\"url\\":\\"https://houbb.github.io\\"}]}"]]},"git":{"createdTime":1759334303000,"updatedTime":1759334303000,"contributors":[{"name":"bbhou","username":"bbhou","email":"1557740299@qq.com","commits":1,"url":"https://github.com/bbhou"}]},"readingTime":{"minutes":5.66,"words":1698},"filePathRelative":"posts/data-struct/2025-10-01-union-find-01-intro.md","localizedDate":"2025年10月1日","excerpt":"<h2>1️⃣ 并查集的本质</h2>\\n<p><strong>并查集</strong>是一种用于 <strong>动态维护不相交集合（Disjoint Sets）</strong> 的数据结构，核心目的是快速判断元素是否属于同一个集合，以及将两个集合合并。</p>\\n<ul>\\n<li>\\n<p><strong>用途</strong>：</p>\\n<ul>\\n<li>判断图中两个节点是否连通</li>\\n<li>求连通分量个数</li>\\n<li>处理网络、社交关系、群体合并等问题</li>\\n</ul>\\n</li>\\n<li>\\n<p><strong>核心思想</strong>：</p>\\n<ul>\\n<li>每个集合有一个“代表元素”（root）</li>\\n<li>每个元素只保存指向父节点的指针</li>\\n<li>查找元素的根节点可以判断是否属于同一个集合</li>\\n<li>合并两个集合就是把一个集合的根挂到另一个根上</li>\\n</ul>\\n</li>\\n</ul>","autoDesc":true}');export{d as comp,k as data};
