import{_ as t}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as r,a as o,o as a}from"./app-ClTxJrej.js";const n={};function p(i,e){return a(),r("div",null,e[0]||(e[0]=[o('<h1 id="题目" tabindex="-1"><a class="header-anchor" href="#题目"><span>题目</span></a></h1><p>题目描述</p><p>给你一个数组 colors，里面有 1、2、 3 三种颜色。</p><p>我们需要在 colors 上进行一些查询操作 queries，其中每个待查项都由两个整数 i 和 c 组成。</p><p>现在请你帮忙设计一个算法，查找从索引 i 到具有目标颜色 c 的元素之间的最短距离。</p><p>如果不存在解决方案，请返回 -1。</p><p>示例 1：</p><p>输入：colors = [1,1,2,1,3,2,2,3,3], queries = [[1,3],[2,2],[6,1]]<br> 输出：[3,0,3]<br> 解释：<br> 距离索引 1 最近的颜色 3 位于索引 4（距离为 3）。<br> 距离索引 2 最近的颜色 2 就是它自己（距离为 0）。<br> 距离索引 6 最近的颜色 1 位于索引 3（距离为 3）。<br> 示例 2：</p><p>输入：colors = [1,2], queries = [[0,3]]<br> 输出：[-1]<br> 解释：colors 中没有颜色 3。</p><p>提示：</p><p>1 &lt;= colors.length &lt;= 5<em>10^4<br> 1 &lt;= colors[i] &lt;= 3<br> 1 &lt;= queries.length &lt;= 5</em>10^4<br> queries[i].length == 2<br> 0 &lt;= queries[i][0] &lt; colors.length<br> 1 &lt;= queries[i][1] &lt;= 3</p><h1 id="v1-暴力解法" tabindex="-1"><a class="header-anchor" href="#v1-暴力解法"><span>v1-暴力解法</span></a></h1><h2 id="思路" tabindex="-1"><a class="header-anchor" href="#思路"><span>思路</span></a></h2><p>直接 indexOf 比较左右两边。</p><p>此处不不做演示。</p><h1 id="v2-hashmap-二分" tabindex="-1"><a class="header-anchor" href="#v2-hashmap-二分"><span>v2-HashMap+二分</span></a></h1><h2 id="思路-1" tabindex="-1"><a class="header-anchor" href="#思路-1"><span>思路</span></a></h2><p>查找目标 首先我们会想到优化 二分是比较容易想到的方式。</p><p>怎么才能用二分呢？我们的元素无顺序</p><p>题意：距离指定颜色的距离，所以我们如果考虑把相同的颜色放在 list 中呢？这样不就有序了。</p><h2 id="实现" tabindex="-1"><a class="header-anchor" href="#实现"><span>实现</span></a></h2><h1 id="参考资料" tabindex="-1"><a class="header-anchor" href="#参考资料"><span>参考资料</span></a></h1><p><a href="https://leetcode.cn/problems/hanota-lcci/description/?envType=problem-list-v2&amp;envId=recursion" target="_blank" rel="noopener noreferrer">https://leetcode.cn/problems/hanota-lcci/description/?envType=problem-list-v2&amp;envId=recursion</a></p>',23)]))}const l=t(n,[["render",p]]),h=JSON.parse('{"path":"/posts/leetcode/2020-06-06-algorithm-020-leetcode-1882-minest-len-of-color.html","title":"【leetcode】1882-1182. 与目标颜色间的最短距离","lang":"zh-CN","frontmatter":{"title":"【leetcode】1882-1182. 与目标颜色间的最短距离","categories":["Algorithm"],"tags":["algorithm","binary-search","leetcode"],"published":true,"description":"题目 题目描述 给你一个数组 colors，里面有 1、2、 3 三种颜色。 我们需要在 colors 上进行一些查询操作 queries，其中每个待查项都由两个整数 i 和 c 组成。 现在请你帮忙设计一个算法，查找从索引 i 到具有目标颜色 c 的元素之间的最短距离。 如果不存在解决方案，请返回 -1。 示例 1： 输入：colors = [1,1...","head":[["meta",{"property":"og:url","content":"https://houbb.github.io/leetcode-notes/posts/leetcode/2020-06-06-algorithm-020-leetcode-1882-minest-len-of-color.html"}],["meta",{"property":"og:site_name","content":"老马啸西风"}],["meta",{"property":"og:title","content":"【leetcode】1882-1182. 与目标颜色间的最短距离"}],["meta",{"property":"og:description","content":"题目 题目描述 给你一个数组 colors，里面有 1、2、 3 三种颜色。 我们需要在 colors 上进行一些查询操作 queries，其中每个待查项都由两个整数 i 和 c 组成。 现在请你帮忙设计一个算法，查找从索引 i 到具有目标颜色 c 的元素之间的最短距离。 如果不存在解决方案，请返回 -1。 示例 1： 输入：colors = [1,1..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-08-18T06:41:49.000Z"}],["meta",{"property":"article:tag","content":"algorithm"}],["meta",{"property":"article:tag","content":"binary-search"}],["meta",{"property":"article:tag","content":"leetcode"}],["meta",{"property":"article:modified_time","content":"2025-08-18T06:41:49.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"【leetcode】1882-1182. 与目标颜色间的最短距离\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-08-18T06:41:49.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"老马啸西风\\",\\"url\\":\\"https://houbb.github.io\\"}]}"]]},"git":{"createdTime":1755499309000,"updatedTime":1755499309000,"contributors":[{"name":"binbin.hou","username":"","email":"binbin.hou@huifu.com","commits":1}]},"readingTime":{"minutes":1.34,"words":402},"filePathRelative":"posts/leetcode/2020-06-06-algorithm-020-leetcode-1882-minest-len-of-color.md","localizedDate":"2025年8月18日","excerpt":"\\n<p>题目描述</p>\\n<p>给你一个数组 colors，里面有  1、2、 3 三种颜色。</p>\\n<p>我们需要在 colors 上进行一些查询操作 queries，其中每个待查项都由两个整数 i 和 c 组成。</p>\\n<p>现在请你帮忙设计一个算法，查找从索引 i 到具有目标颜色 c 的元素之间的最短距离。</p>\\n<p>如果不存在解决方案，请返回 -1。</p>\\n<p>示例 1：</p>\\n<p>输入：colors = [1,1,2,1,3,2,2,3,3], queries = [[1,3],[2,2],[6,1]]<br>\\n输出：[3,0,3]<br>\\n解释：<br>\\n距离索引 1 最近的颜色 3 位于索引 4（距离为 3）。<br>\\n距离索引 2 最近的颜色 2 就是它自己（距离为 0）。<br>\\n距离索引 6 最近的颜色 1 位于索引 3（距离为 3）。<br>\\n示例 2：</p>","autoDesc":true}');export{l as comp,h as data};
