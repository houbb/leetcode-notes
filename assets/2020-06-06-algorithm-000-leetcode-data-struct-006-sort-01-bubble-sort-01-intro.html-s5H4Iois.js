import{_ as t}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as i,a,o as e}from"./app-BdKLGVT_.js";const r={};function n(h,s){return e(),i("div",null,s[0]||(s[0]=[a(`<h1 id="排序系列" tabindex="-1"><a class="header-anchor" href="#排序系列"><span>排序系列</span></a></h1><p><a href="https://houbb.github.io/2016/07/14/sort-00-overview-sort" target="_blank" rel="noopener noreferrer">sort-00-排序算法汇总</a></p><p><a href="https://houbb.github.io/2016/07/14/sort-01-bubble-sort" target="_blank" rel="noopener noreferrer">sort-01-bubble sort 冒泡排序算法详解</a></p><p><a href="https://houbb.github.io/2016/07/14/sort-02-quick-sort" target="_blank" rel="noopener noreferrer">sort-02-QuickSort 快速排序到底快在哪里？</a></p><p><a href="https://houbb.github.io/2016/07/14/sort-03-select-sort" target="_blank" rel="noopener noreferrer">sort-03-SelectSort 选择排序算法详解</a></p><p><a href="https://houbb.github.io/2016/07/14/sort-04-heap-sort" target="_blank" rel="noopener noreferrer">sort-04-heap sort 堆排序算法详解</a></p><p><a href="https://houbb.github.io/2016/07/14/sort-05-insert-sort" target="_blank" rel="noopener noreferrer">sort-05-insert sort 插入排序算法详解</a></p><p><a href="https://houbb.github.io/2016/07/14/sort-06-shell-sort" target="_blank" rel="noopener noreferrer">sort-06-shell sort 希尔排序算法详解</a></p><p><a href="https://houbb.github.io/2016/07/14/sort-07-merge-sort" target="_blank" rel="noopener noreferrer">sort-07-merge sort 归并排序</a></p><p><a href="https://houbb.github.io/2016/07/14/sort-08-counting-sort" target="_blank" rel="noopener noreferrer">sort-08-counting sort 计数排序</a></p><p><a href="https://houbb.github.io/2016/07/14/sort-09-bucket-sort" target="_blank" rel="noopener noreferrer">sort-09-bucket sort 桶排序</a></p><p><a href="https://houbb.github.io/2016/07/14/sort-10-bigfile-sort" target="_blank" rel="noopener noreferrer">sort-10-bigfile 大文件外部排序</a></p><h1 id="前言" tabindex="-1"><a class="header-anchor" href="#前言"><span>前言</span></a></h1><p>大家好，我是老马。</p><p>以前从工程的角度，已经梳理过一次排序算法。</p><p>这里从力扣算法的角度，重新梳理一遍。</p><p>核心内容包含：</p><p>1）常见排序算法介绍</p><p>2）背后的核心思想</p><p>3）leetcode 经典题目练习+讲解</p><p>4）应用场景、优缺点等对比总结</p><p>5）工程 sdk 包，这个已经完成。</p><ol start="6"><li>可视化</li></ol><h1 id="冒泡排序" tabindex="-1"><a class="header-anchor" href="#冒泡排序"><span>冒泡排序</span></a></h1><h2 id="🫧-一、什么是冒泡排序" tabindex="-1"><a class="header-anchor" href="#🫧-一、什么是冒泡排序"><span>🫧 一、什么是冒泡排序？</span></a></h2><p>冒泡排序是一种<strong>简单直观的比较排序算法</strong>。它的名字来源于“大的元素像气泡一样逐渐浮到顶部”的过程。</p><h2 id="🔧-二、算法原理-核心思想" tabindex="-1"><a class="header-anchor" href="#🔧-二、算法原理-核心思想"><span>🔧 二、算法原理（核心思想）</span></a></h2><p>冒泡排序通过<strong>反复遍历待排序的序列</strong>，每次比较<strong>相邻的两个元素</strong>，如果顺序错误就交换，直到没有元素需要交换为止。</p><h3 id="举例" tabindex="-1"><a class="header-anchor" href="#举例"><span>举例：</span></a></h3><p>排序 <code>[5, 2, 4, 3]</code>：</p><ul><li>第1轮：<code>[2, 4, 3, 5]</code>（5浮到最后）</li><li>第2轮：<code>[2, 3, 4, 5]</code></li><li>第3轮：有序，无需再动</li></ul><h2 id="🧠-三、代码逻辑" tabindex="-1"><a class="header-anchor" href="#🧠-三、代码逻辑"><span>🧠 三、代码逻辑</span></a></h2><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> bubbleSort</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int[]</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> arr</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    int</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> n </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> arr</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">length</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    for</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> i </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 0</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">; i </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">&lt;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> n </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">-</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">; i</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">++</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) {</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">        boolean swapped </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> false</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">  // 优化点：如果一轮无交换说明已有序</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        for</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> j </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 0</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">; j </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">&lt;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> n </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">-</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 1</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> -</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> i; j</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">++</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">            if</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">arr</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">[j] </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">&gt;</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> arr</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">[j </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">+</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">]) {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">                int</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> temp </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> arr</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">[j];</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">                arr</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">[j] </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> arr</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">[j </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">+</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">];</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">                arr</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">[j </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">+</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">] </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> temp;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">                swapped </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> true</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">            }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">        }</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        if</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (</span><span style="--shiki-light:#A626A4;--shiki-dark:#56B6C2;">!</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">swapped) </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">break</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>外层循环控制“轮次”</li><li>内层循环执行“冒泡”：大的向后交换</li></ul><h2 id="📈-四、复杂度分析" tabindex="-1"><a class="header-anchor" href="#📈-四、复杂度分析"><span>📈 四、复杂度分析</span></a></h2><table><thead><tr><th>情况</th><th>比较次数</th><th>交换次数</th><th>时间复杂度</th></tr></thead><tbody><tr><td>最好</td><td>O(n)</td><td>0</td><td>✅ O(n)（优化后）</td></tr><tr><td>最坏</td><td>O(n²)</td><td>O(n²)</td><td>❌ O(n²)</td></tr><tr><td>平均</td><td>O(n²)</td><td>O(n²)</td><td>❌ O(n²)</td></tr><tr><td>空间复杂度</td><td>O(1)（原地排序）</td><td></td><td></td></tr></tbody></table><h2 id="🏷️-五、特点总结" tabindex="-1"><a class="header-anchor" href="#🏷️-五、特点总结"><span>🏷️ 五、特点总结</span></a></h2><table><thead><tr><th>特性</th><th>是否说明</th></tr></thead><tbody><tr><td>原地排序</td><td>✅ 是</td></tr><tr><td>稳定排序</td><td>✅ 是（不打乱相等元素顺序）</td></tr><tr><td>递归实现</td><td>🚫 一般不用</td></tr><tr><td>实现难度</td><td>⭐ 非常简单</td></tr></tbody></table><h2 id="✅-六、冒泡排序的优点-缺点" tabindex="-1"><a class="header-anchor" href="#✅-六、冒泡排序的优点-缺点"><span>✅ 六、冒泡排序的优点 &amp; 缺点</span></a></h2><table><thead><tr><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>实现简单，容易理解</td><td>效率太低，不适合大数据量</td></tr><tr><td>稳定排序</td><td>频繁交换导致性能差</td></tr><tr><td>有“优化空间”（加标志位提前退出）</td><td>时间复杂度最坏仍是 O(n²)</td></tr></tbody></table><h2 id="🧠-七、优化版冒泡排序" tabindex="-1"><a class="header-anchor" href="#🧠-七、优化版冒泡排序"><span>🧠 七、优化版冒泡排序</span></a></h2><ul><li><p><strong>优化 1：加布尔变量 <code>swapped</code></strong></p><ul><li>如果某一轮没有交换，说明已排好序，可以提前退出。</li></ul></li><li><p><strong>优化 2：记录最后一次交换的位置</strong></p><ul><li>可以减少下一轮的比较范围（略复杂）</li></ul></li></ul><h2 id="✅-八、冒泡排序适合的场景" tabindex="-1"><a class="header-anchor" href="#✅-八、冒泡排序适合的场景"><span>✅ 八、冒泡排序适合的场景</span></a></h2><table><thead><tr><th>场景</th><th>说明</th></tr></thead><tbody><tr><td>✅ <strong>数据量小</strong></td><td>比如数组长度 &lt;= 100 的排序问题，冒泡的性能勉强可接受。</td></tr><tr><td>✅ <strong>部分有序的数据</strong></td><td>如果数据接近有序，冒泡排序（带优化）能在 O(n) 内完成排序。</td></tr><tr><td>✅ <strong>对稳定性有要求的简单排序</strong></td><td>冒泡排序是稳定排序，适合处理相同元素保持相对位置的问题。</td></tr><tr><td>✅ <strong>教学演示、入门练习</strong></td><td>冒泡排序的逻辑简单，非常适合用来练习排序、数组操作、交换等基础技巧。</td></tr><tr><td>✅ <strong>需要原地排序（O(1)空间）</strong></td><td>冒泡排序是原地排序，无需额外内存。</td></tr></tbody></table><h1 id="力扣上冒泡排序的经典题目" tabindex="-1"><a class="header-anchor" href="#力扣上冒泡排序的经典题目"><span>力扣上冒泡排序的经典题目</span></a></h1><p>冒泡排序虽然在实际应用中不常用于大规模数据处理，但它<strong>在某些场景下仍然有价值</strong>，特别是：</p><p>虽然力扣大部分题目需要更高效的排序（如快速排序、库函数），但以下这些题目可以通过<strong>冒泡排序解决或辅助理解</strong>：</p><h3 id="🔹-1-leetcode-912-排序数组" tabindex="-1"><a class="header-anchor" href="#🔹-1-leetcode-912-排序数组"><span>🔹 1. <a href="https://leetcode.cn/problems/sort-an-array/" target="_blank" rel="noopener noreferrer">LeetCode 912. 排序数组</a></span></a></h3><ul><li><strong>题目描述</strong>：给你一个整数数组，请将数组升序排序。</li><li>✅ <strong>可以用冒泡排序实现（虽不高效）</strong>，适合练习。</li><li>🔧 但面试中推荐用快排、归并、堆排等。</li></ul><hr><h3 id="🔹-2-leetcode-283-移动零" tabindex="-1"><a class="header-anchor" href="#🔹-2-leetcode-283-移动零"><span>🔹 2. <a href="https://leetcode.cn/problems/move-zeroes/" target="_blank" rel="noopener noreferrer">LeetCode 283. 移动零</a></span></a></h3><ul><li><strong>题目描述</strong>：将所有 0 移动到数组末尾，同时保持非零元素的相对顺序。</li><li>✅ 冒泡思想变形：让 0 不断往后“冒泡”，保持相对顺序 ✅ 稳定性。</li><li>可以不用真的排序，但<strong>冒泡的思想很好用</strong>。</li></ul><hr><h3 id="🔹-3-leetcode-75-颜色分类-荷兰国旗问题" tabindex="-1"><a class="header-anchor" href="#🔹-3-leetcode-75-颜色分类-荷兰国旗问题"><span>🔹 3. <a href="https://leetcode.cn/problems/sort-colors/" target="_blank" rel="noopener noreferrer">LeetCode 75. 颜色分类（荷兰国旗问题）</a></span></a></h3><ul><li>题目描述：只包含 0、1、2 的数组，按颜色顺序排序。</li><li>✅ 可用<strong>冒泡或选择排序变形</strong>实现。</li><li>面试推荐使用双指针更优方式，但冒泡版可以作为思维训练。</li></ul><hr><h3 id="🔹-4-leetcode-1470-重新排列数组" tabindex="-1"><a class="header-anchor" href="#🔹-4-leetcode-1470-重新排列数组"><span>🔹 4. <a href="https://leetcode.cn/problems/shuffle-the-array/" target="_blank" rel="noopener noreferrer">LeetCode 1470. 重新排列数组</a></span></a></h3><ul><li>尽管不是排序题，但涉及到<strong>数组变换</strong>，可以借助冒泡排序巩固交换思维。</li></ul><hr><h2 id="🧠-延伸思考-冒泡排序适合考察什么" tabindex="-1"><a class="header-anchor" href="#🧠-延伸思考-冒泡排序适合考察什么"><span>🧠 延伸思考：冒泡排序适合考察什么？</span></a></h2><ul><li>数组遍历与边界控制</li><li>元素交换的实现</li><li>排序稳定性理解</li><li>时间复杂度、空间复杂度分析</li><li><strong>代码细节敏感度</strong>（如循环条件、优化技巧）</li></ul>`,61)]))}const o=t(r,[["render",n]]),d=JSON.parse('{"path":"/posts/leetcode/2020-06-06-algorithm-000-leetcode-data-struct-006-sort-01-bubble-sort-01-intro.html","title":"leetcode sort 排序-01-bubbleSort 冒泡排序入门介绍","lang":"zh-CN","frontmatter":{"title":"leetcode sort 排序-01-bubbleSort 冒泡排序入门介绍","date":"2020-06-08T00:00:00.000Z","categories":["Algorithm"],"tags":["algorithm","sort","sf"],"published":true,"description":"排序系列 sort-00-排序算法汇总 sort-01-bubble sort 冒泡排序算法详解 sort-02-QuickSort 快速排序到底快在哪里？ sort-03-SelectSort 选择排序算法详解 sort-04-heap sort 堆排序算法详解 sort-05-insert sort 插入排序算法详解 sort-06-shell s...","head":[["meta",{"property":"og:url","content":"https://houbb.github.io/leetcode-notes/posts/leetcode/2020-06-06-algorithm-000-leetcode-data-struct-006-sort-01-bubble-sort-01-intro.html"}],["meta",{"property":"og:site_name","content":"老马啸西风"}],["meta",{"property":"og:title","content":"leetcode sort 排序-01-bubbleSort 冒泡排序入门介绍"}],["meta",{"property":"og:description","content":"排序系列 sort-00-排序算法汇总 sort-01-bubble sort 冒泡排序算法详解 sort-02-QuickSort 快速排序到底快在哪里？ sort-03-SelectSort 选择排序算法详解 sort-04-heap sort 堆排序算法详解 sort-05-insert sort 插入排序算法详解 sort-06-shell s..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-08-18T07:11:43.000Z"}],["meta",{"property":"article:tag","content":"algorithm"}],["meta",{"property":"article:tag","content":"sort"}],["meta",{"property":"article:tag","content":"sf"}],["meta",{"property":"article:published_time","content":"2020-06-08T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2025-08-18T07:11:43.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"leetcode sort 排序-01-bubbleSort 冒泡排序入门介绍\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2020-06-08T00:00:00.000Z\\",\\"dateModified\\":\\"2025-08-18T07:11:43.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"老马啸西风\\",\\"url\\":\\"https://houbb.github.io\\"}]}"]]},"git":{"createdTime":1755499309000,"updatedTime":1755501103000,"contributors":[{"name":"binbin.hou","username":"","email":"binbin.hou@huifu.com","commits":2}]},"readingTime":{"minutes":4.59,"words":1377},"filePathRelative":"posts/leetcode/2020-06-06-algorithm-000-leetcode-data-struct-006-sort-01-bubble-sort-01-intro.md","localizedDate":"2020年6月8日","excerpt":"\\n<p><a href=\\"https://houbb.github.io/2016/07/14/sort-00-overview-sort\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">sort-00-排序算法汇总</a></p>\\n<p><a href=\\"https://houbb.github.io/2016/07/14/sort-01-bubble-sort\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">sort-01-bubble sort 冒泡排序算法详解</a></p>\\n<p><a href=\\"https://houbb.github.io/2016/07/14/sort-02-quick-sort\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">sort-02-QuickSort 快速排序到底快在哪里？</a></p>","autoDesc":true}');export{o as comp,d as data};
