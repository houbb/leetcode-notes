import{_ as i}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as t,a,o as n}from"./app-CPAfAraT.js";const e={};function h(r,s){return n(),t("div",null,s[0]||(s[0]=[a(`<h1 id="排序系列" tabindex="-1"><a class="header-anchor" href="#排序系列"><span>排序系列</span></a></h1><p><a href="https://houbb.github.io/2016/07/14/sort-00-overview-sort" target="_blank" rel="noopener noreferrer">sort-00-排序算法汇总</a></p><p><a href="https://houbb.github.io/2016/07/14/sort-01-bubble-sort" target="_blank" rel="noopener noreferrer">sort-01-bubble sort 冒泡排序算法详解</a></p><p><a href="https://houbb.github.io/2016/07/14/sort-02-quick-sort" target="_blank" rel="noopener noreferrer">sort-02-QuickSort 快速排序到底快在哪里？</a></p><p><a href="https://houbb.github.io/2016/07/14/sort-03-select-sort" target="_blank" rel="noopener noreferrer">sort-03-SelectSort 选择排序算法详解</a></p><p><a href="https://houbb.github.io/2016/07/14/sort-04-heap-sort" target="_blank" rel="noopener noreferrer">sort-04-heap sort 堆排序算法详解</a></p><p><a href="https://houbb.github.io/2016/07/14/sort-05-insert-sort" target="_blank" rel="noopener noreferrer">sort-05-insert sort 插入排序算法详解</a></p><p><a href="https://houbb.github.io/2016/07/14/sort-06-shell-sort" target="_blank" rel="noopener noreferrer">sort-06-shell sort 希尔排序算法详解</a></p><p><a href="https://houbb.github.io/2016/07/14/sort-07-merge-sort" target="_blank" rel="noopener noreferrer">sort-07-merge sort 归并排序</a></p><p><a href="https://houbb.github.io/2016/07/14/sort-08-counting-sort" target="_blank" rel="noopener noreferrer">sort-08-counting sort 计数排序</a></p><p><a href="https://houbb.github.io/2016/07/14/sort-09-bucket-sort" target="_blank" rel="noopener noreferrer">sort-09-bucket sort 桶排序</a></p><p><a href="https://houbb.github.io/2016/07/14/sort-10-bigfile-sort" target="_blank" rel="noopener noreferrer">sort-10-bigfile 大文件外部排序</a></p><h1 id="前言" tabindex="-1"><a class="header-anchor" href="#前言"><span>前言</span></a></h1><p>大家好，我是老马。</p><p>以前从工程的角度，已经梳理过一次排序算法。</p><p>这里从力扣算法的角度，重新梳理一遍。</p><p>核心内容包含：</p><p>1）常见排序算法介绍</p><p>2）背后的核心思想</p><p>3）leetcode 经典题目练习+讲解</p><p>4）应用场景、优缺点等对比总结</p><p>5）工程 sdk 包，这个已经完成。</p><ol start="6"><li>可视化</li></ol><h1 id="快速排序-quick-sort" tabindex="-1"><a class="header-anchor" href="#快速排序-quick-sort"><span>快速排序（quick Sort）</span></a></h1><h2 id="📌-一、快速排序简介" tabindex="-1"><a class="header-anchor" href="#📌-一、快速排序简介"><span>📌 一、快速排序简介</span></a></h2><p><strong>快速排序（Quick Sort）</strong> 是一种经典的 <strong>分治算法</strong>，被誉为“实际应用中表现最好的排序算法之一”。</p><blockquote><p><strong>核心思想：通过一次划分将数组分成两个部分，左边都比基准小，右边都比基准大，然后递归排序左右两部分。</strong></p></blockquote><hr><h2 id="🧠-二、核心算法思想-分治-原地划分" tabindex="-1"><a class="header-anchor" href="#🧠-二、核心算法思想-分治-原地划分"><span>🧠 二、核心算法思想：<strong>分治 + 原地划分</strong></span></a></h2><ol><li><strong>选定一个“基准值”（pivot）</strong></li><li><strong>将数组按“基准值”进行划分</strong>：小的放左边，大的放右边</li><li><strong>递归排序左右子数组</strong></li></ol><hr><h2 id="🎯-三、图解流程-以-3-6-1-5-2-4-为例" tabindex="-1"><a class="header-anchor" href="#🎯-三、图解流程-以-3-6-1-5-2-4-为例"><span>🎯 三、图解流程（以 <code>[3, 6, 1, 5, 2, 4]</code> 为例）</span></a></h2><ol><li>选择 pivot = <code>3</code>（常选第一个/最后一个/随机/中位数）</li><li>排列成 <code>[1, 2, 3, 6, 5, 4]</code> （小于3的在左边，大于3的在右边）</li><li>对 <code>[1,2]</code> 和 <code>[6,5,4]</code> 分别递归</li><li><code>[6,5,4]</code> 继续选 pivot = 6 → <code>[5,4,6]</code></li><li>最终得到有序数组 <code>[1,2,3,4,5,6]</code></li></ol><hr><h2 id="✅-四、java-代码实现-原地快速排序" tabindex="-1"><a class="header-anchor" href="#✅-四、java-代码实现-原地快速排序"><span>✅ 四、Java 代码实现（原地快速排序）</span></a></h2><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> quickSort</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(</span><span style="--shiki-light:#C18401;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">[] arr) {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    if</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> (arr </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">==</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> null</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> ||</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> arr</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">length</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> &lt;</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 2</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">) </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">return</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">    quickSortRecursive</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(arr</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 0</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> arr</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">length</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> -</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 1</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">)</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">private</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> quickSortRecursive</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(</span><span style="--shiki-light:#C18401;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">[] arr</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> int</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> left</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> int</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> right) {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    if</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> (left </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">&gt;=</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> right) </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">return</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    int</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> pivotIndex </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> partition</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(arr</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> left</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> right)</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">    quickSortRecursive</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(arr</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> left</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> pivotIndex </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">-</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 1</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">)</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">    quickSortRecursive</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(arr</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> pivotIndex </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">+</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> right)</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">private</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> int</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> partition</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(</span><span style="--shiki-light:#C18401;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">[] arr</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> int</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> left</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> int</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> right) {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    int</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> pivot </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> arr[right]</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">  // 以最后一个为基准</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    int</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> i </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> left</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    for</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> (</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> j </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> left</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> j </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">&lt;</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> right</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> j</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">++</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">) {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        if</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> (arr[j] </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">&lt;</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> pivot) {</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">            swap</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(arr</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> i</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> j)</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">            i</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">++;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">        }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">    swap</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(arr</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> i</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> right)</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    return</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> i</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">private</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> swap</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(</span><span style="--shiki-light:#C18401;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">[] arr</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> int</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> i</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> int</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> j) {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    int</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> temp </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> arr[i]</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> arr[i] </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> arr[j]</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> arr[j] </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> temp</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr><h2 id="📈-五、复杂度分析" tabindex="-1"><a class="header-anchor" href="#📈-五、复杂度分析"><span>📈 五、复杂度分析</span></a></h2><table><thead><tr><th>情况</th><th>时间复杂度</th><th>空间复杂度</th><th>是否稳定</th></tr></thead><tbody><tr><td>最好情况</td><td>O(n log n)</td><td>O(log n)</td><td>❌ 不稳定</td></tr><tr><td>最坏情况</td><td>O(n²)</td><td>O(log n)</td><td>❌ 不稳定</td></tr><tr><td>平均情况</td><td>O(n log n)</td><td>O(log n)</td><td>❌ 不稳定</td></tr></tbody></table><blockquote><p>最坏情况是 pivot 每次都选到了最大或最小值（例如已排好序时），可以通过随机选 pivot 来避免。</p></blockquote><hr><h2 id="⚖️-六、优缺点总结" tabindex="-1"><a class="header-anchor" href="#⚖️-六、优缺点总结"><span>⚖️ 六、优缺点总结</span></a></h2><table><thead><tr><th>✅ 优点</th><th>❌ 缺点</th></tr></thead><tbody><tr><td>平均性能非常快（比归并、堆排序快）</td><td>最坏 O(n²)</td></tr><tr><td>原地排序，空间开销小</td><td>不稳定排序</td></tr><tr><td>分治结构，易于优化并行化</td><td>实现略复杂于插排、冒泡</td></tr></tbody></table><hr><h2 id="🧰-七、适用场景分析" tabindex="-1"><a class="header-anchor" href="#🧰-七、适用场景分析"><span>🧰 七、适用场景分析</span></a></h2><table><thead><tr><th>场景</th><th>是否推荐</th></tr></thead><tbody><tr><td>✅ 大规模数据排序</td><td>非常推荐</td></tr><tr><td>✅ 内存敏感场景（空间小）</td><td>推荐</td></tr><tr><td>❌ 要求稳定排序（值相等时顺序不变）</td><td>不推荐</td></tr><tr><td>❌ 数据基本有序</td><td>不推荐（会退化）</td></tr></tbody></table><hr><h2 id="🧩-八、leetcode-推荐题目" tabindex="-1"><a class="header-anchor" href="#🧩-八、leetcode-推荐题目"><span>🧩 八、LeetCode 推荐题目</span></a></h2><h3 id="🔹-912-排序数组" tabindex="-1"><a class="header-anchor" href="#🔹-912-排序数组"><span>🔹 <a href="https://leetcode.cn/problems/sort-an-array/" target="_blank" rel="noopener noreferrer">912. 排序数组</a></span></a></h3><ul><li>经典实现快排的题目</li></ul><h3 id="🔹-215-数组中的第-k-个最大元素" tabindex="-1"><a class="header-anchor" href="#🔹-215-数组中的第-k-个最大元素"><span>🔹 <a href="https://leetcode.cn/problems/kth-largest-element-in-an-array/" target="_blank" rel="noopener noreferrer">215. 数组中的第 K 个最大元素</a></span></a></h3><ul><li>可以用快速选择（QuickSelect，基于快排）实现</li></ul><h3 id="🔹-973-最接近原点的-k-个点" tabindex="-1"><a class="header-anchor" href="#🔹-973-最接近原点的-k-个点"><span>🔹 <a href="https://leetcode.cn/problems/k-closest-points-to-origin/" target="_blank" rel="noopener noreferrer">973. 最接近原点的 K 个点</a></span></a></h3><ul><li>使用快排变种 + 距离函数</li></ul><hr><h2 id="🆚-九、快速排序-vs-其他排序算法对比" tabindex="-1"><a class="header-anchor" href="#🆚-九、快速排序-vs-其他排序算法对比"><span>🆚 九、快速排序 vs 其他排序算法对比</span></a></h2><table><thead><tr><th>算法</th><th>时间复杂度</th><th>空间复杂度</th><th>稳定性</th><th>适合数据</th></tr></thead><tbody><tr><td>快排</td><td>O(n log n)</td><td>O(log n)</td><td>❌</td><td>大量随机数据</td></tr><tr><td>归并排序</td><td>O(n log n)</td><td>O(n)</td><td>✅</td><td>稳定需求/链表</td></tr><tr><td>堆排序</td><td>O(n log n)</td><td>O(1)</td><td>❌</td><td>内存敏感</td></tr><tr><td>插入排序</td><td>O(n²)</td><td>O(1)</td><td>✅</td><td>小规模、基本有序</td></tr><tr><td>冒泡排序</td><td>O(n²)</td><td>O(1)</td><td>✅</td><td>教学/理解用途</td></tr></tbody></table><hr><h2 id="🔚-十、一句话总结" tabindex="-1"><a class="header-anchor" href="#🔚-十、一句话总结"><span>🔚 十、一句话总结</span></a></h2><blockquote><p><strong>快速排序 = 分治 + 原地划分 + 递归排序，平均性能最优，空间占用低，是实际应用中最常用的高性能排序算法之一。</strong></p></blockquote><h1 id="疑问" tabindex="-1"><a class="header-anchor" href="#疑问"><span>疑问</span></a></h1><h2 id="为什么快速排序最后能让数组有序" tabindex="-1"><a class="header-anchor" href="#为什么快速排序最后能让数组有序"><span>为什么快速排序最后能让数组有序？</span></a></h2><p>关键在于：<strong>递归地“分区 + 排序”</strong></p><p>快速排序每次都会选择一个 <strong>pivot（基准值）</strong>，然后做三件事：</p><ol><li><p>分区：把数组分成两部分：</p><ul><li>一部分是 ≤ pivot 的元素</li><li>另一部分是 &gt; pivot 的元素</li></ul></li><li><p>pivot 被放到了它最终的位置上！</p></li><li><p>然后我们对这两部分分别继续做快速排序（递归）</p></li></ol><p>这个过程会持续地把数组切小，直到每个部分都只有一个元素为止。</p><h2 id="为什么叫「快速排序」-它真的快吗" tabindex="-1"><a class="header-anchor" href="#为什么叫「快速排序」-它真的快吗"><span>为什么叫「快速排序」？它真的快吗？</span></a></h2><p>它通常非常快！原因有两个：</p><ol><li><strong>每次都能“分而治之”，减少比较次数</strong></li></ol><p>相比于像冒泡排序那样一个个交换，快速排序每次都能分成两段，把问题规模砍半，非常高效。</p><ol start="2"><li><strong>数据原地排序，不需要额外空间（不像归并排序那样需要临时数组）</strong></li></ol>`,71)]))}const k=i(e,[["render",h]]),d=JSON.parse('{"path":"/posts/leetcode/2020-06-06-algorithm-000-leetcode-data-struct-006-sort-05-quick-sort-01-intro.html","title":"leetcode sort 排序-04-quickSort 快速排序入门介绍","lang":"zh-CN","frontmatter":{"title":"leetcode sort 排序-04-quickSort 快速排序入门介绍","categories":["Algorithm"],"tags":["algorithm","sort","sf"],"published":true,"description":"排序系列 sort-00-排序算法汇总 sort-01-bubble sort 冒泡排序算法详解 sort-02-QuickSort 快速排序到底快在哪里？ sort-03-SelectSort 选择排序算法详解 sort-04-heap sort 堆排序算法详解 sort-05-insert sort 插入排序算法详解 sort-06-shell s...","head":[["meta",{"property":"og:url","content":"https://houbb.github.io/leetcode-notes/posts/leetcode/2020-06-06-algorithm-000-leetcode-data-struct-006-sort-05-quick-sort-01-intro.html"}],["meta",{"property":"og:site_name","content":"老马啸西风"}],["meta",{"property":"og:title","content":"leetcode sort 排序-04-quickSort 快速排序入门介绍"}],["meta",{"property":"og:description","content":"排序系列 sort-00-排序算法汇总 sort-01-bubble sort 冒泡排序算法详解 sort-02-QuickSort 快速排序到底快在哪里？ sort-03-SelectSort 选择排序算法详解 sort-04-heap sort 堆排序算法详解 sort-05-insert sort 插入排序算法详解 sort-06-shell s..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-08-18T06:41:49.000Z"}],["meta",{"property":"article:tag","content":"algorithm"}],["meta",{"property":"article:tag","content":"sort"}],["meta",{"property":"article:tag","content":"sf"}],["meta",{"property":"article:modified_time","content":"2025-08-18T06:41:49.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"leetcode sort 排序-04-quickSort 快速排序入门介绍\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-08-18T06:41:49.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"老马啸西风\\",\\"url\\":\\"https://houbb.github.io\\"}]}"]]},"git":{"createdTime":1755499309000,"updatedTime":1755499309000,"contributors":[{"name":"binbin.hou","username":"","email":"binbin.hou@huifu.com","commits":1}]},"readingTime":{"minutes":4.63,"words":1388},"filePathRelative":"posts/leetcode/2020-06-06-algorithm-000-leetcode-data-struct-006-sort-05-quick-sort-01-intro.md","localizedDate":"2025年8月18日","excerpt":"\\n<p><a href=\\"https://houbb.github.io/2016/07/14/sort-00-overview-sort\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">sort-00-排序算法汇总</a></p>\\n<p><a href=\\"https://houbb.github.io/2016/07/14/sort-01-bubble-sort\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">sort-01-bubble sort 冒泡排序算法详解</a></p>\\n<p><a href=\\"https://houbb.github.io/2016/07/14/sort-02-quick-sort\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">sort-02-QuickSort 快速排序到底快在哪里？</a></p>","autoDesc":true}');export{k as comp,d as data};
