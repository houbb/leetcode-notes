import{_ as s}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as a,a as n,o as e}from"./app-BXEJzcOL.js";const l={};function h(t,i){return e(),a("div",null,i[0]||(i[0]=[n(`<h1 id="前缀树-trie" tabindex="-1"><a class="header-anchor" href="#前缀树-trie"><span>前缀树（Trie）</span></a></h1><h2 id="_1️⃣-前缀树的概念" tabindex="-1"><a class="header-anchor" href="#_1️⃣-前缀树的概念"><span>1️⃣ 前缀树的概念</span></a></h2><p>前缀树，又叫 <strong>字典树（Trie）</strong>，是一种树形数据结构，用于 <strong>高效存储和查找字符串集合</strong>，尤其擅长处理 <strong>前缀匹配问题</strong>。</p><p>特点：</p><ol><li><p>每个节点表示一个字符串的 <strong>前缀</strong>，根节点表示空字符串。</p></li><li><p>从根节点到某个节点的路径，形成了该节点所代表的字符串前缀。</p></li><li><p>节点通常包含：</p><ul><li>子节点指针（可以是数组、哈希表等）</li><li>是否为完整字符串的标记（例如 <code>isEnd</code>）</li></ul></li></ol><p><strong>核心思想</strong>：公共前缀只存储一次，节省空间，并且查找操作复杂度与字符串长度相关，而不是与集合大小成正比。</p><hr><h2 id="_2️⃣-前缀树的结构" tabindex="-1"><a class="header-anchor" href="#_2️⃣-前缀树的结构"><span>2️⃣ 前缀树的结构</span></a></h2><p>举个例子，我们有字符串集合：<code>[&quot;cat&quot;, &quot;cap&quot;, &quot;can&quot;]</code>。</p><p>前缀树可表示为：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>        root</span></span>
<span class="line"><span>       /    </span></span>
<span class="line"><span>      c</span></span>
<span class="line"><span>     / </span></span>
<span class="line"><span>    a</span></span>
<span class="line"><span>   /|\\</span></span>
<span class="line"><span>  t p n</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><code>c → a → t</code> 表示 <code>&quot;cat&quot;</code></li><li><code>c → a → p</code> 表示 <code>&quot;cap&quot;</code></li><li><code>c → a → n</code> 表示 <code>&quot;can&quot;</code></li><li>节点 <code>t</code>, <code>p</code>, <code>n</code> 的 <code>isEnd = true</code> 表示字符串结束</li></ul><p>如果有 <code>&quot;bat&quot;</code>，结构会变成：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>        root</span></span>
<span class="line"><span>       /    \\</span></span>
<span class="line"><span>      c      b</span></span>
<span class="line"><span>     /       \\</span></span>
<span class="line"><span>    a         a</span></span>
<span class="line"><span>   /|\\         \\</span></span>
<span class="line"><span>  t p n         t</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr><h2 id="_3️⃣-前缀树的常见操作" tabindex="-1"><a class="header-anchor" href="#_3️⃣-前缀树的常见操作"><span>3️⃣ 前缀树的常见操作</span></a></h2><p>假设我们用一个简单的类结构表示节点：</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">class</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> TrieNode</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    boolean</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> isEnd</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">    Map</span><span style="--shiki-light:#E45649;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">Character</span><span style="--shiki-light:#E45649;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> TrieNode</span><span style="--shiki-light:#E45649;--shiki-dark:#ABB2BF;">&gt;</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> children </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> HashMap</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&lt;&gt;</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">()</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_3-1-插入-insert" tabindex="-1"><a class="header-anchor" href="#_3-1-插入-insert"><span>3.1 插入（Insert）</span></a></h3><p>向前缀树中插入字符串：</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> insert</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">String</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> word) {</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">    TrieNode</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> node </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> root</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    for</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> (</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">char</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> ch </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">:</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> word</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">toCharArray</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">()</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">) {</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">        node</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">children</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">putIfAbsent</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(ch, </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">new</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> TrieNode</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">());</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">        node </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> node</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">children</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">get</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(ch);</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">    }</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">    node</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">isEnd</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> true</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>时间复杂度</strong>：O(L)，L = 字符串长度</p><hr><h3 id="_3-2-查询-search" tabindex="-1"><a class="header-anchor" href="#_3-2-查询-search"><span>3.2 查询（Search）</span></a></h3><p>判断字符串是否存在：</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">boolean</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> search</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">String</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> word) {</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">    TrieNode</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> node </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> root</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    for</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> (</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">char</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> ch </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">:</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> word</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">toCharArray</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">()</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">) {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        if</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> (</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">!</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">node</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">children</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">containsKey</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(ch)</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">) </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">return</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> false</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">        node </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> node</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">children</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">get</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(ch);</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">    }</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    return</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> node</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">isEnd</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>时间复杂度</strong>：O(L)</p><hr><h3 id="_3-3-前缀查询-startswith" tabindex="-1"><a class="header-anchor" href="#_3-3-前缀查询-startswith"><span>3.3 前缀查询（StartsWith）</span></a></h3><p>判断是否存在某个前缀：</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">boolean</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> startsWith</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">String</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> prefix) {</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">    TrieNode</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> node </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> root</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    for</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> (</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">char</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> ch </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">:</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> prefix</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">toCharArray</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">()</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">) {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        if</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> (</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">!</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">node</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">children</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">containsKey</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(ch)</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">) </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">return</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> false</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">        node </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> node</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">children</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">get</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(ch);</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">    }</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    return</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> true</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>前缀查询非常快，因为只需要遍历前缀长度，不需要遍历整个集合。</li></ul><hr><h2 id="_4️⃣-前缀树的变体" tabindex="-1"><a class="header-anchor" href="#_4️⃣-前缀树的变体"><span>4️⃣ 前缀树的变体</span></a></h2><ol><li><strong>数组代替哈希表</strong><br> 如果字符集固定（如小写字母 a–z），用 <code>TrieNode[26]</code> 代替 <code>Map</code> 更快、更省内存。</li></ol><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">class</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> TrieNode</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    boolean</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> isEnd</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">    TrieNode</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">[] children </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> TrieNode</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">[</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">26</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">]</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="2"><li><p><strong>压缩前缀树（Radix Tree）</strong><br> 当一个节点只有一个子节点时，可以将路径压缩成一个字符串，减少空间。</p></li><li><p><strong>后缀树</strong><br> 存储字符串所有后缀，方便做模式匹配、字符串统计。</p></li></ol><hr><h2 id="_5️⃣-前缀树的应用场景" tabindex="-1"><a class="header-anchor" href="#_5️⃣-前缀树的应用场景"><span>5️⃣ 前缀树的应用场景</span></a></h2><ol><li><p><strong>单词搜索 / 拼写检查</strong></p><ul><li>自动补全：输入 <code>&quot;ca&quot;</code> → <code>&quot;cat&quot;</code>, <code>&quot;cap&quot;</code>, <code>&quot;can&quot;</code></li><li>单词是否存在</li></ul></li><li><p><strong>前缀统计</strong></p><ul><li>查询某前缀出现次数（比如搜索引擎建议）</li></ul></li><li><p><strong>字符串集合的高效匹配</strong></p><ul><li>如敏感词过滤</li><li>DNA序列匹配</li></ul></li><li><p><strong>多字符串最长公共前缀</strong></p><ul><li>可以快速找到公共前缀，复杂度 O(L × N)</li></ul></li><li><p><strong>LeetCode 相关题</strong></p><ul><li>LC 208. 实现 Trie</li><li>LC 720. 词典中最长的单词</li></ul></li></ol><hr><h2 id="_6️⃣-总结" tabindex="-1"><a class="header-anchor" href="#_6️⃣-总结"><span>6️⃣ 总结</span></a></h2><ul><li>Trie 是一种 <strong>以空间换时间</strong> 的字符串集合存储结构。</li><li>查找、插入、前缀查询复杂度与字符串长度相关，而与集合大小无关。</li><li>适合 <strong>大量字符串和前缀操作</strong> 场景。</li><li>可以用 <strong>数组或哈希表</strong> 存储子节点，根据字符集大小选择。</li></ul>`,43)]))}const r=s(l,[["render",h]]),d=JSON.parse('{"path":"/posts/algorithm/2025-10-06-trie-tree-01-intro.html","title":"Trie (前缀树)","lang":"zh-CN","frontmatter":{"title":"Trie (前缀树)","date":"2025-10-06T00:00:00.000Z","categories":["Althgorim"],"tags":["althgorim","trie"],"published":true,"description":"前缀树（Trie） 1️⃣ 前缀树的概念 前缀树，又叫 字典树（Trie），是一种树形数据结构，用于 高效存储和查找字符串集合，尤其擅长处理 前缀匹配问题。 特点： 每个节点表示一个字符串的 前缀，根节点表示空字符串。 从根节点到某个节点的路径，形成了该节点所代表的字符串前缀。 节点通常包含： 子节点指针（可以是数组、哈希表等） 是否为完整字符串的标记...","head":[["meta",{"property":"og:url","content":"https://houbb.github.io/leetcode-notes/posts/algorithm/2025-10-06-trie-tree-01-intro.html"}],["meta",{"property":"og:site_name","content":"老马啸西风"}],["meta",{"property":"og:title","content":"Trie (前缀树)"}],["meta",{"property":"og:description","content":"前缀树（Trie） 1️⃣ 前缀树的概念 前缀树，又叫 字典树（Trie），是一种树形数据结构，用于 高效存储和查找字符串集合，尤其擅长处理 前缀匹配问题。 特点： 每个节点表示一个字符串的 前缀，根节点表示空字符串。 从根节点到某个节点的路径，形成了该节点所代表的字符串前缀。 节点通常包含： 子节点指针（可以是数组、哈希表等） 是否为完整字符串的标记..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-10-07T19:10:11.000Z"}],["meta",{"property":"article:tag","content":"althgorim"}],["meta",{"property":"article:tag","content":"trie"}],["meta",{"property":"article:published_time","content":"2025-10-06T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2025-10-07T19:10:11.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Trie (前缀树)\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2025-10-06T00:00:00.000Z\\",\\"dateModified\\":\\"2025-10-07T19:10:11.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"老马啸西风\\",\\"url\\":\\"https://houbb.github.io\\"}]}"]]},"git":{"createdTime":1759739505000,"updatedTime":1759864211000,"contributors":[{"name":"bbhou","username":"bbhou","email":"1557740299@qq.com","commits":2,"url":"https://github.com/bbhou"}]},"readingTime":{"minutes":2.72,"words":817},"filePathRelative":"posts/algorithm/2025-10-06-trie-tree-01-intro.md","localizedDate":"2025年10月6日","excerpt":"\\n<h2>1️⃣ 前缀树的概念</h2>\\n<p>前缀树，又叫 <strong>字典树（Trie）</strong>，是一种树形数据结构，用于 <strong>高效存储和查找字符串集合</strong>，尤其擅长处理 <strong>前缀匹配问题</strong>。</p>\\n<p>特点：</p>\\n<ol>\\n<li>\\n<p>每个节点表示一个字符串的 <strong>前缀</strong>，根节点表示空字符串。</p>\\n</li>\\n<li>\\n<p>从根节点到某个节点的路径，形成了该节点所代表的字符串前缀。</p>\\n</li>\\n<li>\\n<p>节点通常包含：</p>\\n<ul>\\n<li>子节点指针（可以是数组、哈希表等）</li>\\n<li>是否为完整字符串的标记（例如 <code>isEnd</code>）</li>\\n</ul>\\n</li>\\n</ol>","autoDesc":true}');export{r as comp,d as data};
