import{_ as i}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as a,a as t,o as e}from"./app-DP7ZrycQ.js";const n={};function l(p,s){return e(),a("div",null,s[0]||(s[0]=[t(`<h1 id="lc112-路径总和-path-sum" tabindex="-1"><a class="header-anchor" href="#lc112-路径总和-path-sum"><span>LC112. 路径总和 path-sum</span></a></h1><p>给你二叉树的根节点 root 和一个表示目标和的整数 targetSum 。</p><p>判断该树中是否存在 根节点到叶子节点 的路径，这条路径上所有节点值相加等于目标和 targetSum 。</p><p>如果存在，返回 true ；否则，返回 false 。</p><p>叶子节点 是指没有子节点的节点。</p><p>示例 1：</p><figure><img src="https://assets.leetcode.com/uploads/2021/01/18/pathsum1.jpg" alt="1" tabindex="0" loading="lazy"><figcaption>1</figcaption></figure><p>输入：root = [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum = 22<br> 输出：true<br> 解释：等于目标和的根节点到叶节点路径如上图所示。</p><p>示例 2：</p><figure><img src="https://assets.leetcode.com/uploads/2021/01/18/pathsum2.jpg" alt="2" tabindex="0" loading="lazy"><figcaption>2</figcaption></figure><p>输入：root = [1,2,3], targetSum = 5<br> 输出：false<br> 解释：树中存在两条根节点到叶子节点的路径：<br> (1 --&gt; 2): 和为 3<br> (1 --&gt; 3): 和为 4<br> 不存在 sum = 5 的根节点到叶子节点的路径。</p><p>示例 3：</p><p>输入：root = [], targetSum = 0<br> 输出：false<br> 解释：由于树是空的，所以不存在根节点到叶子节点的路径。</p><p>提示：</p><p>树中节点的数目在范围 [0, 5000] 内<br> -1000 &lt;= Node.val &lt;= 1000<br> -1000 &lt;= targetSum &lt;= 1000</p><h1 id="v1-dfs" tabindex="-1"><a class="header-anchor" href="#v1-dfs"><span>v1-DFS</span></a></h1><h2 id="思路" tabindex="-1"><a class="header-anchor" href="#思路"><span>思路</span></a></h2><ol><li>路径要求限制</li></ol><p>必须从根开始。所以入口是固定的，就是 root。</p><p>必须到叶子结束。所以你不能中途停下来，必须走到一个没有子节点的位置。</p><ol start="2"><li>每走一步的思路</li></ol><p>当你走到一个节点时，减掉当前值即可（targetSum - node.val）。</p><p>然后问题就变成了：在这个节点的左子树或右子树中，是否存在一条符合“剩余和”的路径？</p><ol start="3"><li>递归的分解</li></ol><p>当前节点如果是叶子节点，那就直接检查剩余值是否正好等于它的值。</p><p>如果不是叶子，就把问题丢给左右子树去做。</p><h2 id="实现" tabindex="-1"><a class="header-anchor" href="#实现"><span>实现</span></a></h2><p>代码并不复杂</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> boolean</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> hasPathSum</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">TreeNode</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> root</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> int</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> targetSum) {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        if</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(root </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">==</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> null</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">) {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">            return</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> false</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">        }   </span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">        // 当前节点是否为叶子</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        if</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">root</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">left</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> ==</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> null</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> &amp;&amp;</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> root</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">right</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> ==</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> null</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">) {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">            return</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> targetSum </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">==</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> root</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">val</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">        }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">        // 递归处理</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">        // 左右子树任何一边满足即可</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        int</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> remain </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> targetSum </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">-</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> root</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">val</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        return</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> hasPathSum</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">root</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">left</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> remain) </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">||</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> hasPathSum</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">root</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">right</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> remain)</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">    }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="效果" tabindex="-1"><a class="header-anchor" href="#效果"><span>效果</span></a></h2><p>0ms 100%</p><h2 id="复杂度" tabindex="-1"><a class="header-anchor" href="#复杂度"><span>复杂度</span></a></h2><p>时间复杂度：O(n)，其中 n 是二叉树的节点数。</p><p>空间复杂度：O(h)，h 为树的高度（最坏 O(n)，平均 O(log n)）</p><h2 id="反思" tabindex="-1"><a class="header-anchor" href="#反思"><span>反思</span></a></h2><p>这一题是这个路径累加和的基础，我们可以在这个基础上拓展一下，好好学一下这个系列。</p><h1 id="参考资料" tabindex="-1"><a class="header-anchor" href="#参考资料"><span>参考资料</span></a></h1>`,37)]))}const k=i(n,[["render",l]]),d=JSON.parse('{"path":"/posts/leetcode/leetcode-75/2025-09-28-binary-tree-04-LC112-path-sum.html","title":"LC112. 路径总和 path-sum","lang":"zh-CN","frontmatter":{"title":"LC112. 路径总和 path-sum","date":"2025-09-24T00:00:00.000Z","categories":["Leetcode-75"],"tags":["leetcode","Leetcode-75","binary-tree"],"published":true,"description":"LC112. 路径总和 path-sum 给你二叉树的根节点 root 和一个表示目标和的整数 targetSum 。 判断该树中是否存在 根节点到叶子节点 的路径，这条路径上所有节点值相加等于目标和 targetSum 。 如果存在，返回 true ；否则，返回 false 。 叶子节点 是指没有子节点的节点。 示例 1： 11 输入：root = ...","head":[["meta",{"property":"og:url","content":"https://houbb.github.io/leetcode-notes/posts/leetcode/leetcode-75/2025-09-28-binary-tree-04-LC112-path-sum.html"}],["meta",{"property":"og:site_name","content":"老马啸西风"}],["meta",{"property":"og:title","content":"LC112. 路径总和 path-sum"}],["meta",{"property":"og:description","content":"LC112. 路径总和 path-sum 给你二叉树的根节点 root 和一个表示目标和的整数 targetSum 。 判断该树中是否存在 根节点到叶子节点 的路径，这条路径上所有节点值相加等于目标和 targetSum 。 如果存在，返回 true ；否则，返回 false 。 叶子节点 是指没有子节点的节点。 示例 1： 11 输入：root = ..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://assets.leetcode.com/uploads/2021/01/18/pathsum1.jpg"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-09-29T10:51:54.000Z"}],["meta",{"property":"article:tag","content":"leetcode"}],["meta",{"property":"article:tag","content":"Leetcode-75"}],["meta",{"property":"article:tag","content":"binary-tree"}],["meta",{"property":"article:published_time","content":"2025-09-24T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2025-09-29T10:51:54.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"LC112. 路径总和 path-sum\\",\\"image\\":[\\"https://assets.leetcode.com/uploads/2021/01/18/pathsum1.jpg\\",\\"https://assets.leetcode.com/uploads/2021/01/18/pathsum2.jpg\\"],\\"datePublished\\":\\"2025-09-24T00:00:00.000Z\\",\\"dateModified\\":\\"2025-09-29T10:51:54.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"老马啸西风\\",\\"url\\":\\"https://houbb.github.io\\"}]}"]]},"git":{"createdTime":1759143114000,"updatedTime":1759143114000,"contributors":[{"name":"binbin.hou","username":"","email":"binbin.hou@huifu.com","commits":1}]},"readingTime":{"minutes":2.05,"words":616},"filePathRelative":"posts/leetcode/leetcode-75/2025-09-28-binary-tree-04-LC112-path-sum.md","localizedDate":"2025年9月24日","excerpt":"\\n<p>给你二叉树的根节点 root 和一个表示目标和的整数 targetSum 。</p>\\n<p>判断该树中是否存在 根节点到叶子节点 的路径，这条路径上所有节点值相加等于目标和 targetSum 。</p>\\n<p>如果存在，返回 true ；否则，返回 false 。</p>\\n<p>叶子节点 是指没有子节点的节点。</p>\\n<p>示例 1：</p>\\n<figure><img src=\\"https://assets.leetcode.com/uploads/2021/01/18/pathsum1.jpg\\" alt=\\"1\\" tabindex=\\"0\\" loading=\\"lazy\\"><figcaption>1</figcaption></figure>","autoDesc":true}');export{k as comp,d as data};
