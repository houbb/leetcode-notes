import{_ as s}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as a,a as t,o as e}from"./app-D4n7alqe.js";const n={};function l(h,i){return e(),a("div",null,i[0]||(i[0]=[t(`<h1 id="数组" tabindex="-1"><a class="header-anchor" href="#数组"><span>数组</span></a></h1><p>大家好，我是老马。</p><p>今天我们一起来学习一下数组这种数据结构。</p><h2 id="主要知识" tabindex="-1"><a class="header-anchor" href="#主要知识"><span>主要知识</span></a></h2><p>数组需要拆分下面几个部分：</p><ol><li><p>理论介绍</p></li><li><p>源码分析</p></li><li><p>数据结构实现？</p></li><li><p>题目练习（按照算法思想分类）</p></li><li><p>梳理对应的 sdk 包</p></li><li><p>应用实战</p></li></ol><p>因为这个是 leetcode 系列，所以重点是 4、5(对4再一次总结)。</p><p>为了照顾没有基础的小伙伴，会简单介绍一下1的基础理论。</p><p>简单介绍1，重点为4。其他不是本系列的重点。</p><h1 id="基础篇" tabindex="-1"><a class="header-anchor" href="#基础篇"><span>基础篇</span></a></h1><p>数组-矩阵</p><p>字符串-字符串匹配</p><p>排序：计数+桶+基数</p><p>模拟</p><p>枚举</p><h1 id="chat" tabindex="-1"><a class="header-anchor" href="#chat"><span>chat</span></a></h1><h2 id="详细介绍一下力扣基础之字符串匹配" tabindex="-1"><a class="header-anchor" href="#详细介绍一下力扣基础之字符串匹配"><span>详细介绍一下力扣基础之字符串匹配</span></a></h2><p>好的！我们来系统讲解 LeetCode（力扣）中的一个重要基础技巧：<strong>字符串匹配（String Matching）</strong>。这个技巧在很多面试题、底层算法（比如搜索、编译器、数据库查询）中都非常关键。</p><hr><h2 id="🧩-一、什么是字符串匹配" tabindex="-1"><a class="header-anchor" href="#🧩-一、什么是字符串匹配"><span>🧩 一、什么是字符串匹配？</span></a></h2><p>字符串匹配问题是指：</p><blockquote><p>在一个字符串（称为“文本串”<code>text</code>）中，<strong>查找是否存在某个“模式串”<code>pattern</code></strong>，如果存在，返回其位置或是否存在。</p></blockquote><p>举例：</p><ul><li><code>text = &quot;abcdefg&quot;</code>，<code>pattern = &quot;cde&quot;</code>，返回 <code>2</code></li><li><code>text = &quot;abcabc&quot;</code>，<code>pattern = &quot;cab&quot;</code>，返回 <code>false</code></li></ul><hr><h2 id="🧠-二、常见字符串匹配相关问题-力扣题型" tabindex="-1"><a class="header-anchor" href="#🧠-二、常见字符串匹配相关问题-力扣题型"><span>🧠 二、常见字符串匹配相关问题（力扣题型）</span></a></h2><h3 id="_1-✅-匹配一个子串" tabindex="-1"><a class="header-anchor" href="#_1-✅-匹配一个子串"><span>1. ✅ <strong>匹配一个子串</strong></span></a></h3><blockquote><p>判断 <code>pattern</code> 是否是 <code>text</code> 的子串，并返回起始下标。</p></blockquote><p>📌 典型题：</p><ul><li><a href="https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/" target="_blank" rel="noopener noreferrer">28. 找出字符串中第一个匹配项的下标</a></li><li><a href="https://leetcode.cn/problems/repeated-string-match/" target="_blank" rel="noopener noreferrer">686. 重复叠加字符串匹配</a></li></ul><hr><h3 id="_2-✅-通配符-正则匹配" tabindex="-1"><a class="header-anchor" href="#_2-✅-通配符-正则匹配"><span>2. ✅ <strong>通配符 / 正则匹配</strong></span></a></h3><blockquote><p><code>?</code> 表示任意单字符，<code>*</code> 表示任意多个字符</p></blockquote><p>📌 典型题：</p><ul><li><a href="https://leetcode.cn/problems/wildcard-matching/" target="_blank" rel="noopener noreferrer">44. 通配符匹配</a></li><li><a href="https://leetcode.cn/problems/regular-expression-matching/" target="_blank" rel="noopener noreferrer">10. 正则表达式匹配（含 <code>.</code> 和 <code>*</code>）</a></li></ul><hr><h3 id="_3-✅-多个字符串匹配" tabindex="-1"><a class="header-anchor" href="#_3-✅-多个字符串匹配"><span>3. ✅ <strong>多个字符串匹配</strong></span></a></h3><blockquote><p>查找一组字符串中哪些是 <code>text</code> 的子串</p></blockquote><p>📌 典型题：</p><ul><li><a href="https://leetcode.cn/problems/word-break-ii/" target="_blank" rel="noopener noreferrer">140. 单词拆分 II</a></li><li><a href="https://leetcode.cn/problems/concatenated-words/" target="_blank" rel="noopener noreferrer">472. 连接词</a></li></ul><hr><h2 id="🛠-三、常见字符串匹配算法" tabindex="-1"><a class="header-anchor" href="#🛠-三、常见字符串匹配算法"><span>🛠 三、常见字符串匹配算法</span></a></h2><h3 id="✅-1-暴力匹配法-brute-force" tabindex="-1"><a class="header-anchor" href="#✅-1-暴力匹配法-brute-force"><span>✅ 1. 暴力匹配法（Brute Force）</span></a></h3><p>思路：枚举每一个起点 <code>i</code>，从 <code>i</code> 开始判断是否与 <code>pattern</code> 完全匹配。</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> int</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> strStr</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">String</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> haystack</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> String</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> needle) {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    int</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> m </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> haystack</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">length</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(),</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> n </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> needle</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">length</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    for</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> (</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> i </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 0</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> i </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">&lt;=</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> m </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">-</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> n</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> i</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">++</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">) {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        if</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> (</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">haystack</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">substring</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(i, i </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">+</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> n).</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">equals</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(needle)</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">) {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">            return</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> i</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">        }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">    }</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    return</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> -</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>时间复杂度：<code>O(m * n)</code>，效率低，但思路简单。</li><li>适用于短文本匹配。</li></ul><hr><h3 id="✅-2-kmp-算法-knuth–morris–pratt" tabindex="-1"><a class="header-anchor" href="#✅-2-kmp-算法-knuth–morris–pratt"><span>✅ 2. KMP 算法（Knuth–Morris–Pratt）</span></a></h3><ul><li>用一个“部分匹配表”（<code>next</code> 数组）加速匹配过程，避免重复比较。</li><li>时间复杂度：<strong>O(m + n)</strong>，<code>m</code> 为主串长度，<code>n</code> 为模式串长度。</li></ul><p>📌 核心思想：</p><ul><li>匹配失败时，<strong>不回退主串指针</strong>，而是跳转模式串到前缀位置。</li></ul><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 生成 KMP 的 next 数组（部分匹配表）</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">[] </span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">buildNext</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">String</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> pattern) {</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#C678DD;">    int</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">[] next </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#C18401;--shiki-dark:#C678DD;"> int</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">[</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">pattern</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">length</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">()</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">]</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    int</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> j </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 0</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    for</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> (</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> i </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> i </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">&lt;</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> pattern</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">length</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> i</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">++</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">) {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        while</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> (j </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">&gt;</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 0</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> &amp;&amp;</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> pattern</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">charAt</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(i)</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> !=</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> pattern</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">charAt</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(j)</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">) {</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">            j </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> next[j </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">-</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 1</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">]</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">        }</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        if</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> (</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">pattern</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">charAt</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(i)</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> ==</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> pattern</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">charAt</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(j)</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">) j</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">++;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">        next[i] </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> j</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">    }</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    return</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> next</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>📌 推荐题：</p><ul><li><a href="https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/" target="_blank" rel="noopener noreferrer">28. 找出字符串中第一个匹配项的下标</a>（KMP 应用）</li><li><a href="https://leetcode.cn/problems/repeated-substring-pattern/" target="_blank" rel="noopener noreferrer">459. 重复的子字符串</a>（KMP 的 next 数组特性）</li></ul><hr><h3 id="✅-3-rabin-karp-算法-滚动哈希" tabindex="-1"><a class="header-anchor" href="#✅-3-rabin-karp-算法-滚动哈希"><span>✅ 3. Rabin-Karp 算法（滚动哈希）</span></a></h3><ul><li>使用 <strong>哈希值</strong> 判断子串是否匹配，避免每次都逐字符比较。</li><li>时间复杂度接近 O(n)，但可能会有哈希冲突。</li></ul><p>📌 原理：</p><ul><li>计算模式串的哈希值</li><li>滑动窗口移动，每次计算窗口哈希值并比较</li></ul><blockquote><p>LeetCode 上并不常直接考 Rabin-Karp，但用于优化“查找重复子串”等问题非常强。</p></blockquote><p>📌 例题：</p><ul><li><a href="https://leetcode.cn/problems/repeated-dna-sequences/" target="_blank" rel="noopener noreferrer">187. 重复的DNA序列</a></li><li><a href="https://leetcode.cn/problems/longest-duplicate-substring/" target="_blank" rel="noopener noreferrer">1044. 最长重复子串（hard）</a></li></ul><hr><h3 id="✅-4-字典树-aho-corasick-多模式匹配" tabindex="-1"><a class="header-anchor" href="#✅-4-字典树-aho-corasick-多模式匹配"><span>✅ 4. 字典树 + Aho-Corasick（多模式匹配）</span></a></h3><ul><li>用于多个单词同时匹配主串，构建 Trie 树 + 失配指针。</li><li>类似 KMP 多词版本。</li></ul><p>📌 例题：</p><ul><li><a href="https://leetcode.cn/problems/word-break/" target="_blank" rel="noopener noreferrer">139. 单词拆分</a></li><li><a href="https://leetcode.cn/problems/camelcase-matching/" target="_blank" rel="noopener noreferrer">1023. 驼峰式匹配</a></li><li><a href="https://leetcode.cn/problems/stream-of-characters/" target="_blank" rel="noopener noreferrer">1032. 字符流</a></li></ul><hr><h2 id="🔍-四、字符串匹配的应用技巧" tabindex="-1"><a class="header-anchor" href="#🔍-四、字符串匹配的应用技巧"><span>🔍 四、字符串匹配的应用技巧</span></a></h2><table><thead><tr><th>技巧</th><th>说明</th></tr></thead><tbody><tr><td>滑动窗口</td><td>处理子串固定长度的匹配，如 Rabin-Karp</td></tr><tr><td>前缀表</td><td>KMP 的关键，用于失配时快速跳转</td></tr><tr><td>哈希</td><td>快速比较字符串内容是否相同</td></tr><tr><td>Trie</td><td>处理多个单词一起匹配主串</td></tr><tr><td>动态规划</td><td>处理通配符 / 正则表达式匹配</td></tr></tbody></table><hr><h2 id="📌-五、面试高频题精选" tabindex="-1"><a class="header-anchor" href="#📌-五、面试高频题精选"><span>📌 五、面试高频题精选</span></a></h2><table><thead><tr><th>题号</th><th>题目</th><th>技巧</th></tr></thead><tbody><tr><td>28</td><td>找出字符串中第一个匹配项</td><td>暴力 / KMP</td></tr><tr><td>10</td><td>正则表达式匹配</td><td>DP</td></tr><tr><td>44</td><td>通配符匹配</td><td>DP</td></tr><tr><td>187</td><td>重复的 DNA 序列</td><td>滚动哈希</td></tr><tr><td>139</td><td>单词拆分</td><td>DP + HashSet</td></tr><tr><td>686</td><td>重复叠加字符串匹配</td><td>枚举 + KMP</td></tr></tbody></table><hr><h2 id="🚀-六、刷题顺序推荐" tabindex="-1"><a class="header-anchor" href="#🚀-六、刷题顺序推荐"><span>🚀 六、刷题顺序推荐</span></a></h2><h3 id="✅-入门" tabindex="-1"><a class="header-anchor" href="#✅-入门"><span>✅ 入门</span></a></h3><ul><li><a href="https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/" target="_blank" rel="noopener noreferrer">28. 找出字符串中第一个匹配项的下标</a></li><li><a href="https://leetcode.cn/problems/longest-common-prefix/" target="_blank" rel="noopener noreferrer">14. 最长公共前缀</a></li><li><a href="https://leetcode.cn/problems/valid-anagram/" target="_blank" rel="noopener noreferrer">242. 有效的字母异位词</a></li></ul><h3 id="✅-进阶匹配" tabindex="-1"><a class="header-anchor" href="#✅-进阶匹配"><span>✅ 进阶匹配</span></a></h3><ul><li><a href="https://leetcode.cn/problems/repeated-string-match/" target="_blank" rel="noopener noreferrer">686. 重复叠加字符串匹配</a></li><li><a href="https://leetcode.cn/problems/repeated-substring-pattern/" target="_blank" rel="noopener noreferrer">459. 重复的子字符串</a></li><li><a href="https://leetcode.cn/problems/repeated-dna-sequences/" target="_blank" rel="noopener noreferrer">187. 重复的 DNA 序列</a></li></ul><h3 id="✅-高阶技巧" tabindex="-1"><a class="header-anchor" href="#✅-高阶技巧"><span>✅ 高阶技巧</span></a></h3><ul><li><a href="https://leetcode.cn/problems/wildcard-matching/" target="_blank" rel="noopener noreferrer">44. 通配符匹配</a></li><li><a href="https://leetcode.cn/problems/regular-expression-matching/" target="_blank" rel="noopener noreferrer">10. 正则表达式匹配</a></li><li><a href="https://leetcode.cn/problems/stream-of-characters/" target="_blank" rel="noopener noreferrer">1032. 字符流</a></li></ul><hr><h2 id="✅-七、总结回顾" tabindex="-1"><a class="header-anchor" href="#✅-七、总结回顾"><span>✅ 七、总结回顾</span></a></h2><table><thead><tr><th>匹配方式</th><th>适用情况</th><th>是否推荐</th></tr></thead><tbody><tr><td>暴力法</td><td>简单题，短串</td><td>✅ 入门好理解</td></tr><tr><td>KMP</td><td>单模式高效匹配</td><td>✅ 高效实用</td></tr><tr><td>Rabin-Karp</td><td>查找重复子串等</td><td>⚠️ 注意哈希冲突</td></tr><tr><td>Trie / Aho-Corasick</td><td>多词匹配</td><td>✅ 复杂题利器</td></tr><tr><td>动态规划</td><td>通配符匹配问题</td><td>✅ 经典考点</td></tr></tbody></table><hr><p>如果你想，我可以帮你：</p><ul><li>手把手讲解 KMP（含动画/代码）</li><li>针对某一道匹配题写出详细分析 + 注释代码</li><li>制定匹配类题目的专项刷题计划</li></ul>`,87)]))}const d=s(n,[["render",l]]),k=JSON.parse('{"path":"/posts/leetcode/top-100-liked/string/2020-06-06-algorithm-000-leetcode-data-struct-001-topics-basic-string-match-01-intro.html","title":"leetcode 基础篇专题之字符串匹配 string-matching 01-入门介绍","lang":"zh-CN","frontmatter":{"title":"leetcode 基础篇专题之字符串匹配 string-matching 01-入门介绍","date":"2020-06-08T00:00:00.000Z","categories":["Algorithm"],"tags":["algorithm","data-struct","topics","leetcode","string-matching","sf"],"published":true,"description":"数组 大家好，我是老马。 今天我们一起来学习一下数组这种数据结构。 主要知识 数组需要拆分下面几个部分： 理论介绍 源码分析 数据结构实现？ 题目练习（按照算法思想分类） 梳理对应的 sdk 包 应用实战 因为这个是 leetcode 系列，所以重点是 4、5(对4再一次总结)。 为了照顾没有基础的小伙伴，会简单介绍一下1的基础理论。 简单介绍1，重点...","head":[["meta",{"property":"og:url","content":"https://houbb.github.io/leetcode-notes/posts/leetcode/top-100-liked/string/2020-06-06-algorithm-000-leetcode-data-struct-001-topics-basic-string-match-01-intro.html"}],["meta",{"property":"og:site_name","content":"老马啸西风"}],["meta",{"property":"og:title","content":"leetcode 基础篇专题之字符串匹配 string-matching 01-入门介绍"}],["meta",{"property":"og:description","content":"数组 大家好，我是老马。 今天我们一起来学习一下数组这种数据结构。 主要知识 数组需要拆分下面几个部分： 理论介绍 源码分析 数据结构实现？ 题目练习（按照算法思想分类） 梳理对应的 sdk 包 应用实战 因为这个是 leetcode 系列，所以重点是 4、5(对4再一次总结)。 为了照顾没有基础的小伙伴，会简单介绍一下1的基础理论。 简单介绍1，重点..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-08-30T18:54:20.000Z"}],["meta",{"property":"article:tag","content":"algorithm"}],["meta",{"property":"article:tag","content":"data-struct"}],["meta",{"property":"article:tag","content":"topics"}],["meta",{"property":"article:tag","content":"leetcode"}],["meta",{"property":"article:tag","content":"string-matching"}],["meta",{"property":"article:tag","content":"sf"}],["meta",{"property":"article:published_time","content":"2020-06-08T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2025-08-30T18:54:20.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"leetcode 基础篇专题之字符串匹配 string-matching 01-入门介绍\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2020-06-08T00:00:00.000Z\\",\\"dateModified\\":\\"2025-08-30T18:54:20.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"老马啸西风\\",\\"url\\":\\"https://houbb.github.io\\"}]}"]]},"git":{"createdTime":1755499309000,"updatedTime":1756580060000,"contributors":[{"name":"binbin.hou","username":"","email":"binbin.hou@huifu.com","commits":2},{"name":"bbhou","username":"bbhou","email":"1557740299@qq.com","commits":2,"url":"https://github.com/bbhou"}]},"readingTime":{"minutes":4.89,"words":1468},"filePathRelative":"posts/leetcode/top-100-liked/string/2020-06-06-algorithm-000-leetcode-data-struct-001-topics-basic-string-match-01-intro.md","localizedDate":"2020年6月8日","excerpt":"\\n<p>大家好，我是老马。</p>\\n<p>今天我们一起来学习一下数组这种数据结构。</p>\\n<h2>主要知识</h2>\\n<p>数组需要拆分下面几个部分：</p>\\n<ol>\\n<li>\\n<p>理论介绍</p>\\n</li>\\n<li>\\n<p>源码分析</p>\\n</li>\\n<li>\\n<p>数据结构实现？</p>\\n</li>\\n<li>\\n<p>题目练习（按照算法思想分类）</p>\\n</li>\\n<li>\\n<p>梳理对应的 sdk 包</p>\\n</li>\\n<li>\\n<p>应用实战</p>\\n</li>\\n</ol>\\n<p>因为这个是 leetcode 系列，所以重点是 4、5(对4再一次总结)。</p>\\n<p>为了照顾没有基础的小伙伴，会简单介绍一下1的基础理论。</p>","autoDesc":true}');export{d as comp,k as data};
