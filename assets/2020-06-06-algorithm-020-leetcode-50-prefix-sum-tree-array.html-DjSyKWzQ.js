import{_ as s}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as a,a as e,o as n}from"./app-DCulNCx2.js";const l={};function t(h,i){return n(),a("div",null,i[0]||(i[0]=[e(`<h1 id="开源地址" tabindex="-1"><a class="header-anchor" href="#开源地址"><span>开源地址</span></a></h1><p>为了便于大家学习，所有实现均已开源。欢迎 fork + star~</p><blockquote><p><a href="https://github.com/houbb/leetcode" target="_blank" rel="noopener noreferrer">https://github.com/houbb/leetcode</a></p></blockquote><h1 id="chat" tabindex="-1"><a class="header-anchor" href="#chat"><span>chat</span></a></h1><h2 id="详细介绍一下树状数组" tabindex="-1"><a class="header-anchor" href="#详细介绍一下树状数组"><span>详细介绍一下树状数组</span></a></h2><p>树状数组（Binary Indexed Tree，简称 BIT）是一种用于高效处理动态数据集的数值结构，特别适用于需要频繁进行前缀和查询和单点更新的场景。</p><p>树状数组通常用于求解序列的前缀和、区间和、频率统计等问题，尤其是在算法竞赛和计算几何中经常用到。</p><h3 id="_1-树状数组的基本原理" tabindex="-1"><a class="header-anchor" href="#_1-树状数组的基本原理"><span>1. 树状数组的基本原理</span></a></h3><p>树状数组通过利用二进制的性质，能够以对数时间复杂度（O(log n)）完成更新和查询操作。</p><p>具体来说，它将一个序列压缩成一个树形结构，以支持高效的前缀和查询与单点更新。</p><h4 id="结构" tabindex="-1"><a class="header-anchor" href="#结构"><span>结构</span></a></h4><p>树状数组的核心思想是：用一个辅助数组来记录当前元素和其之前元素的某些统计信息（通常是某个范围的和）。</p><ul><li>假设我们有一个长度为 <code>n</code> 的数组 <code>arr</code>，目标是计算该数组的前缀和。</li><li>为了能高效地计算前缀和，我们建立一个与 <code>arr</code> 同样大小的树状数组 <code>bit</code>，通过特定的规则进行更新。</li></ul><p>树状数组的结构实际上并不是一个树形数据结构，而是通过数组的下标和二进制操作来模拟树的结构。</p><h4 id="数组更新和查询的核心思想" tabindex="-1"><a class="header-anchor" href="#数组更新和查询的核心思想"><span>数组更新和查询的核心思想</span></a></h4><ul><li><p><strong>查询</strong>：对于任意位置 <code>i</code>，我们可以通过不断查找当前下标与其父节点之间的关系（即 <code>i -= lowbit(i)</code>）来快速查询从数组开始到 <code>i</code> 的前缀和。</p><p>其中，<code>lowbit(i)</code> 代表 <code>i</code> 的最低位的 <code>1</code> 所表示的值，具体实现为：</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">lowbit</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(i) </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> i </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">&amp;</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> (</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">-</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">i)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div></li><li><p><strong>更新</strong>：对于任意位置 <code>i</code> 的更新，我们将变动的值更新到树状数组的相应节点上，并且由于树状数组的特性，这个更新需要沿着树形结构向上递归更新。</p></li></ul><h3 id="_2-树状数组的实现" tabindex="-1"><a class="header-anchor" href="#_2-树状数组的实现"><span>2. 树状数组的实现</span></a></h3><p>假设我们有一个数组 <code>arr</code>，长度为 <code>n</code>，树状数组 <code>bit</code> 的长度同样为 <code>n</code>，<code>bit</code> 数组的下标从 1 开始（为了简化实现，不从 0 开始）。</p><p>树状数组的核心操作包括：</p><ul><li><strong>更新操作</strong>：将 <code>arr[i]</code> 更新为一个新值 <code>x</code>，我们需要调整 <code>bit</code> 数组，使其反映该变化。</li><li><strong>查询操作</strong>：查询从 <code>arr[1]</code> 到 <code>arr[i]</code> 的前缀和。</li></ul><p>以下是一个简单的树状数组的实现（使用 Java 编写）：</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> class</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> FenwickTree</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    private</span><span style="--shiki-light:#C18401;--shiki-dark:#C678DD;"> int</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">[] bit</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">  // 树状数组</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    private</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> int</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> n</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    public</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> FenwickTree</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> n</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">        this</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">n</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> n;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">        bit </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#C18401;--shiki-dark:#C678DD;"> int</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">[n </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">+</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">];  </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 树状数组索引从1开始，大小为n+1</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    // 更新操作：在位置i增加值x</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> update</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> i</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> x</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        while</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (i </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">&lt;=</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> n) {</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">            bit[i] </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">+=</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> x;  </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 更新当前节点的值</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">            i </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">+=</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> lowbit</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(i);  </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 移动到父节点</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">        }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    // 查询操作：查询前缀和[1, i]</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> int</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> query</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> i</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        int</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> sum</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 0</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        while</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (i </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">&gt;</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 0</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) {</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">            sum </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">+=</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> bit[i];  </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 累加当前节点的值</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">            i </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">-=</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> lowbit</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(i);  </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 移动到父节点</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">        }</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        return</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> sum;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    // 计算lowbit(i)</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    private</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> int</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> lowbit</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> i</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        return</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> i </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">&amp;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">-</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">i);  </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 低位的1所表示的值</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> static</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> main</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">String</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">[] </span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;">args</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">        FenwickTree</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> fenwickTree</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> FenwickTree</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">10</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">        fenwickTree</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">update</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">3</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);  </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// arr[1] += 3</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">        fenwickTree</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">update</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">2</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">5</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);  </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// arr[2] += 5</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">        System</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">out</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">println</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">fenwickTree</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">query</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">2</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">));  </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 输出前缀和[1, 2]，即3 + 5 = 8</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">        fenwickTree</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">update</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">2</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);  </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// arr[1] += 2</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">        System</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">out</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">println</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">fenwickTree</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">query</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">2</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">));  </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 输出前缀和[1, 2]，即5 + 5 = 10</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_3-树状数组的时间复杂度" tabindex="-1"><a class="header-anchor" href="#_3-树状数组的时间复杂度"><span>3. 树状数组的时间复杂度</span></a></h3><ul><li><p><strong>更新操作</strong>：每次更新会沿着树状数组向上更新，最多需要更新 <code>O(log n)</code> 个节点。因此，更新操作的时间复杂度是 <code>O(log n)</code>。</p></li><li><p><strong>查询操作</strong>：查询前缀和时，最多需要访问 <code>O(log n)</code> 个节点。因此，查询操作的时间复杂度也是 <code>O(log n)</code>。</p></li></ul><h3 id="_4-应用场景" tabindex="-1"><a class="header-anchor" href="#_4-应用场景"><span>4. 应用场景</span></a></h3><p>树状数组广泛应用于以下几种场景：</p><ul><li><strong>前缀和查询</strong>：比如求一个数组的前缀和或者区间和。</li><li><strong>频率统计</strong>：在动态数据结构中，快速查询某个值出现的次数或者范围内出现的次数。</li><li><strong>动态数据更新</strong>：可以用来处理动态变化的数据序列，特别是有增量更新需求的场景。</li></ul><h3 id="_5-树状数组的扩展" tabindex="-1"><a class="header-anchor" href="#_5-树状数组的扩展"><span>5. 树状数组的扩展</span></a></h3><ul><li><strong>区间和</strong>：通过前缀和公式，可以用树状数组快速计算区间和：<div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">sum[l</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> r] </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> query</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(r) </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">-</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> query</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(l</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">-</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">1</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div></li><li><strong>扩展到二维</strong>：树状数组可以扩展到二维，支持二维区域的前缀和查询和更新。</li></ul><h3 id="_6-与其他数据结构的比较" tabindex="-1"><a class="header-anchor" href="#_6-与其他数据结构的比较"><span>6. 与其他数据结构的比较</span></a></h3><ul><li><p><strong>线段树</strong>：线段树也是一种支持区间查询和单点更新的数据结构。与树状数组相比，线段树的查询和更新操作的时间复杂度也是 <code>O(log n)</code>，但线段树的实现更复杂，且可以处理更多类型的查询（例如区间最大值、区间最小值等）。</p></li><li><p><strong>平衡树（如 AVL 树、红黑树）</strong>：平衡树支持动态维护集合中的元素，并支持 <code>O(log n)</code> 时间复杂度的插入、删除、查找等操作。相比之下，树状数组的更新和查询更为高效，但只能处理数值范围内的前缀和问题。</p></li></ul><h3 id="总结" tabindex="-1"><a class="header-anchor" href="#总结"><span>总结</span></a></h3><p>树状数组是一个高效的数据结构，特别适用于频繁进行前缀和查询和单点更新的问题。</p><p>它通过巧妙地利用二进制位的低位来模拟树形结构，从而在 <code>O(log n)</code> 时间内完成更新和查询操作。</p><p>尽管树状数组不能处理更复杂的区间查询问题，但在特定场景下，它提供了一种既简洁又高效的解决方案。</p><h2 id="实在无法理解这个位运算-结合具体的例子-一步步推导一下" tabindex="-1"><a class="header-anchor" href="#实在无法理解这个位运算-结合具体的例子-一步步推导一下"><span>实在无法理解这个位运算，结合具体的例子，一步步推导一下</span></a></h2><p>理解树状数组中的位运算，特别是 <code>lowbit(i)</code> 的计算和应用，确实需要结合具体的例子一步步推导。</p><p>下面我们通过一个具体的例子，逐步解析树状数组的 <code>lowbit(i)</code> 以及它是如何帮助我们完成查询和更新操作的。</p><h3 id="_1-lowbit-i-的含义" tabindex="-1"><a class="header-anchor" href="#_1-lowbit-i-的含义"><span>1. <code>lowbit(i)</code> 的含义</span></a></h3><p>首先，我们来理解 <code>lowbit(i)</code>。 <code>lowbit(i)</code> 是一个二进制操作，表示数字 <code>i</code> 最低位的 <code>1</code> 所表示的值。具体来说，它的公式是：</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">lowbit</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(i) </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> i </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">&amp;</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> (</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">-</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">i)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>这里，<code>&amp;</code> 是按位与运算，<code>-i</code> 是 <code>i</code> 的二进制补码（负数）。通过 <code>lowbit(i)</code> 我们可以获取 <code>i</code> 在二进制表示中最低位的 <code>1</code> 所对应的数字。</p><h4 id="举个例子来说明" tabindex="-1"><a class="header-anchor" href="#举个例子来说明"><span>举个例子来说明：</span></a></h4><p>假设 <code>i = 6</code>，我们来一步步推导：</p><ul><li><code>i = 6</code> 的二进制表示是：<code>0110</code>。</li><li>取 <code>-i</code>，即 <code>-6</code>，我们首先需要求 <code>6</code> 的二进制补码： <ul><li><code>6</code> 的二进制补码是：<code>1111 1010</code>（假设为 8 位补码）。</li><li>对 <code>6</code> 取反得到：<code>1000 0101</code>，然后加 1 得到 <code>-6</code> 的二进制补码：<code>1000 0110</code>。</li></ul></li></ul><p>现在进行 <code>&amp;</code> 运算：</p><ul><li><code>i = 6</code> 的二进制是：<code>0110</code>。</li><li><code>-i = -6</code> 的二进制是：<code>1000 0110</code>。</li><li>按位与运算结果：<code>0110 &amp; 1000 0110</code> 得到 <code>0000 0010</code>，即 2。</li></ul><p>所以，<code>lowbit(6) = 2</code>。</p><h4 id="解释" tabindex="-1"><a class="header-anchor" href="#解释"><span>解释：</span></a></h4><p><code>lowbit(6)</code> 得到 2，意味着数字 <code>6</code> 中最低位的 <code>1</code> 所对应的数字就是 <code>2</code>。这对于树状数组的操作非常有用。</p><h3 id="_2-lowbit-i-在树状数组中的应用" tabindex="-1"><a class="header-anchor" href="#_2-lowbit-i-在树状数组中的应用"><span>2. <code>lowbit(i)</code> 在树状数组中的应用</span></a></h3><h4 id="a-用于查询" tabindex="-1"><a class="header-anchor" href="#a-用于查询"><span>a. 用于查询</span></a></h4><p>在树状数组中，查询前缀和时，我们要通过不断地跳到当前节点的父节点来实现。</p><p>假设我们要查询前缀和 <code>arr[1] + arr[2] + ... + arr[i]</code>，具体步骤如下：</p><ol><li>计算当前节点 <code>i</code> 的前缀和。</li><li>使用 <code>lowbit(i)</code> 跳到父节点，继续查询直到 <code>i</code> 为 0。</li></ol><p>举个具体的例子，假设树状数组的大小是 6，初始数组是 <code>[0, 3, 2, 1, 5, 4]</code>，我们要查询前缀和 <code>arr[1] + arr[2] + ... + arr[4]</code>。</p><ol><li><strong>查询 <code>query(4)</code></strong>： <ul><li>计算 <code>lowbit(4)</code>： <ul><li><code>4</code> 的二进制表示是 <code>100</code>，<code>lowbit(4) = 4 &amp; (-4) = 100 &amp; 100 = 100</code>，即 4。</li></ul></li><li>累加当前 <code>bit[4]</code>（假设当前树状数组存的是前缀和，<code>bit[4] = 5</code>）。</li><li>然后通过 <code>i -= lowbit(i)</code> 更新 <code>i = 4 - 4 = 0</code>，查询结束。</li></ul></li></ol><p>最终，<code>query(4)</code> 的结果是 <code>bit[4] = 5</code>。</p><h4 id="b-用于更新" tabindex="-1"><a class="header-anchor" href="#b-用于更新"><span>b. 用于更新</span></a></h4><p>树状数组中的更新操作也是通过 <code>lowbit(i)</code> 来实现的。我们在更新某个元素时，需要将其影响传递到树状数组中相关的节点。</p><p>举个具体的例子，假设我们要更新 <code>arr[3]</code>，将它的值增加 <code>3</code>（即 <code>arr[3] += 3</code>）。</p><ul><li><code>i = 3</code>，计算 <code>lowbit(3)</code>： <ul><li><code>3</code> 的二进制表示是 <code>011</code>，<code>lowbit(3) = 3 &amp; (-3) = 011 &amp; 101 = 001</code>，即 1。</li></ul></li><li>更新 <code>bit[3]</code>，加上 <code>3</code>（<code>bit[3] += 3</code>），然后根据 <code>lowbit(3)</code> 更新父节点： <ul><li><code>i = 3 + lowbit(3) = 3 + 1 = 4</code>，继续更新 <code>bit[4]</code>。</li></ul></li><li>再继续更新 <code>bit[4]</code>，然后根据 <code>lowbit(4)</code> 更新到父节点，直到更新完所有相关节点。</li></ul><p>这个过程会反映在树状数组中，确保我们可以根据更新后的数据正确计算前缀和。</p><h3 id="_3-总结" tabindex="-1"><a class="header-anchor" href="#_3-总结"><span>3. 总结</span></a></h3><ul><li><code>lowbit(i)</code> 通过二进制操作找到数字 <code>i</code> 最低位的 <code>1</code> 对应的值，帮助树状数组在查询和更新时高效地向上或向下跳跃。</li><li>通过不断利用 <code>lowbit(i)</code> 更新树状数组，可以在 <code>O(log n)</code> 的时间内高效地完成查询和更新操作。</li><li>在查询时，通过计算 <code>lowbit(i)</code> 反复减小 <code>i</code>，直到到达根节点（即 <code>i = 0</code>）；在更新时，通过计算 <code>lowbit(i)</code> 不断向上更新树状数组，确保树状数组中的值始终反映数组的最新状态。</li></ul><p>通过这个过程，树状数组能高效地支持区间和查询与单点更新，使得它在处理动态数据时非常有用。</p><h2 id="如何记忆呢" tabindex="-1"><a class="header-anchor" href="#如何记忆呢"><span>如何记忆呢？</span></a></h2><p>理解树状数组中的位运算和其复杂流程确实可以让人感到困惑，但其实记忆和掌握这个概念并不一定需要靠死记硬背。更多的是通过对其基本原理和机制的理解，结合不断的练习和思考。这里有一些建议，帮助你更轻松地掌握和记忆树状数组：</p><h3 id="_1-理解二进制的低位性质" tabindex="-1"><a class="header-anchor" href="#_1-理解二进制的低位性质"><span>1. <strong>理解二进制的低位性质</strong></span></a></h3><p>树状数组中的 <code>lowbit(i)</code> 操作本质上是通过二进制操作找到数字中最低位的 <code>1</code> 所对应的值。我们可以通过理解二进制的基本规律来帮助自己理解为什么 <code>lowbit(i)</code> 能有效地帮助查询和更新：</p><ul><li><strong>二进制的特点</strong>：任何数字在二进制表示中，其最低位的 <code>1</code> 表示该数字能被该位置的权重（<code>2^k</code>）所表示。通过 <code>lowbit(i)</code>，你实际上是在查找一个权重范围，即在树状数组中指向的最小范围。</li></ul><p>例如：</p><ul><li><code>lowbit(4) = 4</code>，说明 <code>4</code> 这个数字在二进制中有一个 <code>1</code> 在其第 2 位（<code>2^2</code>），因此影响的范围就是 <code>2^2 = 4</code>。</li><li><code>lowbit(6) = 2</code>，说明 <code>6</code> 这个数字最低位的 <code>1</code> 在第 1 位（<code>2^1</code>），因此影响的范围是 <code>2^1 = 2</code>。</li></ul><h3 id="_2-逐步理解流程-减少一次性负担" tabindex="-1"><a class="header-anchor" href="#_2-逐步理解流程-减少一次性负担"><span>2. <strong>逐步理解流程，减少一次性负担</strong></span></a></h3><p>树状数组的实现本身的流程看起来可能有点复杂，但可以把它拆分成简单的小步骤。你不需要一次性记住所有细节，关键是理解每个步骤背后的原因。</p><h4 id="例如-更新过程" tabindex="-1"><a class="header-anchor" href="#例如-更新过程"><span>例如，更新过程：</span></a></h4><ol><li>更新一个元素时，<strong>首先需要找到该元素影响的范围</strong>。通过 <code>lowbit(i)</code>，我们可以确定该元素影响的 &quot;父节点&quot;。</li><li><strong>逐步向上更新树状数组</strong>，每次更新一个节点，然后再利用 <code>lowbit(i)</code> 找到下一个需要更新的节点。</li></ol><p>你可以通过画图来帮助记忆：画出一个树状数组的结构，标记每个节点的 <code>lowbit(i)</code>，并在图上逐步演示更新过程。通过直观的图形帮助理解这些步骤。</p><h4 id="查询过程" tabindex="-1"><a class="header-anchor" href="#查询过程"><span>查询过程：</span></a></h4><p>查询前缀和也是一个类似的过程：</p><ol><li><strong>从当前节点出发</strong>，通过 <code>lowbit(i)</code> 确定需要访问的父节点。</li><li><strong>一直向上走</strong>，直到访问到根节点（即 <code>i = 0</code>），累加过程中包含了从根到当前节点的所有前缀和。</li></ol><h3 id="_3-通过具体例子反复练习" tabindex="-1"><a class="header-anchor" href="#_3-通过具体例子反复练习"><span>3. <strong>通过具体例子反复练习</strong></span></a></h3><p>实际的编程练习是加深理解最有效的方式。通过具体的例子来实现树状数组，可以帮助你理解每一个操作。你可以用一个简单的例子来实现树状数组，逐步调试每个操作。</p><p>例如，尝试编写一个小程序来实现树状数组的更新和查询，使用小数据量并观察每个步骤的变化。通过实际操作，你会逐渐发现每个操作的规律，从而理解如何利用 <code>lowbit(i)</code> 来实现这些功能。</p><h3 id="_4-关联已知知识" tabindex="-1"><a class="header-anchor" href="#_4-关联已知知识"><span>4. <strong>关联已知知识</strong></span></a></h3><p>如果你之前有其他数据结构的经验（例如栈、队列、链表、二分查找等），你可以将树状数组与这些已知的知识联系起来：</p><ul><li>树状数组类似于“压缩”的树结构，但它并没有显式地构建树，而是利用数组下标和二进制来模拟树的层级关系。</li><li>在树状数组的操作中，<code>lowbit(i)</code> 就相当于在模拟树的父子关系，每次跳跃到上层节点时都减少了一个量级。</li></ul><h3 id="_5-总结和规律提取" tabindex="-1"><a class="header-anchor" href="#_5-总结和规律提取"><span>5. <strong>总结和规律提取</strong></span></a></h3><p>树状数组的核心思想就是<strong>二进制分治</strong>。通过 <code>lowbit(i)</code> 实现快速的查询和更新。每次更新和查询时，利用 <code>lowbit(i)</code> 可以缩小范围，逐步解决问题。这个过程本质上就是一个“按位”操作的过程，它依赖于二进制表示的每一位的权重关系。</p><h3 id="_6-持续练习和复习" tabindex="-1"><a class="header-anchor" href="#_6-持续练习和复习"><span>6. <strong>持续练习和复习</strong></span></a></h3><p>为了加深记忆和理解，持续练习是必要的。你可以通过以下几种方式来加深对树状数组的掌握：</p><ul><li><strong>手写代码</strong>：自己手动实现树状数组，并进行调试。</li><li><strong>解决问题</strong>：利用树状数组解决实际的算法题，例如区间和、频率统计等问题。</li><li><strong>复习总结</strong>：定期回顾 <code>lowbit(i)</code> 的定义和树状数组的流程，重新理解每个步骤的原理。</li></ul><h3 id="_7-思维导图或图示化" tabindex="-1"><a class="header-anchor" href="#_7-思维导图或图示化"><span>7. <strong>思维导图或图示化</strong></span></a></h3><p>有些人通过图示来帮助理解和记忆。你可以画出树状数组的树形结构，每次更新或查询时标出每个节点的 <code>lowbit(i)</code>，看清楚树状数组是如何通过二进制的低位结构进行查询和更新的。</p><h3 id="总结-1" tabindex="-1"><a class="header-anchor" href="#总结-1"><span>总结</span></a></h3><ul><li>不需要硬背树状数组的流程，理解 <strong>二进制的低位特性</strong> 和 <strong>树状数组的查询与更新思想</strong> 才是关键。</li><li>通过 <strong>具体的例子</strong> 和 <strong>图示化的步骤</strong>，逐步掌握每个操作的含义。</li><li>多做练习，逐步形成对树状数组操作的直观理解和记忆。</li></ul><p>只要通过这种分步式的理解和练习，你会发现树状数组的复杂性会逐渐变得更加清晰，最终能够灵活地应用在算法中。</p><h1 id="参考资料" tabindex="-1"><a class="header-anchor" href="#参考资料"><span>参考资料</span></a></h1><p><a href="https://leetcode.cn/problems/range-sum-query-mutable/" target="_blank" rel="noopener noreferrer">https://leetcode.cn/problems/range-sum-query-mutable/</a></p>`,99)]))}const k=s(l,[["render",t]]),r=JSON.parse('{"path":"/posts/leetcode/history1/2020-06-06-algorithm-020-leetcode-50-prefix-sum-tree-array.html","title":"50-树状数组 Binary Indexed Tree，简称 BIT FenwickTree","lang":"zh-CN","frontmatter":{"title":"50-树状数组 Binary Indexed Tree，简称 BIT FenwickTree","date":"2020-06-08T00:00:00.000Z","categories":["Algorithm"],"tags":["algorithm","prefix-sum","leetcode"],"published":true,"description":"开源地址 为了便于大家学习，所有实现均已开源。欢迎 fork + star~ https://github.com/houbb/leetcode chat 详细介绍一下树状数组 树状数组（Binary Indexed Tree，简称 BIT）是一种用于高效处理动态数据集的数值结构，特别适用于需要频繁进行前缀和查询和单点更新的场景。 树状数组通常用于求解...","head":[["meta",{"property":"og:url","content":"https://houbb.github.io/leetcode-notes/posts/leetcode/history1/2020-06-06-algorithm-020-leetcode-50-prefix-sum-tree-array.html"}],["meta",{"property":"og:site_name","content":"老马啸西风"}],["meta",{"property":"og:title","content":"50-树状数组 Binary Indexed Tree，简称 BIT FenwickTree"}],["meta",{"property":"og:description","content":"开源地址 为了便于大家学习，所有实现均已开源。欢迎 fork + star~ https://github.com/houbb/leetcode chat 详细介绍一下树状数组 树状数组（Binary Indexed Tree，简称 BIT）是一种用于高效处理动态数据集的数值结构，特别适用于需要频繁进行前缀和查询和单点更新的场景。 树状数组通常用于求解..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-08-22T12:19:07.000Z"}],["meta",{"property":"article:tag","content":"algorithm"}],["meta",{"property":"article:tag","content":"prefix-sum"}],["meta",{"property":"article:tag","content":"leetcode"}],["meta",{"property":"article:published_time","content":"2020-06-08T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2025-08-22T12:19:07.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"50-树状数组 Binary Indexed Tree，简称 BIT FenwickTree\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2020-06-08T00:00:00.000Z\\",\\"dateModified\\":\\"2025-08-22T12:19:07.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"老马啸西风\\",\\"url\\":\\"https://houbb.github.io\\"}]}"]]},"git":{"createdTime":1755499309000,"updatedTime":1755865147000,"contributors":[{"name":"binbin.hou","username":"","email":"binbin.hou@huifu.com","commits":2},{"name":"bbhou","username":"bbhou","email":"1557740299@qq.com","commits":2,"url":"https://github.com/bbhou"}]},"readingTime":{"minutes":12.93,"words":3878},"filePathRelative":"posts/leetcode/history1/2020-06-06-algorithm-020-leetcode-50-prefix-sum-tree-array.md","localizedDate":"2020年6月8日","excerpt":"\\n<p>为了便于大家学习，所有实现均已开源。欢迎 fork + star~</p>\\n<blockquote>\\n<p><a href=\\"https://github.com/houbb/leetcode\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">https://github.com/houbb/leetcode</a></p>\\n</blockquote>\\n<h1>chat</h1>\\n<h2>详细介绍一下树状数组</h2>\\n<p>树状数组（Binary Indexed Tree，简称 BIT）是一种用于高效处理动态数据集的数值结构，特别适用于需要频繁进行前缀和查询和单点更新的场景。</p>","autoDesc":true}');export{k as comp,r as data};
