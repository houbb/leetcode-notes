import{_ as s}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as a,a as l,o as n}from"./app-Ji2WyQRN.js";const t={};function e(h,i){return n(),a("div",null,i[0]||(i[0]=[l(`<h2 id="_1️⃣-堆的概念" tabindex="-1"><a class="header-anchor" href="#_1️⃣-堆的概念"><span>1️⃣ 堆的概念</span></a></h2><p>堆是一种 <strong>完全二叉树（Complete Binary Tree）</strong> 的数据结构，同时满足 <strong>堆性质（Heap Property）</strong>：</p><ul><li><strong>最大堆（Max-Heap）</strong>：每个节点的值都 <strong>大于等于其子节点的值</strong>。</li><li><strong>最小堆（Min-Heap）</strong>：每个节点的值都 <strong>小于等于其子节点的值</strong>。</li></ul><p>特点：</p><ol><li>完全二叉树：树除了最后一层外，其他层都满；最后一层从左到右依次填充。</li><li>根节点是堆中最大（最大堆）或最小（最小堆）的值。</li><li>堆一般用 <strong>数组</strong> 来实现，而不是指针型节点。</li></ol><hr><h2 id="_2️⃣-堆的表示-数组实现" tabindex="-1"><a class="header-anchor" href="#_2️⃣-堆的表示-数组实现"><span>2️⃣ 堆的表示（数组实现）</span></a></h2><p>因为堆是完全二叉树，所以可以用数组表示，节点索引从 0 开始：</p><ul><li><p>对于索引为 <code>i</code> 的节点：</p><ul><li>左子节点索引：<code>2*i + 1</code></li><li>右子节点索引：<code>2*i + 2</code></li><li>父节点索引：<code>(i - 1) / 2</code>（向下取整）</li></ul></li></ul><p><strong>例子：最大堆</strong></p><p>数组：<code>[90, 15, 10, 7, 12, 2]</code><br> 对应完全二叉树：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>        90</span></span>
<span class="line"><span>       /  \\</span></span>
<span class="line"><span>     15    10</span></span>
<span class="line"><span>    / \\   /</span></span>
<span class="line"><span>   7  12 2</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可以看到，根节点 90 最大，每个父节点都大于等于子节点。</p><hr><h2 id="_3️⃣-堆的核心操作" tabindex="-1"><a class="header-anchor" href="#_3️⃣-堆的核心操作"><span>3️⃣ 堆的核心操作</span></a></h2><h3 id="_1-插入元素-insert" tabindex="-1"><a class="header-anchor" href="#_1-插入元素-insert"><span>（1）插入元素 <code>insert</code></span></a></h3><ul><li><p>步骤：</p><ol><li><p>将新元素放在数组末尾（保持完全二叉树性质）。</p></li><li><p>“上浮”（bubble-up / sift-up）：</p><ul><li>如果新元素比父节点大（最大堆），就交换。</li><li>直到堆性质满足或到达根节点。</li></ul></li></ol></li><li><p>时间复杂度：<code>O(log n)</code>（树高为 log n）</p></li></ul><hr><h3 id="_2-删除堆顶-extract-pop" tabindex="-1"><a class="header-anchor" href="#_2-删除堆顶-extract-pop"><span>（2）删除堆顶 <code>extract</code> / <code>pop</code></span></a></h3><ul><li><p>步骤：</p><ol><li><p>移除根节点（最大堆最大元素）。</p></li><li><p>用最后一个元素填补根节点。</p></li><li><p>“下沉”（bubble-down / sift-down）：</p><ul><li>与左右子节点比较，选最大的交换。</li><li>直到堆性质满足或到达叶子节点。</li></ul></li></ol></li><li><p>时间复杂度：<code>O(log n)</code></p></li></ul><hr><h3 id="_3-堆化-heapify" tabindex="-1"><a class="header-anchor" href="#_3-堆化-heapify"><span>（3）堆化（Heapify）</span></a></h3><ul><li><p>将任意数组变成堆。</p></li><li><p><strong>自下而上</strong>方式：</p><ul><li>从最后一个非叶子节点开始，执行下沉操作。</li></ul></li><li><p>时间复杂度：<code>O(n)</code>，比重复插入效率高。</p></li></ul><hr><h3 id="_4-获取堆顶" tabindex="-1"><a class="header-anchor" href="#_4-获取堆顶"><span>（4）获取堆顶</span></a></h3><ul><li>直接访问数组第 0 个元素。</li><li>时间复杂度：<code>O(1)</code></li></ul><hr><h2 id="_4️⃣-堆的类型" tabindex="-1"><a class="header-anchor" href="#_4️⃣-堆的类型"><span>4️⃣ 堆的类型</span></a></h2><table><thead><tr><th>类型</th><th>堆性质</th><th>根节点</th></tr></thead><tbody><tr><td>最大堆</td><td>父节点 ≥ 子节点</td><td>最大值</td></tr><tr><td>最小堆</td><td>父节点 ≤ 子节点</td><td>最小值</td></tr></tbody></table><p>在应用上：</p><ul><li><strong>最大堆</strong> → 优先获取最大值</li><li><strong>最小堆</strong> → 优先获取最小值</li></ul><hr><h2 id="_5️⃣-堆的应用场景" tabindex="-1"><a class="header-anchor" href="#_5️⃣-堆的应用场景"><span>5️⃣ 堆的应用场景</span></a></h2><ol><li><p><strong>优先队列</strong>（Priority Queue）</p><ul><li>堆是实现优先队列的经典方式。</li><li>插入元素和获取最大/最小元素都很高效。</li><li>例：任务调度、操作系统 CPU 调度</li></ul></li><li><p><strong>堆排序（Heap Sort）</strong></p><ul><li>利用最大堆从大到小排序。</li><li>时间复杂度：<code>O(n log n)</code>，空间复杂度：<code>O(1)</code>（数组原地排序）</li></ul></li><li><p><strong>Top-K 问题</strong></p><ul><li>找前 K 大/小元素</li><li>用大小为 K 的最小堆或最大堆维护</li></ul></li><li><p><strong>合并 K 个有序数组</strong></p><ul><li>使用最小堆维护当前最小元素</li></ul></li><li><p><strong>图算法</strong></p><ul><li>Dijkstra 最短路径</li><li>Prim 最小生成树</li></ul></li></ol><hr><h2 id="_6️⃣-堆的代码示例-java" tabindex="-1"><a class="header-anchor" href="#_6️⃣-堆的代码示例-java"><span>6️⃣ 堆的代码示例（Java）</span></a></h2><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">import</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> java.util.PriorityQueue</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> class</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> HeapExample</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> static</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> main</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">String</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">[] </span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;">args</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">        // 最小堆</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">        PriorityQueue</span><span style="--shiki-light:#E45649;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">Integer</span><span style="--shiki-light:#E45649;--shiki-dark:#ABB2BF;">&gt; </span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">minHeap</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> PriorityQueue</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&lt;&gt;();</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">        minHeap</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">add</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">5</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">        minHeap</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">add</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">3</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">        minHeap</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">add</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">7</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">        System</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">out</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">println</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">minHeap</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">peek</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">()); </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 3</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">        minHeap</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">poll</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(); </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 删除堆顶</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">        System</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">out</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">println</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">minHeap</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">peek</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">()); </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 5</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">        // 最大堆</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">        PriorityQueue</span><span style="--shiki-light:#E45649;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">Integer</span><span style="--shiki-light:#E45649;--shiki-dark:#ABB2BF;">&gt; </span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">maxHeap</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> PriorityQueue</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&lt;&gt;((a, b) </span><span style="--shiki-light:#C18401;--shiki-dark:#C678DD;">-&gt;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> b </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">-</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> a);</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">        maxHeap</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">add</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">5</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">        maxHeap</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">add</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">3</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">        maxHeap</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">add</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">7</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">        System</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">out</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">println</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">maxHeap</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">peek</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">()); </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 7</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr><h2 id="_7️⃣-小结" tabindex="-1"><a class="header-anchor" href="#_7️⃣-小结"><span>7️⃣ 小结</span></a></h2><ul><li><p>堆是一种 <strong>完全二叉树</strong>，满足堆性质。</p></li><li><p>可以用 <strong>数组</strong> 高效实现。</p></li><li><p>核心操作：</p><ul><li>插入：<code>O(log n)</code> 上浮</li><li>删除堆顶：<code>O(log n)</code> 下沉</li><li>堆化整个数组：<code>O(n)</code></li></ul></li><li><p>常用类型：</p><ul><li>最大堆 → 获取最大值</li><li>最小堆 → 获取最小值</li></ul></li><li><p>广泛应用于：</p><ul><li>优先队列</li><li>堆排序</li><li>Top-K 问题</li><li>图算法</li></ul></li></ul>`,40)]))}const k=s(t,[["render",e]]),d=JSON.parse('{"path":"/posts/data-struct/2025-10-02-heap-01-intro.html","title":"堆(优先队列) heap 入门介绍","lang":"zh-CN","frontmatter":{"title":"堆(优先队列) heap 入门介绍","date":"2025-10-01T00:00:00.000Z","categories":["Data Struct"],"tags":["data-struct","heap","sh"],"published":true,"description":"1️⃣ 堆的概念 堆是一种 完全二叉树（Complete Binary Tree） 的数据结构，同时满足 堆性质（Heap Property）： 最大堆（Max-Heap）：每个节点的值都 大于等于其子节点的值。 最小堆（Min-Heap）：每个节点的值都 小于等于其子节点的值。 特点： 完全二叉树：树除了最后一层外，其他层都满；最后一层从左到右依次填...","head":[["meta",{"property":"og:url","content":"https://houbb.github.io/leetcode-notes/posts/data-struct/2025-10-02-heap-01-intro.html"}],["meta",{"property":"og:site_name","content":"老马啸西风"}],["meta",{"property":"og:title","content":"堆(优先队列) heap 入门介绍"}],["meta",{"property":"og:description","content":"1️⃣ 堆的概念 堆是一种 完全二叉树（Complete Binary Tree） 的数据结构，同时满足 堆性质（Heap Property）： 最大堆（Max-Heap）：每个节点的值都 大于等于其子节点的值。 最小堆（Min-Heap）：每个节点的值都 小于等于其子节点的值。 特点： 完全二叉树：树除了最后一层外，其他层都满；最后一层从左到右依次填..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-10-02T09:21:36.000Z"}],["meta",{"property":"article:tag","content":"data-struct"}],["meta",{"property":"article:tag","content":"heap"}],["meta",{"property":"article:tag","content":"sh"}],["meta",{"property":"article:published_time","content":"2025-10-01T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2025-10-02T09:21:36.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"堆(优先队列) heap 入门介绍\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2025-10-01T00:00:00.000Z\\",\\"dateModified\\":\\"2025-10-02T09:21:36.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"老马啸西风\\",\\"url\\":\\"https://houbb.github.io\\"}]}"]]},"git":{"createdTime":1759396896000,"updatedTime":1759396896000,"contributors":[{"name":"bbhou","username":"bbhou","email":"1557740299@qq.com","commits":1,"url":"https://github.com/bbhou"}]},"readingTime":{"minutes":3.08,"words":924},"filePathRelative":"posts/data-struct/2025-10-02-heap-01-intro.md","localizedDate":"2025年10月1日","excerpt":"<h2>1️⃣ 堆的概念</h2>\\n<p>堆是一种 <strong>完全二叉树（Complete Binary Tree）</strong> 的数据结构，同时满足 <strong>堆性质（Heap Property）</strong>：</p>\\n<ul>\\n<li><strong>最大堆（Max-Heap）</strong>：每个节点的值都 <strong>大于等于其子节点的值</strong>。</li>\\n<li><strong>最小堆（Min-Heap）</strong>：每个节点的值都 <strong>小于等于其子节点的值</strong>。</li>\\n</ul>\\n<p>特点：</p>\\n<ol>\\n<li>完全二叉树：树除了最后一层外，其他层都满；最后一层从左到右依次填充。</li>\\n<li>根节点是堆中最大（最大堆）或最小（最小堆）的值。</li>\\n<li>堆一般用 <strong>数组</strong> 来实现，而不是指针型节点。</li>\\n</ol>","autoDesc":true}');export{k as comp,d as data};
