import{_ as s}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as i,a,o as e}from"./app-2r8xTHS-.js";const n={};function r(h,t){return e(),i("div",null,t[0]||(t[0]=[a(`<h1 id="数组" tabindex="-1"><a class="header-anchor" href="#数组"><span>数组</span></a></h1><p>大家好，我是老马。</p><p>今天我们一起来学习一下数组这种数据结构。</p><h2 id="主要知识" tabindex="-1"><a class="header-anchor" href="#主要知识"><span>主要知识</span></a></h2><p>数组需要拆分下面几个部分：</p><ol><li><p>理论介绍</p></li><li><p>源码分析</p></li><li><p>数据结构实现？</p></li><li><p>题目练习（按照算法思想分类）</p></li><li><p>梳理对应的 sdk 包</p></li><li><p>应用实战</p></li></ol><p>因为这个是 leetcode 系列，所以重点是 4、5(对4再一次总结)。</p><p>为了照顾没有基础的小伙伴，会简单介绍一下1的基础理论。</p><p>简单介绍1，重点为4。其他不是本系列的重点。</p><h1 id="算法篇" tabindex="-1"><a class="header-anchor" href="#算法篇"><span>算法篇</span></a></h1><p>动态规划-记忆化搜索</p><p>递归</p><p>二分查找</p><p>DFS 深度优先遍历</p><p>BFS 广度优先遍历</p><p>回溯</p><p>贪心</p><p>分治：快排、归并</p><h1 id="chat" tabindex="-1"><a class="header-anchor" href="#chat"><span>chat</span></a></h1><h2 id="详细介绍一下力扣算法之深度优先遍历" tabindex="-1"><a class="header-anchor" href="#详细介绍一下力扣算法之深度优先遍历"><span>详细介绍一下力扣算法之深度优先遍历</span></a></h2><p>下面是 LeetCode（力扣）中**深度优先遍历（DFS, Depth-First Search）**的详细介绍。</p><p>我们从基础定义、模板写法、常见题型，到技巧总结和高频题推荐全面讲解，帮助你吃透 DFS 算法。</p><hr><h2 id="🧠-一、什么是深度优先遍历-dfs" tabindex="-1"><a class="header-anchor" href="#🧠-一、什么是深度优先遍历-dfs"><span>🧠 一、什么是深度优先遍历（DFS）？</span></a></h2><blockquote><p>DFS 是一种优先“往深处探索”，直到无法继续后才“回溯”的搜索策略。</p></blockquote><p>就像<strong>走迷宫</strong>：你先一直往一个方向走到底，撞墙了再回退换条路。</p><hr><h2 id="🧩-二、dfs-的核心特性" tabindex="-1"><a class="header-anchor" href="#🧩-二、dfs-的核心特性"><span>🧩 二、DFS 的核心特性</span></a></h2><table><thead><tr><th>特性</th><th>说明</th></tr></thead><tbody><tr><td><strong>递归实现</strong></td><td>DFS 通常使用递归实现，也可以用栈模拟</td></tr><tr><td><strong>走到黑到底</strong></td><td>优先沿着某一条路径走到底</td></tr><tr><td><strong>适合搜索结构</strong></td><td>图、树、网格、排列组合等结构</td></tr><tr><td><strong>可配合剪枝、回溯</strong></td><td>用于构造所有合法解的情况（回溯算法本质就是 DFS）</td></tr></tbody></table><hr><h2 id="🔁-三、dfs-模板写法" tabindex="-1"><a class="header-anchor" href="#🔁-三、dfs-模板写法"><span>🔁 三、DFS 模板写法</span></a></h2><h3 id="✅-1-图-网格搜索-二维方向" tabindex="-1"><a class="header-anchor" href="#✅-1-图-网格搜索-二维方向"><span>✅ 1. 图/网格搜索（二维方向）</span></a></h3><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> dfs</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(</span><span style="--shiki-light:#C18401;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">[][] grid</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> int</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> x</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> int</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> y</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#C18401;--shiki-dark:#C678DD;"> boolean</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">[][] visited) {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    if</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> (超出边界 </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">||</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> visited[x][y] </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">||</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> grid[x][y] 不合法) </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">return</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">    visited[x][y] </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> true</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    for</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> (方向 dir </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">:</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> 上下左右) {</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">        dfs</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(grid</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> newX</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> newY</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> visited)</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">    }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="✅-2-回溯型-dfs-如排列、组合、子集" tabindex="-1"><a class="header-anchor" href="#✅-2-回溯型-dfs-如排列、组合、子集"><span>✅ 2. 回溯型 DFS（如排列、组合、子集）</span></a></h3><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> dfs</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">List</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">&lt;</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">Integer</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">&gt;</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> path</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> int</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> index) {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    if</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> (满足条件) {</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">        res</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">add</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">new</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> ArrayList</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&lt;&gt;(path));</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        return</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">    }</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    for</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> (</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> i </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> index</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> i </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">&lt;</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> n</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> i</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">++</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">) {</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">        path</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">add</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(候选值);</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">        dfs</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(path</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> i </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">+</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 1</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">)</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">      // 递归</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">        path</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">remove</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">path</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">size</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">()</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">-</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // 回溯</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">    }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr><h2 id="🧰-四、dfs-应用场景总结" tabindex="-1"><a class="header-anchor" href="#🧰-四、dfs-应用场景总结"><span>🧰 四、DFS 应用场景总结</span></a></h2><table><thead><tr><th>场景</th><th>说明</th><th>高频题目</th></tr></thead><tbody><tr><td>✅ 二叉树遍历</td><td>DFS 是最自然的遍历方式</td><td><a href="https://leetcode.cn/problems/maximum-depth-of-binary-tree" target="_blank" rel="noopener noreferrer">104. 二叉树最大深度</a></td></tr><tr><td>✅ 图遍历</td><td>判断连通分量、拓扑排序</td><td><a href="https://leetcode.cn/problems/number-of-islands" target="_blank" rel="noopener noreferrer">200. 岛屿数量</a></td></tr><tr><td>✅ 网格走迷宫</td><td>搜索路径、区域大小、封闭岛屿</td><td><a href="https://leetcode.cn/problems/surrounded-regions" target="_blank" rel="noopener noreferrer">130. 被围绕的区域</a></td></tr><tr><td>✅ 回溯搜索</td><td>组合、子集、全排列、N皇后等</td><td><a href="https://leetcode.cn/problems/permutations" target="_blank" rel="noopener noreferrer">46. 全排列</a></td></tr><tr><td>✅ 构造解空间</td><td>分割回文串、加减符号、括号匹配</td><td><a href="https://leetcode.cn/problems/palindrome-partitioning" target="_blank" rel="noopener noreferrer">131. 分割回文串</a></td></tr></tbody></table><hr><h2 id="🌈-五、dfs-与其他算法的关系" tabindex="-1"><a class="header-anchor" href="#🌈-五、dfs-与其他算法的关系"><span>🌈 五、DFS 与其他算法的关系</span></a></h2><table><thead><tr><th>算法/结构</th><th>与 DFS 的关系</th></tr></thead><tbody><tr><td>树结构遍历</td><td>DFS 就是前中后序遍历</td></tr><tr><td>回溯法</td><td>是一种“构造所有解”的 DFS</td></tr><tr><td>分治</td><td>通常用 DFS + 合并逻辑</td></tr><tr><td>动态规划（记忆化）</td><td>DFS + 缓存子结果，就是记忆化搜索</td></tr><tr><td>图算法</td><td>DFS 可用于拓扑排序、环检测、强连通分量等</td></tr></tbody></table><hr><h2 id="🎯-六、力扣经典-dfs-题型总结" tabindex="-1"><a class="header-anchor" href="#🎯-六、力扣经典-dfs-题型总结"><span>🎯 六、力扣经典 DFS 题型总结</span></a></h2><h3 id="✅-1-树型-dfs" tabindex="-1"><a class="header-anchor" href="#✅-1-树型-dfs"><span>✅ 1. 树型 DFS</span></a></h3><table><thead><tr><th>题目</th><th>说明</th></tr></thead><tbody><tr><td><a href="https://leetcode.cn/problems/maximum-depth-of-binary-tree" target="_blank" rel="noopener noreferrer">104. 二叉树最大深度</a></td><td>递归求最大深度</td></tr><tr><td><a href="https://leetcode.cn/problems/invert-binary-tree" target="_blank" rel="noopener noreferrer">226. 翻转二叉树</a></td><td>后序递归交换左右</td></tr><tr><td><a href="https://leetcode.cn/problems/path-sum" target="_blank" rel="noopener noreferrer">112. 路径总和</a></td><td>判断是否存在某条路径</td></tr></tbody></table><hr><h3 id="✅-2-网格-dfs" tabindex="-1"><a class="header-anchor" href="#✅-2-网格-dfs"><span>✅ 2. 网格 DFS</span></a></h3><table><thead><tr><th>题目</th><th>说明</th></tr></thead><tbody><tr><td><a href="https://leetcode.cn/problems/number-of-islands" target="_blank" rel="noopener noreferrer">200. 岛屿数量</a></td><td>统计连通块数目</td></tr><tr><td><a href="https://leetcode.cn/problems/max-area-of-island" target="_blank" rel="noopener noreferrer">695. 岛屿的最大面积</a></td><td>搜索最大连通面积</td></tr><tr><td><a href="https://leetcode.cn/problems/surrounded-regions" target="_blank" rel="noopener noreferrer">130. 被围绕的区域</a></td><td>边界 DFS 防止被围绕</td></tr></tbody></table><hr><h3 id="✅-3-回溯-dfs-回退" tabindex="-1"><a class="header-anchor" href="#✅-3-回溯-dfs-回退"><span>✅ 3. 回溯（DFS + 回退）</span></a></h3><table><thead><tr><th>题目</th><th>说明</th></tr></thead><tbody><tr><td><a href="https://leetcode.cn/problems/permutations" target="_blank" rel="noopener noreferrer">46. 全排列</a></td><td>used 数组标记是否被使用</td></tr><tr><td><a href="https://leetcode.cn/problems/combinations" target="_blank" rel="noopener noreferrer">77. 组合</a></td><td>递归 + 回溯构造所有组合</td></tr><tr><td><a href="https://leetcode.cn/problems/letter-combinations-of-a-phone-number" target="_blank" rel="noopener noreferrer">17. 电话号码的字母组合</a></td><td>递归构造所有结果</td></tr></tbody></table><hr><h3 id="✅-4-构造类-dfs" tabindex="-1"><a class="header-anchor" href="#✅-4-构造类-dfs"><span>✅ 4. 构造类 DFS</span></a></h3><table><thead><tr><th>题目</th><th>说明</th></tr></thead><tbody><tr><td><a href="https://leetcode.cn/problems/generate-parentheses" target="_blank" rel="noopener noreferrer">22. 括号生成</a></td><td>左右括号平衡构造</td></tr><tr><td><a href="https://leetcode.cn/problems/restore-ip-addresses" target="_blank" rel="noopener noreferrer">93. 复原 IP 地址</a></td><td>分割 + 剪枝</td></tr><tr><td><a href="https://leetcode.cn/problems/palindrome-partitioning" target="_blank" rel="noopener noreferrer">131. 分割回文串</a></td><td>子串判回文 + DFS</td></tr></tbody></table><hr><h2 id="🧪-七、dfs-技巧总结" tabindex="-1"><a class="header-anchor" href="#🧪-七、dfs-技巧总结"><span>🧪 七、DFS 技巧总结</span></a></h2><table><thead><tr><th>技巧</th><th>说明</th></tr></thead><tbody><tr><td>✅ 剪枝</td><td>对不可能成功的路径提前 return，提高效率</td></tr><tr><td>✅ 回溯撤销</td><td>构造型 DFS 要记得撤销状态（如 path.remove）</td></tr><tr><td>✅ used[] 标记</td><td>用于排列等避免重复使用</td></tr><tr><td>✅ visited[][]</td><td>图/网格防止走重复路径</td></tr><tr><td>✅ 递归返回值</td><td>有些 DFS 需要返回路径/结果而不是 void</td></tr></tbody></table><hr><h2 id="🚫-八、常见错误" tabindex="-1"><a class="header-anchor" href="#🚫-八、常见错误"><span>🚫 八、常见错误</span></a></h2><table><thead><tr><th>错误类型</th><th>说明</th></tr></thead><tbody><tr><td>无限递归</td><td>忘记终止条件或 visited 标记</td></tr><tr><td>回溯出错</td><td>没有正确撤销 path / 状态</td></tr><tr><td>参数传错</td><td>dfs(i + 1) 写成了 i++ 等</td></tr><tr><td>重复结果</td><td>缺少剪枝 or visited 逻辑不严谨</td></tr></tbody></table><hr><h2 id="📌-九、dfs-和-bfs-对比" tabindex="-1"><a class="header-anchor" href="#📌-九、dfs-和-bfs-对比"><span>📌 九、DFS 和 BFS 对比</span></a></h2><table><thead><tr><th>特性</th><th>DFS</th><th>BFS</th></tr></thead><tbody><tr><td>搜索顺序</td><td>一直向下</td><td>一层层推进</td></tr><tr><td>实现方式</td><td>递归或栈</td><td>队列</td></tr><tr><td>适合场景</td><td>构造类、连通性、构造所有解</td><td>最短路径、层次遍历</td></tr><tr><td>常用结构</td><td>树、图、网格</td><td>图、网格</td></tr></tbody></table><hr><h2 id="📚-十、dfs-练习路线推荐-递进式" tabindex="-1"><a class="header-anchor" href="#📚-十、dfs-练习路线推荐-递进式"><span>📚 十、DFS 练习路线推荐（递进式）</span></a></h2><ol><li>🌱 树类：104, 226, 112</li><li>🌿 网格：200, 695, 130</li><li>🌼 回溯：46, 77, 22, 17</li><li>🌸 构造：93, 131, 241</li><li>🌺 图类：785, 886（染色）、207（拓扑）</li></ol><hr><h2 id="✅-总结一句话" tabindex="-1"><a class="header-anchor" href="#✅-总结一句话"><span>✅ 总结一句话</span></a></h2><blockquote><p>DFS 是处理「结构复杂」和「解空间大」问题的万能工具，配合回溯、剪枝、记忆化更加强大，是 LeetCode 中必须掌握的核心算法。</p></blockquote>`,69)]))}const p=s(n,[["render",r]]),k=JSON.parse('{"path":"/posts/leetcode/topics/dfs/2020-06-06-algorithm-000-leetcode-data-struct-001-topics-algorithms-dfs-01-intro.html","title":"算法篇专题之深度优先遍历 DFS Depth-First Search 01-入门介绍","lang":"zh-CN","frontmatter":{"title":"算法篇专题之深度优先遍历 DFS Depth-First Search 01-入门介绍","date":"2020-06-08T00:00:00.000Z","categories":["Algorithm"],"tags":["algorithm","data-struct","topics","leetcode","dfs","sf"],"published":true,"description":"数组 大家好，我是老马。 今天我们一起来学习一下数组这种数据结构。 主要知识 数组需要拆分下面几个部分： 理论介绍 源码分析 数据结构实现？ 题目练习（按照算法思想分类） 梳理对应的 sdk 包 应用实战 因为这个是 leetcode 系列，所以重点是 4、5(对4再一次总结)。 为了照顾没有基础的小伙伴，会简单介绍一下1的基础理论。 简单介绍1，重点...","head":[["meta",{"property":"og:url","content":"https://houbb.github.io/leetcode-notes/posts/leetcode/topics/dfs/2020-06-06-algorithm-000-leetcode-data-struct-001-topics-algorithms-dfs-01-intro.html"}],["meta",{"property":"og:site_name","content":"老马啸西风"}],["meta",{"property":"og:title","content":"算法篇专题之深度优先遍历 DFS Depth-First Search 01-入门介绍"}],["meta",{"property":"og:description","content":"数组 大家好，我是老马。 今天我们一起来学习一下数组这种数据结构。 主要知识 数组需要拆分下面几个部分： 理论介绍 源码分析 数据结构实现？ 题目练习（按照算法思想分类） 梳理对应的 sdk 包 应用实战 因为这个是 leetcode 系列，所以重点是 4、5(对4再一次总结)。 为了照顾没有基础的小伙伴，会简单介绍一下1的基础理论。 简单介绍1，重点..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-08-22T12:19:07.000Z"}],["meta",{"property":"article:tag","content":"algorithm"}],["meta",{"property":"article:tag","content":"data-struct"}],["meta",{"property":"article:tag","content":"topics"}],["meta",{"property":"article:tag","content":"leetcode"}],["meta",{"property":"article:tag","content":"dfs"}],["meta",{"property":"article:tag","content":"sf"}],["meta",{"property":"article:published_time","content":"2020-06-08T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2025-08-22T12:19:07.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"算法篇专题之深度优先遍历 DFS Depth-First Search 01-入门介绍\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2020-06-08T00:00:00.000Z\\",\\"dateModified\\":\\"2025-08-22T12:19:07.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"老马啸西风\\",\\"url\\":\\"https://houbb.github.io\\"}]}"]]},"git":{"createdTime":1755499309000,"updatedTime":1755865147000,"contributors":[{"name":"binbin.hou","username":"","email":"binbin.hou@huifu.com","commits":2},{"name":"bbhou","username":"bbhou","email":"1557740299@qq.com","commits":2,"url":"https://github.com/bbhou"}]},"readingTime":{"minutes":4.66,"words":1399},"filePathRelative":"posts/leetcode/topics/dfs/2020-06-06-algorithm-000-leetcode-data-struct-001-topics-algorithms-dfs-01-intro.md","localizedDate":"2020年6月8日","excerpt":"\\n<p>大家好，我是老马。</p>\\n<p>今天我们一起来学习一下数组这种数据结构。</p>\\n<h2>主要知识</h2>\\n<p>数组需要拆分下面几个部分：</p>\\n<ol>\\n<li>\\n<p>理论介绍</p>\\n</li>\\n<li>\\n<p>源码分析</p>\\n</li>\\n<li>\\n<p>数据结构实现？</p>\\n</li>\\n<li>\\n<p>题目练习（按照算法思想分类）</p>\\n</li>\\n<li>\\n<p>梳理对应的 sdk 包</p>\\n</li>\\n<li>\\n<p>应用实战</p>\\n</li>\\n</ol>\\n<p>因为这个是 leetcode 系列，所以重点是 4、5(对4再一次总结)。</p>\\n<p>为了照顾没有基础的小伙伴，会简单介绍一下1的基础理论。</p>","autoDesc":true}');export{p as comp,k as data};
