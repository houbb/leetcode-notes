import{_ as i}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as t,a,o as n}from"./app-Cbb6KCGF.js";const e={};function r(h,s){return n(),t("div",null,s[0]||(s[0]=[a(`<h1 id="排序系列" tabindex="-1"><a class="header-anchor" href="#排序系列"><span>排序系列</span></a></h1><p><a href="https://houbb.github.io/2016/07/14/sort-00-overview-sort" target="_blank" rel="noopener noreferrer">sort-00-排序算法汇总</a></p><p><a href="https://houbb.github.io/2016/07/14/sort-01-bubble-sort" target="_blank" rel="noopener noreferrer">sort-01-bubble sort 冒泡排序算法详解</a></p><p><a href="https://houbb.github.io/2016/07/14/sort-02-quick-sort" target="_blank" rel="noopener noreferrer">sort-02-QuickSort 快速排序到底快在哪里？</a></p><p><a href="https://houbb.github.io/2016/07/14/sort-03-select-sort" target="_blank" rel="noopener noreferrer">sort-03-SelectSort 选择排序算法详解</a></p><p><a href="https://houbb.github.io/2016/07/14/sort-04-heap-sort" target="_blank" rel="noopener noreferrer">sort-04-heap sort 堆排序算法详解</a></p><p><a href="https://houbb.github.io/2016/07/14/sort-05-insert-sort" target="_blank" rel="noopener noreferrer">sort-05-insert sort 插入排序算法详解</a></p><p><a href="https://houbb.github.io/2016/07/14/sort-06-shell-sort" target="_blank" rel="noopener noreferrer">sort-06-shell sort 希尔排序算法详解</a></p><p><a href="https://houbb.github.io/2016/07/14/sort-07-merge-sort" target="_blank" rel="noopener noreferrer">sort-07-merge sort 归并排序</a></p><p><a href="https://houbb.github.io/2016/07/14/sort-08-counting-sort" target="_blank" rel="noopener noreferrer">sort-08-counting sort 计数排序</a></p><p><a href="https://houbb.github.io/2016/07/14/sort-09-bucket-sort" target="_blank" rel="noopener noreferrer">sort-09-bucket sort 桶排序</a></p><p><a href="https://houbb.github.io/2016/07/14/sort-10-bigfile-sort" target="_blank" rel="noopener noreferrer">sort-10-bigfile 大文件外部排序</a></p><h1 id="前言" tabindex="-1"><a class="header-anchor" href="#前言"><span>前言</span></a></h1><p>大家好，我是老马。</p><p>以前从工程的角度，已经梳理过一次排序算法。</p><p>这里从力扣算法的角度，重新梳理一遍。</p><p>核心内容包含：</p><p>1）常见排序算法介绍</p><p>2）背后的核心思想</p><p>3）leetcode 经典题目练习+讲解</p><p>4）应用场景、优缺点等对比总结</p><p>5）工程 sdk 包，这个已经完成。</p><ol start="6"><li>可视化</li></ol><h1 id="计数排序-counting-sort" tabindex="-1"><a class="header-anchor" href="#计数排序-counting-sort"><span>计数排序（counting Sort）</span></a></h1><h2 id="📌-一、计数排序简介" tabindex="-1"><a class="header-anchor" href="#📌-一、计数排序简介"><span>📌 一、计数排序简介</span></a></h2><p>计数排序是一种<strong>非比较型的整数排序算法</strong>，利用待排序数据的值作为数组下标，通过统计每个值出现的次数，实现排序。</p><blockquote><p>适合<strong>整数范围不大</strong>且<strong>数据量较大的情况</strong>，不是基于比较的排序，因此效率很高。</p></blockquote><hr><h2 id="🧠-二、核心算法思想" tabindex="-1"><a class="header-anchor" href="#🧠-二、核心算法思想"><span>🧠 二、核心算法思想</span></a></h2><ol><li>找出待排序数组中的最大值 <code>max</code> 和最小值 <code>min</code>（一般考虑非负整数时，min=0）</li><li>创建一个长度为 <code>(max - min + 1)</code> 的计数数组 <code>count</code>，所有元素初始化为 0</li><li>遍历原数组，对每个元素 <code>x</code>，在 <code>count[x - min]</code> 位置计数加一</li><li>根据 <code>count</code> 数组，依次输出排序后的元素（累加计数也可实现稳定排序）</li></ol><hr><h2 id="🎯-三、计数排序步骤" tabindex="-1"><a class="header-anchor" href="#🎯-三、计数排序步骤"><span>🎯 三、计数排序步骤</span></a></h2><p>假设数组为 <code>[2, 5, 3, 0, 2, 3, 0, 3]</code></p><ul><li><p>最大值 max = 5，最小值 min = 0</p></li><li><p>创建长度为 6 的计数数组 <code>count = [0,0,0,0,0,0]</code></p></li><li><p>统计出现次数：</p><table><thead><tr><th>数值</th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th></tr></thead><tbody><tr><td>频率</td><td>2</td><td>0</td><td>2</td><td>3</td><td>0</td><td>1</td></tr></tbody></table></li><li><p>输出排序结果：</p><p><code>[0,0,2,2,3,3,3,5]</code></p></li></ul><hr><h2 id="✅-四、java代码实现-稳定版本" tabindex="-1"><a class="header-anchor" href="#✅-四、java代码实现-稳定版本"><span>✅ 四、Java代码实现（稳定版本）</span></a></h2><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> countingSort</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(</span><span style="--shiki-light:#C18401;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">[] arr) {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    if</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> (arr </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">==</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> null</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> ||</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> arr</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">length</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> ==</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 0</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">) </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">return</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    // 找最大最小值</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    int</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> max </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> arr[</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">0</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">]</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    int</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> min </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> arr[</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">0</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">]</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    for</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> (</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> num </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">:</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> arr) {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        if</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> (num </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">&gt;</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> max) max </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> num</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        if</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> (num </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">&lt;</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> min) min </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> num</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    int</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> range </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> max </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">-</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> min </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">+</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#C678DD;">    int</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">[] count </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#C18401;--shiki-dark:#C678DD;"> int</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">[range]</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    // 统计频率</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    for</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> (</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> num </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">:</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> arr) {</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">        count[num </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">-</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> min]</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">++;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    // 累加计数，实现稳定排序</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    for</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> (</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> i </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> i </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">&lt;</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> count</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">length</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> i</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">++</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">) {</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">        count[i] </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">+=</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> count[i </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">-</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 1</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">]</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#C678DD;">    int</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">[] output </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#C18401;--shiki-dark:#C678DD;"> int</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">[</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">arr</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">length</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">]</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    // 从后往前遍历，保持稳定性</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    for</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> (</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> i </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> arr</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">length</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> -</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> i </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">&gt;=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 0</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> i</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">--</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">) {</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">        output[count[arr[i] </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">-</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> min] </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">-</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 1</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">] </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> arr[i]</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">        count[arr[i] </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">-</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> min]</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">--;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    // 复制回原数组</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">    System</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">arraycopy</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(output, </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">0</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, arr, </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">0</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">arr</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">length</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr><h2 id="📈-五、复杂度分析" tabindex="-1"><a class="header-anchor" href="#📈-五、复杂度分析"><span>📈 五、复杂度分析</span></a></h2><table><thead><tr><th>维度</th><th>复杂度</th></tr></thead><tbody><tr><td>时间复杂度</td><td>O(n + k)，n为元素数，k为数值范围</td></tr><tr><td>空间复杂度</td><td>O(n + k)</td></tr><tr><td>是否稳定</td><td>✅ 稳定（如果按上面实现）</td></tr></tbody></table><hr><h2 id="⚖️-六、优缺点总结" tabindex="-1"><a class="header-anchor" href="#⚖️-六、优缺点总结"><span>⚖️ 六、优缺点总结</span></a></h2><table><thead><tr><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>时间复杂度接近线性 O(n + k)</td><td>受限于数据范围 k，范围大时耗内存大</td></tr><tr><td>实现简单，速度快</td><td>不适合非整数或范围很大的数据</td></tr><tr><td>稳定排序</td><td>不是比较排序，不能直接用于浮点或复杂类型</td></tr></tbody></table><hr><h2 id="🧰-七、适用场景" tabindex="-1"><a class="header-anchor" href="#🧰-七、适用场景"><span>🧰 七、适用场景</span></a></h2><table><thead><tr><th>场景</th><th>是否推荐</th></tr></thead><tbody><tr><td>✅ 整数范围有限且较小的数据</td><td>推荐</td></tr><tr><td>✅ 大量数据需要快速排序</td><td>推荐</td></tr><tr><td>❌ 数据范围极大或稀疏</td><td>不推荐</td></tr><tr><td>❌ 需要排序浮点数或复杂对象</td><td>不推荐</td></tr></tbody></table><h1 id="经典题目" tabindex="-1"><a class="header-anchor" href="#经典题目"><span>经典题目</span></a></h1><p>在 LeetCode（力扣）上，<strong>计数排序（Counting Sort）<strong>本身很少直接作为题目标签出现，但有不少</strong>适合用计数排序优化</strong>的题目，尤其是涉及「范围较小的整数频率统计」类问题。以下是一些经典代表题目，适合用或改造为计数排序思路解决：</p><hr><h3 id="✅-经典适用题目推荐" tabindex="-1"><a class="header-anchor" href="#✅-经典适用题目推荐"><span>✅ 经典适用题目推荐</span></a></h3><table><thead><tr><th>题号</th><th>标题</th><th>说明</th></tr></thead><tbody><tr><td><a href="https://leetcode.cn/problems/sort-colors/" target="_blank" rel="noopener noreferrer">75</a></td><td>颜色分类（Sort Colors）</td><td>最经典的计数排序题之一，值域只有 0、1、2。可用计数排序（统计个数）或双指针三路快排思想</td></tr><tr><td><a href="https://leetcode.cn/problems/how-many-numbers-are-smaller-than-the-current-number/" target="_blank" rel="noopener noreferrer">1365</a></td><td>有多少小于当前数字的数字</td><td>值域 [0, 100]，可用计数排序 + 前缀和快速解决</td></tr><tr><td><a href="https://leetcode.cn/problems/rank-transform-of-an-array/" target="_blank" rel="noopener noreferrer">1331</a></td><td>数组序号转换</td><td>离散化题，可借用计数排序思想处理映射关系</td></tr><tr><td><a href="https://leetcode.cn/problems/top-k-frequent-elements/" target="_blank" rel="noopener noreferrer">347</a></td><td>前 K 个高频元素</td><td>结合桶排序的思想（频率做桶），经典题</td></tr><tr><td><a href="https://leetcode.cn/problems/sort-characters-by-frequency/" target="_blank" rel="noopener noreferrer">451</a></td><td>根据字符出现频率排序</td><td>可用计数 + 桶排序方式</td></tr><tr><td><a href="https://leetcode.cn/problems/k-closest-points-to-origin/" target="_blank" rel="noopener noreferrer">973</a></td><td>最接近原点的 K 个点</td><td>若用计数排序思想则需结合桶或值域限制</td></tr><tr><td><a href="https://leetcode.cn/problems/maximum-gap/" target="_blank" rel="noopener noreferrer">164</a></td><td>最大间距</td><td>桶排序/计数排序思想的进阶题</td></tr></tbody></table><hr><h3 id="✅-进阶练习-计数排序或桶排序变种" tabindex="-1"><a class="header-anchor" href="#✅-进阶练习-计数排序或桶排序变种"><span>✅ 进阶练习（计数排序或桶排序变种）</span></a></h3><table><thead><tr><th>题号</th><th>标题</th><th>说明</th></tr></thead><tbody><tr><td><a href="https://leetcode.cn/problems/kth-largest-element-in-an-array/" target="_blank" rel="noopener noreferrer">215</a></td><td>数组中的第 K 个最大元素</td><td>可以通过计数排序加速（若值域小）</td></tr><tr><td><a href="https://leetcode.cn/problems/valid-anagram/" target="_blank" rel="noopener noreferrer">242</a></td><td>有效的字母异位词</td><td>典型的 26 个字母计数</td></tr><tr><td><a href="https://leetcode.cn/problems/ransom-note/" target="_blank" rel="noopener noreferrer">383</a></td><td>赎金信</td><td>也是字母频率统计问题</td></tr><tr><td><a href="https://leetcode.cn/problems/find-the-difference/" target="_blank" rel="noopener noreferrer">389</a></td><td>找不同</td><td>计数法可轻松解决</td></tr><tr><td><a href="https://leetcode.cn/problems/bulls-and-cows/" target="_blank" rel="noopener noreferrer">299</a></td><td>猜数字游戏</td><td>用计数数组统计牛数</td></tr><tr><td><a href="https://leetcode.cn/problems/count-common-words-with-one-occurrence/" target="_blank" rel="noopener noreferrer">2085</a></td><td>统计两个字符串数组中唯一字符串的数目</td><td>使用 Map 也行，但值域可控时计数更高效</td></tr></tbody></table><hr><h3 id="🧠-总结-适合用计数排序的题目特征" tabindex="-1"><a class="header-anchor" href="#🧠-总结-适合用计数排序的题目特征"><span>🧠 总结：适合用计数排序的题目特征</span></a></h3><ul><li>数据范围小（如 0-100 或 0-1000）</li><li>无需比较操作</li><li>可用频率统计 + 前缀和等技巧优化</li><li>类似“桶排序”思想，计数作为中间结构</li></ul>`,57)]))}const k=i(e,[["render",r]]),d=JSON.parse('{"path":"/posts/leetcode/topliked-100/sort/2020-06-06-algorithm-000-leetcode-data-struct-006-sort-08-counting-sort-01-intro.html","title":"leetcode sort 排序-08-countingSort 计数排序入门介绍","lang":"zh-CN","frontmatter":{"title":"leetcode sort 排序-08-countingSort 计数排序入门介绍","date":"2020-06-08T00:00:00.000Z","categories":["TopLiked100"],"tags":["algorithm","sort","sf"],"published":true,"description":"排序系列 sort-00-排序算法汇总 sort-01-bubble sort 冒泡排序算法详解 sort-02-QuickSort 快速排序到底快在哪里？ sort-03-SelectSort 选择排序算法详解 sort-04-heap sort 堆排序算法详解 sort-05-insert sort 插入排序算法详解 sort-06-shell s...","head":[["meta",{"property":"og:url","content":"https://houbb.github.io/leetcode-notes/posts/leetcode/topliked-100/sort/2020-06-06-algorithm-000-leetcode-data-struct-006-sort-08-counting-sort-01-intro.html"}],["meta",{"property":"og:site_name","content":"老马啸西风"}],["meta",{"property":"og:title","content":"leetcode sort 排序-08-countingSort 计数排序入门介绍"}],["meta",{"property":"og:description","content":"排序系列 sort-00-排序算法汇总 sort-01-bubble sort 冒泡排序算法详解 sort-02-QuickSort 快速排序到底快在哪里？ sort-03-SelectSort 选择排序算法详解 sort-04-heap sort 堆排序算法详解 sort-05-insert sort 插入排序算法详解 sort-06-shell s..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-09-24T02:52:43.000Z"}],["meta",{"property":"article:tag","content":"algorithm"}],["meta",{"property":"article:tag","content":"sort"}],["meta",{"property":"article:tag","content":"sf"}],["meta",{"property":"article:published_time","content":"2020-06-08T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2025-09-24T02:52:43.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"leetcode sort 排序-08-countingSort 计数排序入门介绍\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2020-06-08T00:00:00.000Z\\",\\"dateModified\\":\\"2025-09-24T02:52:43.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"老马啸西风\\",\\"url\\":\\"https://houbb.github.io\\"}]}"]]},"git":{"createdTime":1755499309000,"updatedTime":1758682363000,"contributors":[{"name":"binbin.hou","username":"","email":"binbin.hou@huifu.com","commits":4},{"name":"bbhou","username":"bbhou","email":"1557740299@qq.com","commits":2,"url":"https://github.com/bbhou"}]},"readingTime":{"minutes":4.99,"words":1498},"filePathRelative":"posts/leetcode/topliked-100/sort/2020-06-06-algorithm-000-leetcode-data-struct-006-sort-08-counting-sort-01-intro.md","localizedDate":"2020年6月8日","excerpt":"\\n<p><a href=\\"https://houbb.github.io/2016/07/14/sort-00-overview-sort\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">sort-00-排序算法汇总</a></p>\\n<p><a href=\\"https://houbb.github.io/2016/07/14/sort-01-bubble-sort\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">sort-01-bubble sort 冒泡排序算法详解</a></p>\\n<p><a href=\\"https://houbb.github.io/2016/07/14/sort-02-quick-sort\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">sort-02-QuickSort 快速排序到底快在哪里？</a></p>","autoDesc":true}');export{k as comp,d as data};
