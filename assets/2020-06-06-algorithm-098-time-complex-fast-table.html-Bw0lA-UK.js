import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as l,a as n,o as d}from"./app-BZYhpQRl.js";const i={};function s(a,t){return d(),l("div",null,t[0]||(t[0]=[n(`<h2 id="常见算法的时间复杂度" tabindex="-1"><a class="header-anchor" href="#常见算法的时间复杂度"><span>常见算法的时间复杂度</span></a></h2><h2 id="一、常见算法时间复杂度速查表" tabindex="-1"><a class="header-anchor" href="#一、常见算法时间复杂度速查表"><span>一、常见算法时间复杂度速查表</span></a></h2><table><thead><tr><th style="text-align:left;">算法类别</th><th style="text-align:left;">具体算法</th><th style="text-align:left;">最佳情况</th><th style="text-align:left;">平均情况</th><th style="text-align:left;">最坏情况</th><th style="text-align:left;">空间复杂度 (通常)</th><th style="text-align:left;">关键特点/说明</th></tr></thead><tbody><tr><td style="text-align:left;">排序算法</td><td style="text-align:left;"></td><td style="text-align:left;"></td><td style="text-align:left;"></td><td style="text-align:left;"></td><td style="text-align:left;"></td><td style="text-align:left;"></td></tr><tr><td style="text-align:left;"></td><td style="text-align:left;">冒泡排序 (Bubble Sort)</td><td style="text-align:left;">O(n) (优化后)</td><td style="text-align:left;">O(n²)</td><td style="text-align:left;">O(n²)</td><td style="text-align:left;">O(1)</td><td style="text-align:left;">简单，效率低，原地排序</td></tr><tr><td style="text-align:left;"></td><td style="text-align:left;">选择排序 (Selection Sort)</td><td style="text-align:left;">O(n²)</td><td style="text-align:left;">O(n²)</td><td style="text-align:left;">O(n²)</td><td style="text-align:left;">O(1)</td><td style="text-align:left;">简单，效率低，交换次数少，原地排序</td></tr><tr><td style="text-align:left;"></td><td style="text-align:left;">插入排序 (Insertion Sort)</td><td style="text-align:left;">O(n) (已有序)</td><td style="text-align:left;">O(n²)</td><td style="text-align:left;">O(n²)</td><td style="text-align:left;">O(1)</td><td style="text-align:left;">小规模或基本有序数据高效，原地排序</td></tr><tr><td style="text-align:left;"></td><td style="text-align:left;">希尔排序 (Shell Sort)</td><td style="text-align:left;">O(n log n)</td><td style="text-align:left;">取决于间隔序列</td><td style="text-align:left;">O(n²)</td><td style="text-align:left;">O(1)</td><td style="text-align:left;">插入排序改进版，不稳定</td></tr><tr><td style="text-align:left;"></td><td style="text-align:left;">归并排序 (Merge Sort)</td><td style="text-align:left;">O(n log n)</td><td style="text-align:left;">O(n log n)</td><td style="text-align:left;">O(n log n)</td><td style="text-align:left;">O(n)</td><td style="text-align:left;">稳定，高效，分治典范，需额外空间</td></tr><tr><td style="text-align:left;"></td><td style="text-align:left;">快速排序 (Quick Sort)</td><td style="text-align:left;">O(n log n)</td><td style="text-align:left;">O(n log n)</td><td style="text-align:left;">O(n²) (坏划分)</td><td style="text-align:left;">O(log n) (递归栈)</td><td style="text-align:left;">通常最快，分治，原地排序，最坏情况依赖划分</td></tr><tr><td style="text-align:left;"></td><td style="text-align:left;">堆排序 (Heap Sort)</td><td style="text-align:left;">O(n log n)</td><td style="text-align:left;">O(n log n)</td><td style="text-align:left;">O(n log n)</td><td style="text-align:left;">O(1)</td><td style="text-align:left;">原地排序，不稳定</td></tr><tr><td style="text-align:left;"></td><td style="text-align:left;">计数排序 (Counting Sort)</td><td style="text-align:left;">O(n + k)</td><td style="text-align:left;">O(n + k)</td><td style="text-align:left;">O(n + k)</td><td style="text-align:left;">O(n + k)</td><td style="text-align:left;">非比较排序，k是数据范围，范围小高效</td></tr><tr><td style="text-align:left;"></td><td style="text-align:left;">桶排序 (Bucket Sort)</td><td style="text-align:left;">O(n + k)</td><td style="text-align:left;">O(n + k)</td><td style="text-align:left;">O(n²) (坏分布)</td><td style="text-align:left;">O(n + k)</td><td style="text-align:left;">非比较排序，数据分布均匀高效</td></tr><tr><td style="text-align:left;"></td><td style="text-align:left;">基数排序 (Radix Sort)</td><td style="text-align:left;">O(d*(n + b))</td><td style="text-align:left;">O(d*(n + b))</td><td style="text-align:left;">O(d*(n + b))</td><td style="text-align:left;">O(n + b)</td><td style="text-align:left;">非比较排序，d是位数，b是基数(桶数)，稳定</td></tr><tr><td style="text-align:left;">搜索算法</td><td style="text-align:left;"></td><td style="text-align:left;"></td><td style="text-align:left;"></td><td style="text-align:left;"></td><td style="text-align:left;"></td><td style="text-align:left;"></td></tr><tr><td style="text-align:left;"></td><td style="text-align:left;">线性搜索 (Linear Search)</td><td style="text-align:left;">O(1) (第一个)</td><td style="text-align:left;">O(n)</td><td style="text-align:left;">O(n)</td><td style="text-align:left;">O(1)</td><td style="text-align:left;">无序数组</td></tr><tr><td style="text-align:left;"></td><td style="text-align:left;">二分查找 (Binary Search)</td><td style="text-align:left;">O(1) (中间)</td><td style="text-align:left;">O(log n)</td><td style="text-align:left;">O(log n)</td><td style="text-align:left;">O(1) (迭代)</td><td style="text-align:left;">必须有序数组，分治思想</td></tr><tr><td style="text-align:left;">数据结构操作</td><td style="text-align:left;"></td><td style="text-align:left;"></td><td style="text-align:left;"></td><td style="text-align:left;"></td><td style="text-align:left;"></td><td style="text-align:left;"></td></tr><tr><td style="text-align:left;"></td><td style="text-align:left;">数组</td><td style="text-align:left;"></td><td style="text-align:left;"></td><td style="text-align:left;"></td><td style="text-align:left;"></td><td style="text-align:left;"></td></tr><tr><td style="text-align:left;"></td><td style="text-align:left;">访问 (by index)</td><td style="text-align:left;">O(1)</td><td style="text-align:left;">O(1)</td><td style="text-align:left;">O(1)</td><td style="text-align:left;">-</td><td style="text-align:left;"></td></tr><tr><td style="text-align:left;"></td><td style="text-align:left;">插入/删除 (末尾)</td><td style="text-align:left;">O(1) (摊销)</td><td style="text-align:left;">O(1) (摊销)</td><td style="text-align:left;">O(1) (摊销)</td><td style="text-align:left;">-</td><td style="text-align:left;">动态数组扩容有摊销成本</td></tr><tr><td style="text-align:left;"></td><td style="text-align:left;">插入/删除 (中间/开头)</td><td style="text-align:left;">O(n)</td><td style="text-align:left;">O(n)</td><td style="text-align:left;">O(n)</td><td style="text-align:left;">-</td><td style="text-align:left;">需要移动元素</td></tr><tr><td style="text-align:left;"></td><td style="text-align:left;">搜索 (无序)</td><td style="text-align:left;">O(n)</td><td style="text-align:left;">O(n)</td><td style="text-align:left;">O(n)</td><td style="text-align:left;">-</td><td style="text-align:left;"></td></tr><tr><td style="text-align:left;"></td><td style="text-align:left;">搜索 (有序)</td><td style="text-align:left;">O(log n)</td><td style="text-align:left;">O(log n)</td><td style="text-align:left;">O(log n)</td><td style="text-align:left;">-</td><td style="text-align:left;">二分查找</td></tr><tr><td style="text-align:left;"></td><td style="text-align:left;">链表 (单/双)</td><td style="text-align:left;"></td><td style="text-align:left;"></td><td style="text-align:left;"></td><td style="text-align:left;"></td><td style="text-align:left;"></td></tr><tr><td style="text-align:left;"></td><td style="text-align:left;">访问 (by index)</td><td style="text-align:left;">O(n)</td><td style="text-align:left;">O(n)</td><td style="text-align:left;">O(n)</td><td style="text-align:left;">-</td><td style="text-align:left;">需要遍历</td></tr><tr><td style="text-align:left;"></td><td style="text-align:left;">插入/删除 (已知位置)</td><td style="text-align:left;">O(1)</td><td style="text-align:left;">O(1)</td><td style="text-align:left;">O(1)</td><td style="text-align:left;">-</td><td style="text-align:left;">前提是已获得要操作节点的引用</td></tr><tr><td style="text-align:left;"></td><td style="text-align:left;">插入/删除 (头/尾)</td><td style="text-align:left;">O(1)</td><td style="text-align:left;">O(1)</td><td style="text-align:left;">O(1)</td><td style="text-align:left;">-</td><td style="text-align:left;">通常维护头尾指针</td></tr><tr><td style="text-align:left;"></td><td style="text-align:left;">搜索</td><td style="text-align:left;">O(n)</td><td style="text-align:left;">O(n)</td><td style="text-align:left;">O(n)</td><td style="text-align:left;">-</td><td style="text-align:left;">需要遍历</td></tr><tr><td style="text-align:left;"></td><td style="text-align:left;">哈希表 (HashMap/Dict)</td><td style="text-align:left;"></td><td style="text-align:left;"></td><td style="text-align:left;"></td><td style="text-align:left;"></td><td style="text-align:left;"></td></tr><tr><td style="text-align:left;"></td><td style="text-align:left;">插入 (Insert)</td><td style="text-align:left;">O(1) (摊销)</td><td style="text-align:left;">O(1) (摊销)</td><td style="text-align:left;">O(n) (全冲突)</td><td style="text-align:left;">-</td><td style="text-align:left;">理想情况O(1)，冲突处理影响效率</td></tr><tr><td style="text-align:left;"></td><td style="text-align:left;">查找 (Lookup)</td><td style="text-align:left;">O(1) (摊销)</td><td style="text-align:left;">O(1) (摊销)</td><td style="text-align:left;">O(n) (全冲突)</td><td style="text-align:left;">-</td><td style="text-align:left;">理想情况O(1)，冲突处理影响效率</td></tr><tr><td style="text-align:left;"></td><td style="text-align:left;">删除 (Delete)</td><td style="text-align:left;">O(1) (摊销)</td><td style="text-align:left;">O(1) (摊销)</td><td style="text-align:left;">O(n) (全冲突)</td><td style="text-align:left;">-</td><td style="text-align:left;">理想情况O(1)，冲突处理影响效率</td></tr><tr><td style="text-align:left;"></td><td style="text-align:left;">平衡二叉搜索树 (AVL, RB)</td><td style="text-align:left;"></td><td style="text-align:left;"></td><td style="text-align:left;"></td><td style="text-align:left;"></td><td style="text-align:left;"></td></tr><tr><td style="text-align:left;"></td><td style="text-align:left;">插入 (Insert)</td><td style="text-align:left;">O(1)</td><td style="text-align:left;">O(log n)</td><td style="text-align:left;">O(log n)</td><td style="text-align:left;">O(log n) (递归栈)</td><td style="text-align:left;">自平衡保证O(log n)</td></tr><tr><td style="text-align:left;"></td><td style="text-align:left;">查找 (Search)</td><td style="text-align:left;">O(1) (根)</td><td style="text-align:left;">O(log n)</td><td style="text-align:left;">O(log n)</td><td style="text-align:left;">O(log n) (递归栈)</td><td style="text-align:left;">自平衡保证O(log n)</td></tr><tr><td style="text-align:left;"></td><td style="text-align:left;">删除 (Delete)</td><td style="text-align:left;">O(1) (叶子)</td><td style="text-align:left;">O(log n)</td><td style="text-align:left;">O(log n)</td><td style="text-align:left;">O(log n) (递归栈)</td><td style="text-align:left;">自平衡保证O(log n)</td></tr><tr><td style="text-align:left;"></td><td style="text-align:left;">二叉堆 (优先队列)</td><td style="text-align:left;"></td><td style="text-align:left;"></td><td style="text-align:left;"></td><td style="text-align:left;"></td><td style="text-align:left;"></td></tr><tr><td style="text-align:left;"></td><td style="text-align:left;">插入 (Insert) / 入队 (Enqueue)</td><td style="text-align:left;">O(1) (摊销)</td><td style="text-align:left;">O(log n)</td><td style="text-align:left;">O(log n)</td><td style="text-align:left;">-</td><td style="text-align:left;">堆化 (Heapify Up)</td></tr><tr><td style="text-align:left;"></td><td style="text-align:left;">取最小/最大 (Find Min/Max)</td><td style="text-align:left;">O(1)</td><td style="text-align:left;">O(1)</td><td style="text-align:left;">O(1)</td><td style="text-align:left;">-</td><td style="text-align:left;">查看根节点</td></tr><tr><td style="text-align:left;"></td><td style="text-align:left;">删除最小/最大 (Extract)</td><td style="text-align:left;">O(log n)</td><td style="text-align:left;">O(log n)</td><td style="text-align:left;">O(log n)</td><td style="text-align:left;">-</td><td style="text-align:left;">堆化 (Heapify Down)</td></tr><tr><td style="text-align:left;"></td><td style="text-align:left;">构建堆 (Heap Build)</td><td style="text-align:left;">O(n)</td><td style="text-align:left;">O(n)</td><td style="text-align:left;">O(n)</td><td style="text-align:left;">-</td><td style="text-align:left;">Floyd算法，自底向上堆化</td></tr><tr><td style="text-align:left;">图算法</td><td style="text-align:left;"></td><td style="text-align:left;"></td><td style="text-align:left;"></td><td style="text-align:left;"></td><td style="text-align:left;"></td><td style="text-align:left;"></td></tr><tr><td style="text-align:left;"></td><td style="text-align:left;">广度优先搜索 (BFS)</td><td style="text-align:left;">O(V + E)</td><td style="text-align:left;">O(V + E)</td><td style="text-align:left;">O(V + E)</td><td style="text-align:left;">O(V)</td><td style="text-align:left;">邻接表或邻接矩阵（需转换）</td></tr><tr><td style="text-align:left;"></td><td style="text-align:left;">深度优先搜索 (DFS)</td><td style="text-align:left;">O(V + E)</td><td style="text-align:left;">O(V + E)</td><td style="text-align:left;">O(V + E)</td><td style="text-align:left;">O(V) (递归栈)</td><td style="text-align:left;">邻接表或邻接矩阵（需转换）</td></tr><tr><td style="text-align:left;"></td><td style="text-align:left;">Dijkstra (无负权)</td><td style="text-align:left;">O(V log V + E)</td><td style="text-align:left;">O(V log V + E)</td><td style="text-align:left;">O(V log V + E)</td><td style="text-align:left;">O(V)</td><td style="text-align:left;">优先队列 (堆) 优化后</td></tr><tr><td style="text-align:left;"></td><td style="text-align:left;">Bellman-Ford (可有负权)</td><td style="text-align:left;">O(V*E)</td><td style="text-align:left;">O(V*E)</td><td style="text-align:left;">O(V*E)</td><td style="text-align:left;">O(V)</td><td style="text-align:left;">检测负权环</td></tr><tr><td style="text-align:left;"></td><td style="text-align:left;">Floyd-Warshall (APSP)</td><td style="text-align:left;">O(V³)</td><td style="text-align:left;">O(V³)</td><td style="text-align:left;">O(V³)</td><td style="text-align:left;">O(V²)</td><td style="text-align:left;">所有节点对最短路径，动态规划</td></tr><tr><td style="text-align:left;"></td><td style="text-align:left;">Prim (MST - 邻接矩阵)</td><td style="text-align:left;">O(V²)</td><td style="text-align:left;">O(V²)</td><td style="text-align:left;">O(V²)</td><td style="text-align:left;">O(V)</td><td style="text-align:left;"></td></tr><tr><td style="text-align:left;"></td><td style="text-align:left;">Prim (MST - 邻接表+堆)</td><td style="text-align:left;">O(E log V)</td><td style="text-align:left;">O(E log V)</td><td style="text-align:left;">O(E log V)</td><td style="text-align:left;">O(V)</td><td style="text-align:left;">优先队列 (堆) 优化后</td></tr><tr><td style="text-align:left;"></td><td style="text-align:left;">Kruskal (MST)</td><td style="text-align:left;">O(E log E)</td><td style="text-align:left;">O(E log E)</td><td style="text-align:left;">O(E log E)</td><td style="text-align:left;">O(E+V)</td><td style="text-align:left;">并查集优化后，主要成本在排序边(E log E)</td></tr><tr><td style="text-align:left;">字符串匹配</td><td style="text-align:left;"></td><td style="text-align:left;"></td><td style="text-align:left;"></td><td style="text-align:left;"></td><td style="text-align:left;"></td><td style="text-align:left;"></td></tr><tr><td style="text-align:left;"></td><td style="text-align:left;">朴素算法 (Brute Force)</td><td style="text-align:left;">O(n) (首字符)</td><td style="text-align:left;">O((n-m+1)*m)</td><td style="text-align:left;">O(n*m)</td><td style="text-align:left;">O(1)</td><td style="text-align:left;">n=文本长， m=模式长</td></tr><tr><td style="text-align:left;"></td><td style="text-align:left;">KMP (Knuth-Morris-Pratt)</td><td style="text-align:left;">O(n + m)</td><td style="text-align:left;">O(n + m)</td><td style="text-align:left;">O(n + m)</td><td style="text-align:left;">O(m)</td><td style="text-align:left;">预处理O(m)，匹配O(n)</td></tr><tr><td style="text-align:left;"></td><td style="text-align:left;">Rabin-Karp</td><td style="text-align:left;">O(n + m)</td><td style="text-align:left;">O(n + m)</td><td style="text-align:left;">O(n*m) (坏哈希)</td><td style="text-align:left;">O(1)</td><td style="text-align:left;">基于哈希，平均好，最坏差(哈希冲突)</td></tr></tbody></table><hr><h2 id="二、时间复杂度推断核心技巧-如何分析" tabindex="-1"><a class="header-anchor" href="#二、时间复杂度推断核心技巧-如何分析"><span>二、时间复杂度推断核心技巧 (如何分析？)</span></a></h2><p>分析时间复杂度关键在于找出基本操作执行次数 <code>T(n)</code> 与输入规模 <code>n</code> 之间的函数关系，然后用大O表示法简化（忽略常数、系数、低阶项）。</p><p>以下是实用的推断技巧：</p><ol><li><p>聚焦循环 (Loops are Key):</p><ul><li>单层循环： 循环体执行次数通常与 <code>n</code> 线性相关 -&gt; <code>O(n)</code>。<div class="language-python line-numbers-mode" data-highlighter="shiki" data-ext="python" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">for</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> i </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">in</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> range</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(n):  </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># 循环 n 次</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#61AFEF;">    do_something</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">()  </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># O(1) 操作</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># T(n) = n * O(1) = O(n)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li>嵌套循环： 分析每一层循环的迭代次数。 <ul><li>独立嵌套： 内层循环次数固定或与外层无关 -&gt; 相乘。<div class="language-python line-numbers-mode" data-highlighter="shiki" data-ext="python" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">for</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> i </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">in</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> range</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(n):      </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># 循环 n 次</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    for</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> j </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">in</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> range</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">10</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">): </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># 固定循环 10 次 (常数)</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#61AFEF;">        do_something</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">()  </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># O(1)</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># T(n) = n * 10 * O(1) = O(n)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li>相关嵌套： 内层循环次数依赖于外层循环变量 -&gt; 通常是求和。<div class="language-python line-numbers-mode" data-highlighter="shiki" data-ext="python" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">for</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> i </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">in</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> range</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(n):         </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># i 从 0 到 n-1</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    for</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> j </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">in</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> range</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(i, n):  </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># j 从 i 到 n-1 -&gt; 执行 (n - i) 次</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#61AFEF;">        do_something</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">()     </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># O(1)</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># T(n) = Σ(i=0 to n-1) Σ(j=i to n-1) 1 = Σ(i=0 to n-1) (n - i)</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">#       = n + (n-1) + ... + 1 = n(n+1)/2 = O(n²)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li>多重嵌套： 嵌套层数 <code>k</code> 层，且每层大致循环 <code>n</code> 次 -&gt; <code>O(n^k)</code>。<div class="language-python line-numbers-mode" data-highlighter="shiki" data-ext="python" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">for</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> i </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">in</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> range</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(n):</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    for</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> j </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">in</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> range</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(n):</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        for</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> k </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">in</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> range</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(n):</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#61AFEF;">            do_something</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">() </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># O(1)</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># T(n) = n * n * n * O(1) = O(n³)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul></li></ul></li><li><p>理解递归 (Recursion Requires Equations):</p><ul><li>递归算法的时间复杂度分析通常需要建立递归方程并求解。</li><li>主定理 (Master Theorem)： 解决形如 <code>T(n) = a * T(n/b) + f(n)</code> 的递归方程。这是分析分治算法（如归并、快排、二分查找）的利器。主定理根据 <code>f(n)</code> 与 <code>n^(log_b(a))</code> 的关系给出解： <ul><li><code>f(n) = O(n^(log_b(a) - ε))</code> (ε &gt; 0) -&gt; <code>T(n) = Θ(n^(log_b(a)))</code></li><li><code>f(n) = Θ(n^(log_b(a)))</code> -&gt; <code>T(n) = Θ(n^(log_b(a)) * log n)</code></li><li><code>f(n) = Ω(n^(log_b(a) + ε))</code> (ε &gt; 0) 且 <code>a*f(n/b) &lt;= c*f(n)</code> (c&lt;1) -&gt; <code>T(n) = Θ(f(n))</code></li></ul></li><li>递归树 (Recursion Tree)： 可视化递归调用过程，计算每层工作量和总层数。 <ul><li>例如斐波那契 <code>F(n) = F(n-1) + F(n-2)</code>，递归树是二叉树，节点数约 <code>2^n</code> -&gt; <code>O(2^n)</code>。</li></ul></li><li>展开/代入法 (Iteration/Substitution)： 反复将递归式右边的 <code>T(...)</code> 用定义展开，观察规律或求和。</li></ul></li><li><p>识别分治 (Divide and Conquer Pattern):</p><ul><li>模式：将问题分成 <code>a</code> 个大小为 <code>n/b</code> 的子问题，合并结果代价为 <code>f(n)</code>。</li><li>时间复杂度通式：<code>T(n) = a * T(n/b) + f(n)</code> -&gt; 用主定理分析。</li><li>经典例子： <ul><li>二分查找： <code>T(n) = T(n/2) + O(1)</code> -&gt; <code>a=1, b=2, f(n)=O(1)</code> -&gt; <code>O(log n)</code> (Case 2)。</li><li>归并排序： <code>T(n) = 2T(n/2) + O(n)</code> -&gt; <code>a=2, b=2, f(n)=O(n)</code> -&gt; <code>O(n log n)</code> (Case 2)。</li><li>快速排序 (平均)： <code>T(n) = T(k) + T(n-k-1) + O(n)</code>，假设划分均衡 <code>k≈n/2</code> -&gt; <code>≈ 2T(n/2) + O(n)</code> -&gt; <code>O(n log n)</code> (Case 2)。最坏划分 <code>k=0 或 k=n-1</code> -&gt; <code>T(n) = T(n-1) + O(n)</code> -&gt; <code>O(n²)</code>。</li></ul></li></ul></li><li><p>关注数据结构和操作 (Data Structures Matter):</p><ul><li>不同数据结构的同一操作（如查找、插入、删除）时间复杂度可能天差地别。</li><li>关键问题： <ul><li>这个操作需要遍历多少元素？(线性搜索 vs 二分查找 vs 哈希查找)</li><li>这个操作需要移动多少元素？(数组中间插入 vs 链表已知位置插入)</li><li>这个操作需要维护什么额外结构？(堆插入后需要堆化 <code>O(log n)</code>，平衡树插入后可能需要旋转 <code>O(log n)</code>)</li></ul></li><li>例子： 在已排序数组中查找 -&gt; <code>O(log n)</code> (二分)，在哈希表中查找 -&gt; <code>O(1)</code> (平均)，在链表中查找 -&gt; <code>O(n)</code>。</li></ul></li><li><p>注意“隐藏”成本 (Watch for Hidden Costs):</p><ul><li>函数调用： 递归调用、辅助函数调用会增加栈开销，影响实际常数因子，但不改变大O阶（除非递归深度很大，如链表递归 <code>O(n)</code> 深度）。</li><li>内存分配： 动态数组扩容 (<code>append</code> 的摊销 <code>O(1)</code>)。</li><li>内置操作： 某些语言的内置操作可能不是 <code>O(1)</code>。例如 Python 的 <code>len(list)</code> 是 <code>O(1)</code>（列表存储了长度），而 <code>min(list)</code> 是 <code>O(n)</code>。</li></ul></li><li><p>考虑输入特征 (Consider Input Characteristics):</p><ul><li>最好/最坏/平均： 明确分析的是哪种情况。快排最坏 <code>O(n²)</code>，平均 <code>O(n log n)</code>。</li><li>数据分布： 桶排序、计数排序的效率高度依赖输入数据的范围或分布。</li><li>问题规模： <code>n</code> 代表什么？是数组长度、节点数、边数、还是数值大小？分析 <code>T(n)</code> 时 <code>n</code> 必须一致。</li></ul></li><li><p>利用已知结论 (Leverage Known Results):</p><ul><li>记住常见算法和操作的复杂度（如排序下限 <code>O(n log n)</code>，堆操作 <code>O(log n)</code>，BFS/DFS <code>O(V+E)</code>）。</li><li>组合操作：如果算法由多个步骤组成，总复杂度由最高阶的步骤决定（<code>O(n²) + O(n log n) + O(n) = O(n²)</code>）。</li></ul></li></ol><hr><h2 id="三、核心推断步骤总结" tabindex="-1"><a class="header-anchor" href="#三、核心推断步骤总结"><span>三、核心推断步骤总结</span></a></h2><ol><li>定义 <code>n</code>： 明确输入规模 <code>n</code> 指什么（数组长度？节点数？数值位数？）。</li><li>识别基本操作： 找到执行最频繁、最耗时的核心操作（比较、赋值、算术、特定函数调用）。</li><li>计算 <code>T(n)</code>： <ul><li>对于循环：分析循环次数（单层、嵌套层数、迭代次数关系）。</li><li>对于递归：建立递归方程，使用主定理、递归树或代入法求解。</li><li>对于分治：识别 <code>a</code>, <code>b</code>, <code>f(n)</code>，应用主定理。</li><li>考虑数据结构的固有操作成本。</li></ul></li><li>简化到大O： 忽略常数因子、系数、低阶项，保留最高阶项。</li><li>明确情况： 说明是最好、最坏还是平均时间复杂度。</li></ol><h1 id="参考资料" tabindex="-1"><a class="header-anchor" href="#参考资料"><span>参考资料</span></a></h1>`,12)]))}const f=e(i,[["render",s]]),x=JSON.parse('{"path":"/posts/leetcode/history1/2020-06-06-algorithm-098-time-complex-fast-table.html","title":"力扣刷题之时间复杂度常见算法速查表+推断技巧","lang":"zh-CN","frontmatter":{"title":"力扣刷题之时间复杂度常见算法速查表+推断技巧","date":"2020-06-08T00:00:00.000Z","categories":["Algorithm"],"tags":["algorithm","tips","leetcode"],"published":true,"description":"常见算法的时间复杂度 一、常见算法时间复杂度速查表 二、时间复杂度推断核心技巧 (如何分析？) 分析时间复杂度关键在于找出基本操作执行次数 T(n) 与输入规模 n 之间的函数关系，然后用大O表示法简化（忽略常数、系数、低阶项）。 以下是实用的推断技巧： 聚焦循环 (Loops are Key): 单层循环： 循环体执行次数通常与 n 线性相关 -> ...","head":[["meta",{"property":"og:url","content":"https://houbb.github.io/leetcode-notes/posts/leetcode/history1/2020-06-06-algorithm-098-time-complex-fast-table.html"}],["meta",{"property":"og:site_name","content":"老马啸西风"}],["meta",{"property":"og:title","content":"力扣刷题之时间复杂度常见算法速查表+推断技巧"}],["meta",{"property":"og:description","content":"常见算法的时间复杂度 一、常见算法时间复杂度速查表 二、时间复杂度推断核心技巧 (如何分析？) 分析时间复杂度关键在于找出基本操作执行次数 T(n) 与输入规模 n 之间的函数关系，然后用大O表示法简化（忽略常数、系数、低阶项）。 以下是实用的推断技巧： 聚焦循环 (Loops are Key): 单层循环： 循环体执行次数通常与 n 线性相关 -> ..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-08-22T12:19:07.000Z"}],["meta",{"property":"article:tag","content":"algorithm"}],["meta",{"property":"article:tag","content":"tips"}],["meta",{"property":"article:tag","content":"leetcode"}],["meta",{"property":"article:published_time","content":"2020-06-08T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2025-08-22T12:19:07.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"力扣刷题之时间复杂度常见算法速查表+推断技巧\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2020-06-08T00:00:00.000Z\\",\\"dateModified\\":\\"2025-08-22T12:19:07.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"老马啸西风\\",\\"url\\":\\"https://houbb.github.io\\"}]}"]]},"git":{"createdTime":1755499309000,"updatedTime":1755865147000,"contributors":[{"name":"binbin.hou","username":"","email":"binbin.hou@huifu.com","commits":2},{"name":"bbhou","username":"bbhou","email":"1557740299@qq.com","commits":2,"url":"https://github.com/bbhou"}]},"readingTime":{"minutes":8.71,"words":2614},"filePathRelative":"posts/leetcode/history1/2020-06-06-algorithm-098-time-complex-fast-table.md","localizedDate":"2020年6月8日","excerpt":"<h2>常见算法的时间复杂度</h2>\\n<h2>一、常见算法时间复杂度速查表</h2>\\n<table>\\n<thead>\\n<tr>\\n<th style=\\"text-align:left\\">算法类别</th>\\n<th style=\\"text-align:left\\">具体算法</th>\\n<th style=\\"text-align:left\\">最佳情况</th>\\n<th style=\\"text-align:left\\">平均情况</th>\\n<th style=\\"text-align:left\\">最坏情况</th>\\n<th style=\\"text-align:left\\">空间复杂度 (通常)</th>\\n<th style=\\"text-align:left\\">关键特点/说明</th>\\n</tr>\\n</thead>\\n<tbody>\\n<tr>\\n<td style=\\"text-align:left\\">排序算法</td>\\n<td style=\\"text-align:left\\"></td>\\n<td style=\\"text-align:left\\"></td>\\n<td style=\\"text-align:left\\"></td>\\n<td style=\\"text-align:left\\"></td>\\n<td style=\\"text-align:left\\"></td>\\n<td style=\\"text-align:left\\"></td>\\n</tr>\\n<tr>\\n<td style=\\"text-align:left\\"></td>\\n<td style=\\"text-align:left\\">冒泡排序 (Bubble Sort)</td>\\n<td style=\\"text-align:left\\">O(n) (优化后)</td>\\n<td style=\\"text-align:left\\">O(n²)</td>\\n<td style=\\"text-align:left\\">O(n²)</td>\\n<td style=\\"text-align:left\\">O(1)</td>\\n<td style=\\"text-align:left\\">简单，效率低，原地排序</td>\\n</tr>\\n<tr>\\n<td style=\\"text-align:left\\"></td>\\n<td style=\\"text-align:left\\">选择排序 (Selection Sort)</td>\\n<td style=\\"text-align:left\\">O(n²)</td>\\n<td style=\\"text-align:left\\">O(n²)</td>\\n<td style=\\"text-align:left\\">O(n²)</td>\\n<td style=\\"text-align:left\\">O(1)</td>\\n<td style=\\"text-align:left\\">简单，效率低，交换次数少，原地排序</td>\\n</tr>\\n<tr>\\n<td style=\\"text-align:left\\"></td>\\n<td style=\\"text-align:left\\">插入排序 (Insertion Sort)</td>\\n<td style=\\"text-align:left\\">O(n) (已有序)</td>\\n<td style=\\"text-align:left\\">O(n²)</td>\\n<td style=\\"text-align:left\\">O(n²)</td>\\n<td style=\\"text-align:left\\">O(1)</td>\\n<td style=\\"text-align:left\\">小规模或基本有序数据高效，原地排序</td>\\n</tr>\\n<tr>\\n<td style=\\"text-align:left\\"></td>\\n<td style=\\"text-align:left\\">希尔排序 (Shell Sort)</td>\\n<td style=\\"text-align:left\\">O(n log n)</td>\\n<td style=\\"text-align:left\\">取决于间隔序列</td>\\n<td style=\\"text-align:left\\">O(n²)</td>\\n<td style=\\"text-align:left\\">O(1)</td>\\n<td style=\\"text-align:left\\">插入排序改进版，不稳定</td>\\n</tr>\\n<tr>\\n<td style=\\"text-align:left\\"></td>\\n<td style=\\"text-align:left\\">归并排序 (Merge Sort)</td>\\n<td style=\\"text-align:left\\">O(n log n)</td>\\n<td style=\\"text-align:left\\">O(n log n)</td>\\n<td style=\\"text-align:left\\">O(n log n)</td>\\n<td style=\\"text-align:left\\">O(n)</td>\\n<td style=\\"text-align:left\\">稳定，高效，分治典范，需额外空间</td>\\n</tr>\\n<tr>\\n<td style=\\"text-align:left\\"></td>\\n<td style=\\"text-align:left\\">快速排序 (Quick Sort)</td>\\n<td style=\\"text-align:left\\">O(n log n)</td>\\n<td style=\\"text-align:left\\">O(n log n)</td>\\n<td style=\\"text-align:left\\">O(n²) (坏划分)</td>\\n<td style=\\"text-align:left\\">O(log n) (递归栈)</td>\\n<td style=\\"text-align:left\\">通常最快，分治，原地排序，最坏情况依赖划分</td>\\n</tr>\\n<tr>\\n<td style=\\"text-align:left\\"></td>\\n<td style=\\"text-align:left\\">堆排序 (Heap Sort)</td>\\n<td style=\\"text-align:left\\">O(n log n)</td>\\n<td style=\\"text-align:left\\">O(n log n)</td>\\n<td style=\\"text-align:left\\">O(n log n)</td>\\n<td style=\\"text-align:left\\">O(1)</td>\\n<td style=\\"text-align:left\\">原地排序，不稳定</td>\\n</tr>\\n<tr>\\n<td style=\\"text-align:left\\"></td>\\n<td style=\\"text-align:left\\">计数排序 (Counting Sort)</td>\\n<td style=\\"text-align:left\\">O(n + k)</td>\\n<td style=\\"text-align:left\\">O(n + k)</td>\\n<td style=\\"text-align:left\\">O(n + k)</td>\\n<td style=\\"text-align:left\\">O(n + k)</td>\\n<td style=\\"text-align:left\\">非比较排序，k是数据范围，范围小高效</td>\\n</tr>\\n<tr>\\n<td style=\\"text-align:left\\"></td>\\n<td style=\\"text-align:left\\">桶排序 (Bucket Sort)</td>\\n<td style=\\"text-align:left\\">O(n + k)</td>\\n<td style=\\"text-align:left\\">O(n + k)</td>\\n<td style=\\"text-align:left\\">O(n²) (坏分布)</td>\\n<td style=\\"text-align:left\\">O(n + k)</td>\\n<td style=\\"text-align:left\\">非比较排序，数据分布均匀高效</td>\\n</tr>\\n<tr>\\n<td style=\\"text-align:left\\"></td>\\n<td style=\\"text-align:left\\">基数排序 (Radix Sort)</td>\\n<td style=\\"text-align:left\\">O(d*(n + b))</td>\\n<td style=\\"text-align:left\\">O(d*(n + b))</td>\\n<td style=\\"text-align:left\\">O(d*(n + b))</td>\\n<td style=\\"text-align:left\\">O(n + b)</td>\\n<td style=\\"text-align:left\\">非比较排序，d是位数，b是基数(桶数)，稳定</td>\\n</tr>\\n<tr>\\n<td style=\\"text-align:left\\">搜索算法</td>\\n<td style=\\"text-align:left\\"></td>\\n<td style=\\"text-align:left\\"></td>\\n<td style=\\"text-align:left\\"></td>\\n<td style=\\"text-align:left\\"></td>\\n<td style=\\"text-align:left\\"></td>\\n<td style=\\"text-align:left\\"></td>\\n</tr>\\n<tr>\\n<td style=\\"text-align:left\\"></td>\\n<td style=\\"text-align:left\\">线性搜索 (Linear Search)</td>\\n<td style=\\"text-align:left\\">O(1) (第一个)</td>\\n<td style=\\"text-align:left\\">O(n)</td>\\n<td style=\\"text-align:left\\">O(n)</td>\\n<td style=\\"text-align:left\\">O(1)</td>\\n<td style=\\"text-align:left\\">无序数组</td>\\n</tr>\\n<tr>\\n<td style=\\"text-align:left\\"></td>\\n<td style=\\"text-align:left\\">二分查找 (Binary Search)</td>\\n<td style=\\"text-align:left\\">O(1) (中间)</td>\\n<td style=\\"text-align:left\\">O(log n)</td>\\n<td style=\\"text-align:left\\">O(log n)</td>\\n<td style=\\"text-align:left\\">O(1) (迭代)</td>\\n<td style=\\"text-align:left\\">必须有序数组，分治思想</td>\\n</tr>\\n<tr>\\n<td style=\\"text-align:left\\">数据结构操作</td>\\n<td style=\\"text-align:left\\"></td>\\n<td style=\\"text-align:left\\"></td>\\n<td style=\\"text-align:left\\"></td>\\n<td style=\\"text-align:left\\"></td>\\n<td style=\\"text-align:left\\"></td>\\n<td style=\\"text-align:left\\"></td>\\n</tr>\\n<tr>\\n<td style=\\"text-align:left\\"></td>\\n<td style=\\"text-align:left\\">数组</td>\\n<td style=\\"text-align:left\\"></td>\\n<td style=\\"text-align:left\\"></td>\\n<td style=\\"text-align:left\\"></td>\\n<td style=\\"text-align:left\\"></td>\\n<td style=\\"text-align:left\\"></td>\\n</tr>\\n<tr>\\n<td style=\\"text-align:left\\"></td>\\n<td style=\\"text-align:left\\">访问 (by index)</td>\\n<td style=\\"text-align:left\\">O(1)</td>\\n<td style=\\"text-align:left\\">O(1)</td>\\n<td style=\\"text-align:left\\">O(1)</td>\\n<td style=\\"text-align:left\\">-</td>\\n<td style=\\"text-align:left\\"></td>\\n</tr>\\n<tr>\\n<td style=\\"text-align:left\\"></td>\\n<td style=\\"text-align:left\\">插入/删除 (末尾)</td>\\n<td style=\\"text-align:left\\">O(1) (摊销)</td>\\n<td style=\\"text-align:left\\">O(1) (摊销)</td>\\n<td style=\\"text-align:left\\">O(1) (摊销)</td>\\n<td style=\\"text-align:left\\">-</td>\\n<td style=\\"text-align:left\\">动态数组扩容有摊销成本</td>\\n</tr>\\n<tr>\\n<td style=\\"text-align:left\\"></td>\\n<td style=\\"text-align:left\\">插入/删除 (中间/开头)</td>\\n<td style=\\"text-align:left\\">O(n)</td>\\n<td style=\\"text-align:left\\">O(n)</td>\\n<td style=\\"text-align:left\\">O(n)</td>\\n<td style=\\"text-align:left\\">-</td>\\n<td style=\\"text-align:left\\">需要移动元素</td>\\n</tr>\\n<tr>\\n<td style=\\"text-align:left\\"></td>\\n<td style=\\"text-align:left\\">搜索 (无序)</td>\\n<td style=\\"text-align:left\\">O(n)</td>\\n<td style=\\"text-align:left\\">O(n)</td>\\n<td style=\\"text-align:left\\">O(n)</td>\\n<td style=\\"text-align:left\\">-</td>\\n<td style=\\"text-align:left\\"></td>\\n</tr>\\n<tr>\\n<td style=\\"text-align:left\\"></td>\\n<td style=\\"text-align:left\\">搜索 (有序)</td>\\n<td style=\\"text-align:left\\">O(log n)</td>\\n<td style=\\"text-align:left\\">O(log n)</td>\\n<td style=\\"text-align:left\\">O(log n)</td>\\n<td style=\\"text-align:left\\">-</td>\\n<td style=\\"text-align:left\\">二分查找</td>\\n</tr>\\n<tr>\\n<td style=\\"text-align:left\\"></td>\\n<td style=\\"text-align:left\\">链表 (单/双)</td>\\n<td style=\\"text-align:left\\"></td>\\n<td style=\\"text-align:left\\"></td>\\n<td style=\\"text-align:left\\"></td>\\n<td style=\\"text-align:left\\"></td>\\n<td style=\\"text-align:left\\"></td>\\n</tr>\\n<tr>\\n<td style=\\"text-align:left\\"></td>\\n<td style=\\"text-align:left\\">访问 (by index)</td>\\n<td style=\\"text-align:left\\">O(n)</td>\\n<td style=\\"text-align:left\\">O(n)</td>\\n<td style=\\"text-align:left\\">O(n)</td>\\n<td style=\\"text-align:left\\">-</td>\\n<td style=\\"text-align:left\\">需要遍历</td>\\n</tr>\\n<tr>\\n<td style=\\"text-align:left\\"></td>\\n<td style=\\"text-align:left\\">插入/删除 (已知位置)</td>\\n<td style=\\"text-align:left\\">O(1)</td>\\n<td style=\\"text-align:left\\">O(1)</td>\\n<td style=\\"text-align:left\\">O(1)</td>\\n<td style=\\"text-align:left\\">-</td>\\n<td style=\\"text-align:left\\">前提是已获得要操作节点的引用</td>\\n</tr>\\n<tr>\\n<td style=\\"text-align:left\\"></td>\\n<td style=\\"text-align:left\\">插入/删除 (头/尾)</td>\\n<td style=\\"text-align:left\\">O(1)</td>\\n<td style=\\"text-align:left\\">O(1)</td>\\n<td style=\\"text-align:left\\">O(1)</td>\\n<td style=\\"text-align:left\\">-</td>\\n<td style=\\"text-align:left\\">通常维护头尾指针</td>\\n</tr>\\n<tr>\\n<td style=\\"text-align:left\\"></td>\\n<td style=\\"text-align:left\\">搜索</td>\\n<td style=\\"text-align:left\\">O(n)</td>\\n<td style=\\"text-align:left\\">O(n)</td>\\n<td style=\\"text-align:left\\">O(n)</td>\\n<td style=\\"text-align:left\\">-</td>\\n<td style=\\"text-align:left\\">需要遍历</td>\\n</tr>\\n<tr>\\n<td style=\\"text-align:left\\"></td>\\n<td style=\\"text-align:left\\">哈希表 (HashMap/Dict)</td>\\n<td style=\\"text-align:left\\"></td>\\n<td style=\\"text-align:left\\"></td>\\n<td style=\\"text-align:left\\"></td>\\n<td style=\\"text-align:left\\"></td>\\n<td style=\\"text-align:left\\"></td>\\n</tr>\\n<tr>\\n<td style=\\"text-align:left\\"></td>\\n<td style=\\"text-align:left\\">插入 (Insert)</td>\\n<td style=\\"text-align:left\\">O(1) (摊销)</td>\\n<td style=\\"text-align:left\\">O(1) (摊销)</td>\\n<td style=\\"text-align:left\\">O(n) (全冲突)</td>\\n<td style=\\"text-align:left\\">-</td>\\n<td style=\\"text-align:left\\">理想情况O(1)，冲突处理影响效率</td>\\n</tr>\\n<tr>\\n<td style=\\"text-align:left\\"></td>\\n<td style=\\"text-align:left\\">查找 (Lookup)</td>\\n<td style=\\"text-align:left\\">O(1) (摊销)</td>\\n<td style=\\"text-align:left\\">O(1) (摊销)</td>\\n<td style=\\"text-align:left\\">O(n) (全冲突)</td>\\n<td style=\\"text-align:left\\">-</td>\\n<td style=\\"text-align:left\\">理想情况O(1)，冲突处理影响效率</td>\\n</tr>\\n<tr>\\n<td style=\\"text-align:left\\"></td>\\n<td style=\\"text-align:left\\">删除 (Delete)</td>\\n<td style=\\"text-align:left\\">O(1) (摊销)</td>\\n<td style=\\"text-align:left\\">O(1) (摊销)</td>\\n<td style=\\"text-align:left\\">O(n) (全冲突)</td>\\n<td style=\\"text-align:left\\">-</td>\\n<td style=\\"text-align:left\\">理想情况O(1)，冲突处理影响效率</td>\\n</tr>\\n<tr>\\n<td style=\\"text-align:left\\"></td>\\n<td style=\\"text-align:left\\">平衡二叉搜索树 (AVL, RB)</td>\\n<td style=\\"text-align:left\\"></td>\\n<td style=\\"text-align:left\\"></td>\\n<td style=\\"text-align:left\\"></td>\\n<td style=\\"text-align:left\\"></td>\\n<td style=\\"text-align:left\\"></td>\\n</tr>\\n<tr>\\n<td style=\\"text-align:left\\"></td>\\n<td style=\\"text-align:left\\">插入 (Insert)</td>\\n<td style=\\"text-align:left\\">O(1)</td>\\n<td style=\\"text-align:left\\">O(log n)</td>\\n<td style=\\"text-align:left\\">O(log n)</td>\\n<td style=\\"text-align:left\\">O(log n) (递归栈)</td>\\n<td style=\\"text-align:left\\">自平衡保证O(log n)</td>\\n</tr>\\n<tr>\\n<td style=\\"text-align:left\\"></td>\\n<td style=\\"text-align:left\\">查找 (Search)</td>\\n<td style=\\"text-align:left\\">O(1) (根)</td>\\n<td style=\\"text-align:left\\">O(log n)</td>\\n<td style=\\"text-align:left\\">O(log n)</td>\\n<td style=\\"text-align:left\\">O(log n) (递归栈)</td>\\n<td style=\\"text-align:left\\">自平衡保证O(log n)</td>\\n</tr>\\n<tr>\\n<td style=\\"text-align:left\\"></td>\\n<td style=\\"text-align:left\\">删除 (Delete)</td>\\n<td style=\\"text-align:left\\">O(1) (叶子)</td>\\n<td style=\\"text-align:left\\">O(log n)</td>\\n<td style=\\"text-align:left\\">O(log n)</td>\\n<td style=\\"text-align:left\\">O(log n) (递归栈)</td>\\n<td style=\\"text-align:left\\">自平衡保证O(log n)</td>\\n</tr>\\n<tr>\\n<td style=\\"text-align:left\\"></td>\\n<td style=\\"text-align:left\\">二叉堆 (优先队列)</td>\\n<td style=\\"text-align:left\\"></td>\\n<td style=\\"text-align:left\\"></td>\\n<td style=\\"text-align:left\\"></td>\\n<td style=\\"text-align:left\\"></td>\\n<td style=\\"text-align:left\\"></td>\\n</tr>\\n<tr>\\n<td style=\\"text-align:left\\"></td>\\n<td style=\\"text-align:left\\">插入 (Insert) / 入队 (Enqueue)</td>\\n<td style=\\"text-align:left\\">O(1) (摊销)</td>\\n<td style=\\"text-align:left\\">O(log n)</td>\\n<td style=\\"text-align:left\\">O(log n)</td>\\n<td style=\\"text-align:left\\">-</td>\\n<td style=\\"text-align:left\\">堆化 (Heapify Up)</td>\\n</tr>\\n<tr>\\n<td style=\\"text-align:left\\"></td>\\n<td style=\\"text-align:left\\">取最小/最大 (Find Min/Max)</td>\\n<td style=\\"text-align:left\\">O(1)</td>\\n<td style=\\"text-align:left\\">O(1)</td>\\n<td style=\\"text-align:left\\">O(1)</td>\\n<td style=\\"text-align:left\\">-</td>\\n<td style=\\"text-align:left\\">查看根节点</td>\\n</tr>\\n<tr>\\n<td style=\\"text-align:left\\"></td>\\n<td style=\\"text-align:left\\">删除最小/最大 (Extract)</td>\\n<td style=\\"text-align:left\\">O(log n)</td>\\n<td style=\\"text-align:left\\">O(log n)</td>\\n<td style=\\"text-align:left\\">O(log n)</td>\\n<td style=\\"text-align:left\\">-</td>\\n<td style=\\"text-align:left\\">堆化 (Heapify Down)</td>\\n</tr>\\n<tr>\\n<td style=\\"text-align:left\\"></td>\\n<td style=\\"text-align:left\\">构建堆 (Heap Build)</td>\\n<td style=\\"text-align:left\\">O(n)</td>\\n<td style=\\"text-align:left\\">O(n)</td>\\n<td style=\\"text-align:left\\">O(n)</td>\\n<td style=\\"text-align:left\\">-</td>\\n<td style=\\"text-align:left\\">Floyd算法，自底向上堆化</td>\\n</tr>\\n<tr>\\n<td style=\\"text-align:left\\">图算法</td>\\n<td style=\\"text-align:left\\"></td>\\n<td style=\\"text-align:left\\"></td>\\n<td style=\\"text-align:left\\"></td>\\n<td style=\\"text-align:left\\"></td>\\n<td style=\\"text-align:left\\"></td>\\n<td style=\\"text-align:left\\"></td>\\n</tr>\\n<tr>\\n<td style=\\"text-align:left\\"></td>\\n<td style=\\"text-align:left\\">广度优先搜索 (BFS)</td>\\n<td style=\\"text-align:left\\">O(V + E)</td>\\n<td style=\\"text-align:left\\">O(V + E)</td>\\n<td style=\\"text-align:left\\">O(V + E)</td>\\n<td style=\\"text-align:left\\">O(V)</td>\\n<td style=\\"text-align:left\\">邻接表或邻接矩阵（需转换）</td>\\n</tr>\\n<tr>\\n<td style=\\"text-align:left\\"></td>\\n<td style=\\"text-align:left\\">深度优先搜索 (DFS)</td>\\n<td style=\\"text-align:left\\">O(V + E)</td>\\n<td style=\\"text-align:left\\">O(V + E)</td>\\n<td style=\\"text-align:left\\">O(V + E)</td>\\n<td style=\\"text-align:left\\">O(V) (递归栈)</td>\\n<td style=\\"text-align:left\\">邻接表或邻接矩阵（需转换）</td>\\n</tr>\\n<tr>\\n<td style=\\"text-align:left\\"></td>\\n<td style=\\"text-align:left\\">Dijkstra (无负权)</td>\\n<td style=\\"text-align:left\\">O(V log V + E)</td>\\n<td style=\\"text-align:left\\">O(V log V + E)</td>\\n<td style=\\"text-align:left\\">O(V log V + E)</td>\\n<td style=\\"text-align:left\\">O(V)</td>\\n<td style=\\"text-align:left\\">优先队列 (堆) 优化后</td>\\n</tr>\\n<tr>\\n<td style=\\"text-align:left\\"></td>\\n<td style=\\"text-align:left\\">Bellman-Ford (可有负权)</td>\\n<td style=\\"text-align:left\\">O(V*E)</td>\\n<td style=\\"text-align:left\\">O(V*E)</td>\\n<td style=\\"text-align:left\\">O(V*E)</td>\\n<td style=\\"text-align:left\\">O(V)</td>\\n<td style=\\"text-align:left\\">检测负权环</td>\\n</tr>\\n<tr>\\n<td style=\\"text-align:left\\"></td>\\n<td style=\\"text-align:left\\">Floyd-Warshall (APSP)</td>\\n<td style=\\"text-align:left\\">O(V³)</td>\\n<td style=\\"text-align:left\\">O(V³)</td>\\n<td style=\\"text-align:left\\">O(V³)</td>\\n<td style=\\"text-align:left\\">O(V²)</td>\\n<td style=\\"text-align:left\\">所有节点对最短路径，动态规划</td>\\n</tr>\\n<tr>\\n<td style=\\"text-align:left\\"></td>\\n<td style=\\"text-align:left\\">Prim (MST - 邻接矩阵)</td>\\n<td style=\\"text-align:left\\">O(V²)</td>\\n<td style=\\"text-align:left\\">O(V²)</td>\\n<td style=\\"text-align:left\\">O(V²)</td>\\n<td style=\\"text-align:left\\">O(V)</td>\\n<td style=\\"text-align:left\\"></td>\\n</tr>\\n<tr>\\n<td style=\\"text-align:left\\"></td>\\n<td style=\\"text-align:left\\">Prim (MST - 邻接表+堆)</td>\\n<td style=\\"text-align:left\\">O(E log V)</td>\\n<td style=\\"text-align:left\\">O(E log V)</td>\\n<td style=\\"text-align:left\\">O(E log V)</td>\\n<td style=\\"text-align:left\\">O(V)</td>\\n<td style=\\"text-align:left\\">优先队列 (堆) 优化后</td>\\n</tr>\\n<tr>\\n<td style=\\"text-align:left\\"></td>\\n<td style=\\"text-align:left\\">Kruskal (MST)</td>\\n<td style=\\"text-align:left\\">O(E log E)</td>\\n<td style=\\"text-align:left\\">O(E log E)</td>\\n<td style=\\"text-align:left\\">O(E log E)</td>\\n<td style=\\"text-align:left\\">O(E+V)</td>\\n<td style=\\"text-align:left\\">并查集优化后，主要成本在排序边(E log E)</td>\\n</tr>\\n<tr>\\n<td style=\\"text-align:left\\">字符串匹配</td>\\n<td style=\\"text-align:left\\"></td>\\n<td style=\\"text-align:left\\"></td>\\n<td style=\\"text-align:left\\"></td>\\n<td style=\\"text-align:left\\"></td>\\n<td style=\\"text-align:left\\"></td>\\n<td style=\\"text-align:left\\"></td>\\n</tr>\\n<tr>\\n<td style=\\"text-align:left\\"></td>\\n<td style=\\"text-align:left\\">朴素算法 (Brute Force)</td>\\n<td style=\\"text-align:left\\">O(n) (首字符)</td>\\n<td style=\\"text-align:left\\">O((n-m+1)*m)</td>\\n<td style=\\"text-align:left\\">O(n*m)</td>\\n<td style=\\"text-align:left\\">O(1)</td>\\n<td style=\\"text-align:left\\">n=文本长， m=模式长</td>\\n</tr>\\n<tr>\\n<td style=\\"text-align:left\\"></td>\\n<td style=\\"text-align:left\\">KMP (Knuth-Morris-Pratt)</td>\\n<td style=\\"text-align:left\\">O(n + m)</td>\\n<td style=\\"text-align:left\\">O(n + m)</td>\\n<td style=\\"text-align:left\\">O(n + m)</td>\\n<td style=\\"text-align:left\\">O(m)</td>\\n<td style=\\"text-align:left\\">预处理O(m)，匹配O(n)</td>\\n</tr>\\n<tr>\\n<td style=\\"text-align:left\\"></td>\\n<td style=\\"text-align:left\\">Rabin-Karp</td>\\n<td style=\\"text-align:left\\">O(n + m)</td>\\n<td style=\\"text-align:left\\">O(n + m)</td>\\n<td style=\\"text-align:left\\">O(n*m) (坏哈希)</td>\\n<td style=\\"text-align:left\\">O(1)</td>\\n<td style=\\"text-align:left\\">基于哈希，平均好，最坏差(哈希冲突)</td>\\n</tr>\\n</tbody>\\n</table>","autoDesc":true}');export{f as comp,x as data};
