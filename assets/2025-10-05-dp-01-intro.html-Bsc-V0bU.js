import{_ as s}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as a,a as n,o as l}from"./app-CsJpo4OC.js";const h={};function e(t,i){return l(),a("div",null,i[0]||(i[0]=[n(`<h1 id="动态规划-dynamic-programming-dp-—-详细介绍" tabindex="-1"><a class="header-anchor" href="#动态规划-dynamic-programming-dp-—-详细介绍"><span>动态规划（Dynamic Programming，DP） — 详细介绍</span></a></h1><h2 id="一句话概念" tabindex="-1"><a class="header-anchor" href="#一句话概念"><span>一句话概念</span></a></h2><p>动态规划就是把一个复杂问题拆成相互重叠的子问题，把子问题的答案记下来（记忆化或表格），避免重复计算，从而高效求解。</p><p>核心是 最优子结构 + 重叠子问题。</p><hr><h2 id="两条核心性质" tabindex="-1"><a class="header-anchor" href="#两条核心性质"><span>两条核心性质</span></a></h2><ol><li>最优子结构（Optimal substructure）：问题的最优解可以由若干子问题的最优解构成。</li><li>重叠子问题（Overlapping subproblems）：子问题之间有重复，直接递归会大量重复计算。</li></ol><hr><h2 id="设计-dp-的标准-6-步-解决一题的流程" tabindex="-1"><a class="header-anchor" href="#设计-dp-的标准-6-步-解决一题的流程"><span>设计 DP 的标准 6 步（解决一题的流程）</span></a></h2><ol><li>定义状态（state）：明确 <code>dp[...]</code> 表示什么（必须能唯一表示子问题）。例如：<code>dp[i]</code> 表示前 <code>i</code> 项的最优值，或 <code>dp[i][j]</code> 表示前 <code>i</code> 个物品、容量为 <code>j</code> 时的最优值。</li><li>写出状态转移方程（transition）：如何从更小的子问题推导出当前状态。</li><li>确定初始值 / 边界（base case）：例如 <code>dp[0]=...</code>，<code>dp[i][0]=...</code>。</li><li>确定计算顺序：按依赖关系从小到大填表（自底向上）或用递归+记忆化（自顶向下）。</li><li>得到答案：从 <code>dp</code> 中读出最终答案（可能在 <code>dp[n]</code> 或 <code>max(dp[i])</code>）。</li><li>（可选）恢复解（reconstruction）：如果需要还原具体方案，额外保存“选择”信息或者从后向前回溯。</li></ol><hr><h2 id="两种实现策略对比" tabindex="-1"><a class="header-anchor" href="#两种实现策略对比"><span>两种实现策略对比</span></a></h2><ul><li><p>自顶向下（递归 + 记忆化）</p><ul><li>思路直观，按自然递归写法改加缓存即可。</li><li>便于实现复杂状态，但递归层数可能深（栈溢出风险）。</li></ul></li><li><p>自底向上（迭代表/填表）</p><ul><li>明确控制计算顺序，常更节省常数（无函数调用开销）。</li><li>更容易做空间优化（滚动数组）。</li></ul></li></ul><hr><h2 id="常见-dp-模式-题型-套路" tabindex="-1"><a class="header-anchor" href="#常见-dp-模式-题型-套路"><span>常见 DP 模式 / 题型（套路）</span></a></h2><ul><li>线性 DP（一维/二维）：如斐波那契、最短路径、最大和子序列等。</li><li>背包类（01 背包、完全背包、多重背包）：<code>dp[cap]</code> 或 <code>dp[i][cap]</code>。</li><li>最长子序列 / 子串（LIS/LCS/最长回文子串）：<code>dp[i]</code> 或 <code>dp[i][j]</code>。</li><li>区间 DP（区间长度作为状态）：如合并石子、区间博弈、矩阵链乘。</li><li>树形 DP：在树上 DFS 计算 <code>dp[node]</code>（通常子节点推父节点）。</li><li>位掩码 DP（状态是一个子集）：旅行商、集合分割，适合 n ≲ 20。</li><li>数位 DP（digit DP）：处理“满足某属性的数字个数”。</li><li>基于队列/单调队列优化的 DP：用于滑动窗口最优转移。</li><li>凸包 / 分治 / Knuth 优化：当转移满足某些单调/四边形不等式时可把复杂度从 O(n²) 降到 O(n log n) 或 O(n)。</li></ul><hr><h2 id="示例-1-斐波那契-最简单的演示" tabindex="-1"><a class="header-anchor" href="#示例-1-斐波那契-最简单的演示"><span>示例 1：斐波那契（最简单的演示）</span></a></h2><p>定义：<code>F(n)=F(n-1)+F(n-2)</code>，<code>F(0)=0,F(1)=1</code>。</p><ul><li>递归（指数级）--不可取。</li><li>递归+记忆化（O(n)）：</li></ul><div class="language-python line-numbers-mode" data-highlighter="shiki" data-ext="python" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">memo </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {}</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">def</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> fib</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#986801;--shiki-light-font-style:inherit;--shiki-dark:#D19A66;--shiki-dark-font-style:italic;">n</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">):</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    if</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> n</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">&lt;=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">: </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">return</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> n</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    if</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> n </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">in</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> memo: </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">return</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> memo[n]</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    memo[n] </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#61AFEF;"> fib</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(n</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">-</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">+</span><span style="--shiki-light:#383A42;--shiki-dark:#61AFEF;"> fib</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(n</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">-</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">2</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    return</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> memo[n]</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>迭代（自底向上，O(n) 时间、O(1) 空间）：</li></ul><div class="language-python line-numbers-mode" data-highlighter="shiki" data-ext="python" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">def</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> fib</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#986801;--shiki-light-font-style:inherit;--shiki-dark:#D19A66;--shiki-dark-font-style:italic;">n</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">):</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    if</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> n</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">&lt;=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">: </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">return</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> n</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    a,b </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 0</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">1</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    for</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> _ </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">in</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> range</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">2</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,n</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">+</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">):</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">        a,b </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> b,a</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">+</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">b</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    return</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> b</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr><h2 id="示例-2-0-1-背包-经典、也很实用" tabindex="-1"><a class="header-anchor" href="#示例-2-0-1-背包-经典、也很实用"><span>示例 2：0/1 背包（经典、也很实用）</span></a></h2><p>问题：有 <code>n</code> 个物品，每个物品重量 <code>wt[i]</code>、价值 <code>val[i]</code>，背包容量 <code>W</code>，每个物品最多选 1 次，求最大价值。</p><p>状态：<code>dp[i][w]</code> = 用前 <code>i</code> 件物品放入容量为 <code>w</code> 时的最大价值。<br> 转移：</p><ul><li>不选第 i 件：<code>dp[i][w] = dp[i-1][w]</code></li><li>选第 i 件（若 <code>w &gt;= wt[i]</code>）：<code>dp[i][w] = dp[i-1][w-wt[i]] + val[i]</code><br> 所以 <code>dp[i][w] = max(dp[i-1][w], dp[i-1][w-wt[i]] + val[i])</code>。</li></ul><p>空间优化：经典技巧是把二维 <code>dp[i][w]</code> 压成一维 <code>dp[w]</code>，并且从大到小遍历容量（避免重复选同一物品）：</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// Java: 0/1 背包 — 空间优化为 1D</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> int</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> knapsack01</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> W</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#C18401;--shiki-dark:#C678DD;"> int</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">[] wt</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#C18401;--shiki-dark:#C678DD;"> int</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">[] val) {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    int</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> n </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> wt</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">length</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#C678DD;">    int</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">[] dp </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#C18401;--shiki-dark:#C678DD;"> int</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">[W </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">+</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 1</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">]</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // dp[w] = max value for capacity w</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    for</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> (</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> i </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 0</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> i </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">&lt;</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> n</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> i</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">++</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">) {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        for</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> (</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> w </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> W</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> w </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">&gt;=</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> wt[i]</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> w</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">--</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">) { </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 从大到小</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">            dp[w] </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> Math</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">max</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(dp[w], dp[w </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">-</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> wt[i]] </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">+</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> val[i]);</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">        }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">    }</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    return</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> dp[W]</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>时间复杂度：<code>O(n * W)</code>；空间：<code>O(W)</code>。</p><hr><h2 id="示例-3-最长递增子序列-lis" tabindex="-1"><a class="header-anchor" href="#示例-3-最长递增子序列-lis"><span>示例 3：最长递增子序列（LIS）</span></a></h2><p>DP 思路（O(n²)）：令 <code>dp[i]</code> 表示以 <code>nums[i]</code> 结尾的 LIS 长度。<br> 转移：<code>dp[i] = 1 + max(dp[j])</code> 对所有 <code>j &lt; i</code> 且 <code>nums[j] &lt; nums[i]</code>。<br> 代码（Java）：</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> int</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> lengthOfLIS</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(</span><span style="--shiki-light:#C18401;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">[] nums) {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    int</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> n </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> nums</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">length</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#C678DD;">    int</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">[] dp </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#C18401;--shiki-dark:#C678DD;"> int</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">[n]</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">    Arrays</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">fill</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(dp, </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    int</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> ans </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 0</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    for</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> (</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> i </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 0</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> i </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">&lt;</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> n</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> i</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">++</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">) {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        for</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> (</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> j </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 0</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> j </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">&lt;</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> i</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> j</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">++</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">) {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">            if</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> (nums[j] </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">&lt;</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> nums[i]) dp[i] </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> Math</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">max</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(dp[i], dp[j] </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">+</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">        }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">        ans </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> Math</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">max</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(ans, dp[i]);</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">    }</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    return</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> ans</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>复杂度：<code>O(n²)</code>。若要优化到 <code>O(n log n)</code>，使用耐心排序（patience）+二分技巧（维护 tails 数组），这里就不展开实现细节了，但这是常见必会的优化。</p><hr><h2 id="状态设计技巧-常见思路" tabindex="-1"><a class="header-anchor" href="#状态设计技巧-常见思路"><span>状态设计技巧（常见思路）</span></a></h2><ul><li>用索引/前缀表示“已处理到哪里”：<code>i</code> 表示已处理前 <code>i</code> 个元素。</li><li>用“容量 / 花费 /剩余资源”作为状态维度：背包类。</li><li>用“上一个选了谁/最后一个值”作为状态：如 LIS、某些序列 DP。</li><li>把问题转为“决策序列”：每一步决策是选/不选或选哪种方式。</li><li>尝试把状态压缩（只保留前一层），以节省空间。</li><li>复杂状态先用递归写出正确关系，再逐步转成表填。</li></ul><hr><h2 id="常见优化手段-提高时间-空间" tabindex="-1"><a class="header-anchor" href="#常见优化手段-提高时间-空间"><span>常见优化手段（提高时间/空间）</span></a></h2><ul><li>滚动数组 / 1D 压缩：把 <code>dp[i][...]</code> 压缩到 <code>dp[...]</code>。</li><li>前缀和 / 差分：当转移需要区间和时用前缀和加速。</li><li>单调队列 / 滑动窗口优化：把某些线性转移降为 O(n)。</li><li>分治优化（Divide &amp; Conquer DP）：适用于转移满足“凸性”的场景。</li><li>Knuth 优化：用于区间 DP（如最优合并石子）能把 O(n³) → O(n²)（需满足单调性）。</li><li>Convex Hull Trick（CHT）：当转移是 <code>dp[i] = min_j (dp[j] + m_j * x_i + b_j)</code> 的形式，可降复杂度。</li><li>位掩码 + 状态压缩：用于小 n 的子集 DP（2^n * n）。<br> 这些优化通常需要额外的数学性质或单调性，先理解普通 DP 再考虑这些技巧。</li></ul><hr><h2 id="常见容易犯的错误-以及调试建议" tabindex="-1"><a class="header-anchor" href="#常见容易犯的错误-以及调试建议"><span>常见容易犯的错误（以及调试建议）</span></a></h2><ul><li>状态定义不清：dp 含义模糊会导致错误转移或错误的答案读取位置。</li><li>忘记处理边界（base case）：导致越界或初始值错误。</li><li>方向错误：压缩到 1D 时若遍历方向不对会重复使用同一物品。</li><li>忽略答案的位置：有时答案不在 <code>dp[n]</code> 而是在 <code>max(dp[i])</code> 或 <code>min(dp[*])</code>。</li><li>没有考虑空间/时间上界：当 <code>W</code> 很大或 <code>n</code> 很大，需要换思路（贪心、数学、近似、其他算法）。<br> 调试建议：手工写出小样例的 <code>dp</code> 表，逐行填表核对；打印中间状态；写暴力解（小 n）做对照。</li></ul><hr><h2 id="练习题-建议掌握的经典题型-难度从易到难" tabindex="-1"><a class="header-anchor" href="#练习题-建议掌握的经典题型-难度从易到难"><span>练习题（建议掌握的经典题型 / 难度从易到难）</span></a></h2><ul><li>斐波那契 / 爬楼梯（入门）</li><li>背包家族：01 背包、完全背包、分组背包</li><li>最长子序列 LIS（n² 与 n log n 两种方法）</li><li>最长公共子序列 LCS（二维 DP）</li><li>分割等和子集（subset sum / partition）</li><li>区间 DP：石子合并 / 矩阵链乘</li><li>树形 DP：树上独立集、路径相关 DP</li><li>位掩码 DP：旅行商（TSP）小规模</li><li>数位 DP：统计满足某条件的整数个数</li></ul><hr><h2 id="小结-实战流程模板" tabindex="-1"><a class="header-anchor" href="#小结-实战流程模板"><span>小结（实战流程模板）</span></a></h2><p>遇到一道新题，用下面的流程套一遍：</p><ol><li>试着用暴力递归写出状态转移（明确子问题）。</li><li>判断是否存在重叠子问题 &amp; 最优子结构（可以用 DP）。</li><li>明确 <code>dp</code> 含义、转移和 base case。</li><li>先写递归 + 记忆化验证正确性，再改成迭代表格（若需要）。</li><li>考虑时间/空间复杂度，做常见优化（滚动数组/前缀/单调队列等）。</li><li>若需要恢复解，额外记录选择信息并回溯。</li></ol>`,52)]))}const d=s(h,[["render",e]]),r=JSON.parse('{"path":"/posts/algorithm/2025-10-05-dp-01-intro.html","title":"动态规划算法入门介绍 Dynamic Programming，DP","lang":"zh-CN","frontmatter":{"title":"动态规划算法入门介绍 Dynamic Programming，DP","date":"2025-10-05T00:00:00.000Z","categories":["Althgorim"],"tags":["althgorim","dp"],"published":true,"description":"动态规划（Dynamic Programming，DP） — 详细介绍 一句话概念 动态规划就是把一个复杂问题拆成相互重叠的子问题，把子问题的答案记下来（记忆化或表格），避免重复计算，从而高效求解。 核心是 最优子结构 + 重叠子问题。 两条核心性质 最优子结构（Optimal substructure）：问题的最优解可以由若干子问题的最优解构成。 重...","head":[["meta",{"property":"og:url","content":"https://houbb.github.io/leetcode-notes/posts/algorithm/2025-10-05-dp-01-intro.html"}],["meta",{"property":"og:site_name","content":"老马啸西风"}],["meta",{"property":"og:title","content":"动态规划算法入门介绍 Dynamic Programming，DP"}],["meta",{"property":"og:description","content":"动态规划（Dynamic Programming，DP） — 详细介绍 一句话概念 动态规划就是把一个复杂问题拆成相互重叠的子问题，把子问题的答案记下来（记忆化或表格），避免重复计算，从而高效求解。 核心是 最优子结构 + 重叠子问题。 两条核心性质 最优子结构（Optimal substructure）：问题的最优解可以由若干子问题的最优解构成。 重..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-10-05T06:40:03.000Z"}],["meta",{"property":"article:tag","content":"althgorim"}],["meta",{"property":"article:tag","content":"dp"}],["meta",{"property":"article:published_time","content":"2025-10-05T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2025-10-05T06:40:03.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"动态规划算法入门介绍 Dynamic Programming，DP\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2025-10-05T00:00:00.000Z\\",\\"dateModified\\":\\"2025-10-05T06:40:03.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"老马啸西风\\",\\"url\\":\\"https://houbb.github.io\\"}]}"]]},"git":{"createdTime":1759646403000,"updatedTime":1759646403000,"contributors":[{"name":"bbhou","username":"bbhou","email":"1557740299@qq.com","commits":1,"url":"https://github.com/bbhou"}]},"readingTime":{"minutes":6.67,"words":2001},"filePathRelative":"posts/algorithm/2025-10-05-dp-01-intro.md","localizedDate":"2025年10月5日","excerpt":"\\n<h2>一句话概念</h2>\\n<p>动态规划就是把一个复杂问题拆成相互重叠的子问题，把子问题的答案记下来（记忆化或表格），避免重复计算，从而高效求解。</p>\\n<p>核心是 最优子结构 + 重叠子问题。</p>\\n<hr>\\n<h2>两条核心性质</h2>\\n<ol>\\n<li>最优子结构（Optimal substructure）：问题的最优解可以由若干子问题的最优解构成。</li>\\n<li>重叠子问题（Overlapping subproblems）：子问题之间有重复，直接递归会大量重复计算。</li>\\n</ol>\\n<hr>\\n<h2>设计 DP 的标准 6 步（解决一题的流程）</h2>\\n<ol>\\n<li>定义状态（state）：明确 <code>dp[...]</code> 表示什么（必须能唯一表示子问题）。例如：<code>dp[i]</code> 表示前 <code>i</code> 项的最优值，或 <code>dp[i][j]</code> 表示前 <code>i</code> 个物品、容量为 <code>j</code> 时的最优值。</li>\\n<li>写出状态转移方程（transition）：如何从更小的子问题推导出当前状态。</li>\\n<li>确定初始值 / 边界（base case）：例如 <code>dp[0]=...</code>，<code>dp[i][0]=...</code>。</li>\\n<li>确定计算顺序：按依赖关系从小到大填表（自底向上）或用递归+记忆化（自顶向下）。</li>\\n<li>得到答案：从 <code>dp</code> 中读出最终答案（可能在 <code>dp[n]</code> 或 <code>max(dp[i])</code>）。</li>\\n<li>（可选）恢复解（reconstruction）：如果需要还原具体方案，额外保存“选择”信息或者从后向前回溯。</li>\\n</ol>","autoDesc":true}');export{d as comp,r as data};
