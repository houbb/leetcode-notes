import{_ as i}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as a,a as t,o as h}from"./app-CQ3qWz9M.js";const e={};function l(n,s){return h(),a("div",null,s[0]||(s[0]=[t(`<h1 id="拓展阅读" tabindex="-1"><a class="header-anchor" href="#拓展阅读"><span>拓展阅读</span></a></h1><p><a href="https://houbb.github.io/2018/08/13/consistent-hash" target="_blank" rel="noopener noreferrer">一致性 hash 算法</a></p><p><a href="https://houbb.github.io/2018/05/30/hash-impl" target="_blank" rel="noopener noreferrer">java hash 实现</a></p><p><a href="https://houbb.github.io/2018/05/30/hash-conflict" target="_blank" rel="noopener noreferrer">hash 冲突处理</a></p><p><a href="https://houbb.github.io/2018/12/05/bloom-filter" target="_blank" rel="noopener noreferrer">bloom filter</a></p><p><a href="https://houbb.github.io/2019/04/01/BloomFilter-best-practice" target="_blank" rel="noopener noreferrer">bloom filter 使用最佳实践，让你少采坑！</a></p><h1 id="chat" tabindex="-1"><a class="header-anchor" href="#chat"><span>chat</span></a></h1><h1 id="详细介绍一下哈希" tabindex="-1"><a class="header-anchor" href="#详细介绍一下哈希"><span>详细介绍一下哈希</span></a></h1><p>哈希（Hash），又叫<strong>散列</strong>，是计算机中一种<strong>将任意长度的数据映射为固定长度的数据</strong>的技术，广泛应用于查找、去重、加密、负载均衡等场景。</p><hr><h2 id="🧠-核心概念" tabindex="-1"><a class="header-anchor" href="#🧠-核心概念"><span>🧠 核心概念</span></a></h2><h3 id="_1-哈希函数-hash-function" tabindex="-1"><a class="header-anchor" href="#_1-哈希函数-hash-function"><span>1. <strong>哈希函数（Hash Function）</strong></span></a></h3><ul><li>将任意长度的输入“压缩”成固定长度的输出。</li><li>相同输入，输出必定相同；不同输入，尽量输出不同。</li><li>输出结果一般称为<strong>哈希值（Hash Value）<strong>或</strong>哈希码（Hash Code）</strong>。</li></ul><p>比如：</p><div class="language-text line-numbers-mode" data-highlighter="shiki" data-ext="text" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>输入: &quot;apple&quot;   →  哈希值:  97af...</span></span>
<span class="line"><span>输入: &quot;banana&quot;  →  哈希值:  b1c4...</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><hr><h2 id="🧮-哈希的主要用途" tabindex="-1"><a class="header-anchor" href="#🧮-哈希的主要用途"><span>🧮 哈希的主要用途</span></a></h2><h3 id="_1-哈希表-hash-table" tabindex="-1"><a class="header-anchor" href="#_1-哈希表-hash-table"><span>1. <strong>哈希表（Hash Table）</strong></span></a></h3><p>最典型的应用，键值对形式存储数据，具有<strong>接近 O(1) 的查找效率</strong>。</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">Map</span><span style="--shiki-light:#E45649;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">String</span><span style="--shiki-light:#E45649;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> Integer</span><span style="--shiki-light:#E45649;--shiki-dark:#ABB2BF;">&gt;</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> map </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> HashMap</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&lt;&gt;</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">()</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">map</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">put</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;apple&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">5</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">System</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">out</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">println</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">map</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">get</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;apple&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">));</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // 输出 5</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><p>背后原理：</p><ul><li>key 通过哈希函数映射到数组中的一个索引位置。</li><li>如果多个 key 映射到了同一位置（<strong>哈希冲突</strong>），就通过链表、红黑树等方式解决。</li></ul></li></ul><h3 id="_2-哈希去重" tabindex="-1"><a class="header-anchor" href="#_2-哈希去重"><span>2. <strong>哈希去重</strong></span></a></h3><ul><li>将元素的哈希值存入集合中判断是否重复。</li></ul><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">Set</span><span style="--shiki-light:#E45649;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">String</span><span style="--shiki-light:#E45649;--shiki-dark:#ABB2BF;">&gt;</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> set </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> HashSet</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&lt;&gt;</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">()</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h3 id="_3-密码加密-如-md5-sha-256" tabindex="-1"><a class="header-anchor" href="#_3-密码加密-如-md5-sha-256"><span>3. <strong>密码加密（如 MD5, SHA-256）</strong></span></a></h3><ul><li><p>将原始密码经过哈希函数后存储，防止明文泄露。</p></li><li><p>特点：</p><ul><li>不可逆（从哈希值推不出原始值）</li><li>雪崩效应：输入变化一点点，输出变化很大。</li></ul></li></ul><h3 id="_4-数据校验-如文件传输" tabindex="-1"><a class="header-anchor" href="#_4-数据校验-如文件传输"><span>4. <strong>数据校验（如文件传输）</strong></span></a></h3><ul><li>比如用 MD5 校验码检查文件是否被篡改。</li></ul><h3 id="_5-负载均衡-分布式系统" tabindex="-1"><a class="header-anchor" href="#_5-负载均衡-分布式系统"><span>5. <strong>负载均衡 / 分布式系统</strong></span></a></h3><ul><li>一致性哈希：把 key 均匀地映射到多个节点上。</li></ul><hr><h2 id="⚠️-哈希冲突" tabindex="-1"><a class="header-anchor" href="#⚠️-哈希冲突"><span>⚠️ 哈希冲突</span></a></h2><p>不同的输入得到相同的哈希值，叫<strong>哈希冲突（Collision）</strong>。</p><p>解决方法主要有两种：</p><h3 id="_1-开放地址法" tabindex="-1"><a class="header-anchor" href="#_1-开放地址法"><span>1. 开放地址法</span></a></h3><ul><li>冲突后，向后查找空位插入。</li></ul><h3 id="_2-链地址法-java-hashmap-用的" tabindex="-1"><a class="header-anchor" href="#_2-链地址法-java-hashmap-用的"><span>2. 链地址法（Java HashMap 用的）</span></a></h3><ul><li>冲突的元素用链表或红黑树连接在一起。</li></ul><hr><h2 id="🧪-哈希函数的好坏标准" tabindex="-1"><a class="header-anchor" href="#🧪-哈希函数的好坏标准"><span>🧪 哈希函数的好坏标准</span></a></h2><p>一个“好的”哈希函数应该具备：</p><ul><li><strong>计算快</strong>（不能拖后腿）</li><li><strong>分布均匀</strong>（避免集中在少数桶里）</li><li><strong>抗碰撞性强</strong>（避免冲突太多）</li><li><strong>确定性</strong>（输入一样输出一定一样）</li></ul><hr><h2 id="🧰-常见哈希函数" tabindex="-1"><a class="header-anchor" href="#🧰-常见哈希函数"><span>🧰 常见哈希函数</span></a></h2><table><thead><tr><th>名称</th><th>应用场景</th></tr></thead><tbody><tr><td><code>Object.hashCode()</code></td><td>Java 的哈希表</td></tr><tr><td><code>MD5</code></td><td>密码、文件校验</td></tr><tr><td><code>SHA-256</code></td><td>密码、更安全的加密</td></tr><tr><td><code>CRC32</code></td><td>文件完整性检查</td></tr><tr><td><code>MurmurHash</code></td><td>大数据、分布式高性能哈希</td></tr></tbody></table><hr><h2 id="🔍-例子-哈希表查找效率" tabindex="-1"><a class="header-anchor" href="#🔍-例子-哈希表查找效率"><span>🔍 例子：哈希表查找效率</span></a></h2><p>假设你用一个数组存储 100 万个数字，查找一个值平均是 O(logN) 或 O(N)。</p><p>但如果用哈希表（数组 + 哈希函数）：</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">Map</span><span style="--shiki-light:#E45649;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">Integer</span><span style="--shiki-light:#E45649;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> String</span><span style="--shiki-light:#E45649;--shiki-dark:#ABB2BF;">&gt;</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> map </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> HashMap</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&lt;&gt;</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">()</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">map</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">put</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">1000000</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;value&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">System</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">out</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">println</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">map</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">get</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">1000000</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">));</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // O(1) 查找</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>几乎是<strong>常数时间</strong>，这是哈希表强大的原因。</p><hr><h2 id="总结-🧾" tabindex="-1"><a class="header-anchor" href="#总结-🧾"><span>总结 🧾</span></a></h2><table><thead><tr><th>项目</th><th>说明</th></tr></thead><tbody><tr><td>哈希是什么</td><td>把数据映射为固定长度的值</td></tr><tr><td>主要作用</td><td>查找、去重、加密、校验、分布式</td></tr><tr><td>关键结构</td><td>哈希函数 + 哈希表（数组 + 链）</td></tr><tr><td>核心优势</td><td>高效查找、快速匹配</td></tr><tr><td>风险点</td><td>冲突处理，哈希函数选择</td></tr></tbody></table><h1 id="哈希的应用场景可以在拓展一些吗-比如-bloom-filter-之类的" tabindex="-1"><a class="header-anchor" href="#哈希的应用场景可以在拓展一些吗-比如-bloom-filter-之类的"><span>哈希的应用场景可以在拓展一些吗？比如 bloom-filter 之类的</span></a></h1><p>当然可以！哈希的应用场景其实非常广泛，除了常规的哈希表、去重、加密等之外，还有很多“隐藏高手”也离不开哈希，比如 <strong>布隆过滤器、LRU缓存、一致性哈希、区块链、图像/音频指纹识别</strong> 等等。</p><hr><h2 id="✅-哈希的更多应用场景拓展" tabindex="-1"><a class="header-anchor" href="#✅-哈希的更多应用场景拓展"><span>✅ 哈希的更多应用场景拓展</span></a></h2><h3 id="_1-布隆过滤器-bloom-filter" tabindex="-1"><a class="header-anchor" href="#_1-布隆过滤器-bloom-filter"><span>1. <strong>布隆过滤器（Bloom Filter）</strong></span></a></h3><blockquote><p>是一种<strong>用空间换时间</strong>的概率型数据结构，核心依赖哈希。</p></blockquote><ul><li><p>用途：<strong>判断某个元素是否存在于集合中</strong>。</p></li><li><p>特点：</p><ul><li><strong>占用内存极小</strong></li><li>有<strong>误判率（可能会说有，其实没有）</strong>，但<strong>绝不会漏判</strong>。</li></ul></li><li><p>应用：</p><ul><li><strong>爬虫系统</strong>去重 URL</li><li><strong>缓存穿透防护</strong>（比如 Redis + Bloom Filter）</li><li>大规模黑名单检测</li></ul></li></ul><p><strong>原理简述：</strong></p><ul><li>把元素通过多个哈希函数映射到一个位数组的多个位置。</li><li>查询时检查对应位置是否全为 1，如果是就认为可能存在。</li></ul><hr><h3 id="_2-一致性哈希-consistent-hashing" tabindex="-1"><a class="header-anchor" href="#_2-一致性哈希-consistent-hashing"><span>2. <strong>一致性哈希（Consistent Hashing）</strong></span></a></h3><blockquote><p>分布式系统中的负载均衡利器。</p></blockquote><ul><li><p>用途：将请求分布到多个服务器节点，避免因新增/删除节点导致大规模重映射。</p></li><li><p>应用：</p><ul><li><strong>分布式缓存（如 Redis Cluster）</strong></li><li><strong>CDN、数据库分片</strong></li></ul></li><li><p>原理：</p><ul><li>将节点和 key 都哈希到一个环上，顺时针找到最近的节点处理该 key。</li></ul></li></ul><hr><h3 id="_3-lru-cache-最近最少使用缓存" tabindex="-1"><a class="header-anchor" href="#_3-lru-cache-最近最少使用缓存"><span>3. <strong>LRU Cache（最近最少使用缓存）</strong></span></a></h3><blockquote><p>常见于操作系统、数据库、浏览器等缓存策略。</p></blockquote><ul><li><p>LRU 的核心结构通常是：</p><ul><li>哈希表（用于 O(1) 查找）</li><li>双向链表（用于维护使用顺序）</li></ul></li></ul><p>哈希表用于高效定位缓存项，链表用于记录访问顺序。</p><hr><h3 id="_4-区块链-blockchain" tabindex="-1"><a class="header-anchor" href="#_4-区块链-blockchain"><span>4. <strong>区块链（BlockChain）</strong></span></a></h3><blockquote><p>哈希几乎是区块链的“骨架”。</p></blockquote><ul><li>每个区块都包含前一个区块的哈希值（称为“区块头”）</li><li>一旦区块中的数据被篡改，其哈希值就会改变，链条就断裂，从而保证<strong>数据不可篡改性</strong></li><li>使用大量哈希函数如 SHA-256、Merkle Tree 等</li></ul><hr><h3 id="_5-merkle-tree-默克尔树" tabindex="-1"><a class="header-anchor" href="#_5-merkle-tree-默克尔树"><span>5. <strong>Merkle Tree（默克尔树）</strong></span></a></h3><blockquote><p>一种基于哈希构造的树结构，常用于数据校验和对比。</p></blockquote><ul><li><p>应用：</p><ul><li>区块链（如比特币、以太坊）</li><li>分布式系统中的<strong>数据一致性校验</strong></li></ul></li><li><p>每个叶子节点是数据的哈希值，上层节点是下层两个节点哈希拼接后的哈希。</p></li></ul><hr><h3 id="_6-图像-音频指纹识别" tabindex="-1"><a class="header-anchor" href="#_6-图像-音频指纹识别"><span>6. <strong>图像/音频指纹识别</strong></span></a></h3><blockquote><p>哈希用于生成“特征指纹”。</p></blockquote><ul><li><p>如 Perceptual Hash（感知哈希）：将图片压缩为低分辨率图像后计算哈希值，能识别“相似图像”。</p></li><li><p>应用：</p><ul><li>图像去重、版权保护</li><li>音频识别（如 Shazam）</li></ul></li></ul><hr><h3 id="_7-哈希索引-数据库" tabindex="-1"><a class="header-anchor" href="#_7-哈希索引-数据库"><span>7. <strong>哈希索引（数据库）</strong></span></a></h3><blockquote><p>一种基于哈希表实现的数据库索引机制。</p></blockquote><ul><li>应用：MySQL Memory 引擎默认使用哈希索引</li><li>特点：查找非常快，但不适合范围查询（因为哈希是无序的）</li></ul><hr><h3 id="_8-负载均衡-load-balancing" tabindex="-1"><a class="header-anchor" href="#_8-负载均衡-load-balancing"><span>8. <strong>负载均衡（Load Balancing）</strong></span></a></h3><blockquote><p>哈希算法用于决定用户请求发送到哪个服务器。</p></blockquote><ul><li><p>常见方案：</p><ul><li><code>userId % 服务器数</code></li><li><code>hash(IP)</code> -&gt; 映射到服务器池</li></ul></li><li><p>避免某个服务器被频繁切换，提高粘性和效率。</p></li></ul><hr><h3 id="_9-分布式系统中的幂等处理" tabindex="-1"><a class="header-anchor" href="#_9-分布式系统中的幂等处理"><span>9. <strong>分布式系统中的幂等处理</strong></span></a></h3><blockquote><p>防止消息重复处理，常用哈希存储“处理过的标识”。</p></blockquote><ul><li><p>应用：</p><ul><li>消息队列（如 Kafka）</li><li>API 接口幂等性判断</li></ul></li></ul><hr><h3 id="_10-验证码识别-防刷机制" tabindex="-1"><a class="header-anchor" href="#_10-验证码识别-防刷机制"><span>10. <strong>验证码识别/防刷机制</strong></span></a></h3><blockquote><p>通过哈希生成验证码标识、或者限制同一 IP 重复访问行为。</p></blockquote><hr><h2 id="📌-总结-哈希的高级应用场景地图" tabindex="-1"><a class="header-anchor" href="#📌-总结-哈希的高级应用场景地图"><span>📌 总结：哈希的高级应用场景地图</span></a></h2><table><thead><tr><th>应用领域</th><th>场景/技术</th><th>用途说明</th></tr></thead><tbody><tr><td>数据结构</td><td>哈希表、布隆过滤器</td><td>高效查找、去重</td></tr><tr><td>分布式系统</td><td>一致性哈希、哈希分片</td><td>节点路由、负载均衡</td></tr><tr><td>缓存机制</td><td>LRU 缓存、布隆过滤器+Redis</td><td>查询加速、减少 DB 压力</td></tr><tr><td>安全领域</td><td>加密哈希（SHA, MD5）</td><td>密码存储、签名、防篡改</td></tr><tr><td>区块链</td><td>区块哈希、Merkle Tree</td><td>数据完整性、追溯、抗篡改</td></tr><tr><td>多媒体处理</td><td>图像哈希、音频指纹</td><td>版权识别、去重</td></tr><tr><td>数据库系统</td><td>哈希索引、分布式幂等判断</td><td>加速查询、避免重复写入</td></tr><tr><td>网络安全</td><td>DoS 攻击防御、验证码限制</td><td>限流、行为识别</td></tr></tbody></table>`,102)]))}const d=i(e,[["render",l]]),o=JSON.parse('{"path":"/posts/algorithm/hash/2018-05-30-hash-10-chat-intro.html","title":"Hash-10-聊一聊哈希","lang":"zh-CN","frontmatter":{"title":"Hash-10-聊一聊哈希","date":"2018-05-30T00:00:00.000Z","categories":["Algorithm"],"tags":["algorithm","hash","hashing"],"published":true,"description":"拓展阅读 一致性 hash 算法 java hash 实现 hash 冲突处理 bloom filter bloom filter 使用最佳实践，让你少采坑！ chat 详细介绍一下哈希 哈希（Hash），又叫散列，是计算机中一种将任意长度的数据映射为固定长度的数据的技术，广泛应用于查找、去重、加密、负载均衡等场景。 🧠 核心概念 1. 哈希函数（H...","head":[["meta",{"property":"og:url","content":"https://houbb.github.io/leetcode-notes/posts/algorithm/hash/2018-05-30-hash-10-chat-intro.html"}],["meta",{"property":"og:site_name","content":"老马啸西风"}],["meta",{"property":"og:title","content":"Hash-10-聊一聊哈希"}],["meta",{"property":"og:description","content":"拓展阅读 一致性 hash 算法 java hash 实现 hash 冲突处理 bloom filter bloom filter 使用最佳实践，让你少采坑！ chat 详细介绍一下哈希 哈希（Hash），又叫散列，是计算机中一种将任意长度的数据映射为固定长度的数据的技术，广泛应用于查找、去重、加密、负载均衡等场景。 🧠 核心概念 1. 哈希函数（H..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-08-23T04:59:26.000Z"}],["meta",{"property":"article:tag","content":"algorithm"}],["meta",{"property":"article:tag","content":"hash"}],["meta",{"property":"article:tag","content":"hashing"}],["meta",{"property":"article:published_time","content":"2018-05-30T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2025-08-23T04:59:26.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Hash-10-聊一聊哈希\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2018-05-30T00:00:00.000Z\\",\\"dateModified\\":\\"2025-08-23T04:59:26.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"老马啸西风\\",\\"url\\":\\"https://houbb.github.io\\"}]}"]]},"git":{"createdTime":1755925166000,"updatedTime":1755925166000,"contributors":[{"name":"bbhou","username":"bbhou","email":"1557740299@qq.com","commits":1,"url":"https://github.com/bbhou"}]},"readingTime":{"minutes":6.38,"words":1913},"filePathRelative":"posts/algorithm/hash/2018-05-30-hash-10-chat-intro.md","localizedDate":"2018年5月30日","excerpt":"\\n<p><a href=\\"https://houbb.github.io/2018/08/13/consistent-hash\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">一致性 hash 算法</a></p>\\n<p><a href=\\"https://houbb.github.io/2018/05/30/hash-impl\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">java hash 实现</a></p>\\n<p><a href=\\"https://houbb.github.io/2018/05/30/hash-conflict\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">hash 冲突处理</a></p>","autoDesc":true}');export{d as comp,o as data};
