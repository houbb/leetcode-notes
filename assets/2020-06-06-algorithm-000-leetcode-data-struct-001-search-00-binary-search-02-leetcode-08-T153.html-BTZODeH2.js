import{_ as i}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as a,a as n,o as t}from"./app-DloVM1yj.js";const e={};function h(l,s){return t(),a("div",null,s[0]||(s[0]=[n(`<h1 id="二分查找算法" tabindex="-1"><a class="header-anchor" href="#二分查找算法"><span>二分查找算法</span></a></h1><p>大家好，我是老马。</p><p>今天我们一起来学习一下数组密切相关的二分查找算法力扣实战。</p><p>我们来看一下二分法当数组不再严格递增，但仍保有一定规律，可以通过<strong>二分定位区间</strong></p><h1 id="_153-寻找旋转排序数组中的最小值" tabindex="-1"><a class="header-anchor" href="#_153-寻找旋转排序数组中的最小值"><span>153. 寻找旋转排序数组中的最小值</span></a></h1><p>已知一个长度为 n 的数组，预先按照升序排列，经由 1 到 n 次 旋转 后，得到输入数组。</p><p>例如，原数组 nums = [0,1,2,4,5,6,7] 在变化后可能得到：<br> 若旋转 4 次，则可以得到 [4,5,6,7,0,1,2]<br> 若旋转 7 次，则可以得到 [0,1,2,4,5,6,7]<br> 注意，数组 [a[0], a[1], a[2], ..., a[n-1]] 旋转一次 的结果为数组 [a[n-1], a[0], a[1], a[2], ..., a[n-2]] 。</p><p>给你一个元素值 互不相同 的数组 nums ，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。</p><p>请你找出并返回数组中的 最小元素 。</p><p>你必须设计一个时间复杂度为 O(log n) 的算法解决此问题。</p><p>示例 1：</p><p>输入：nums = [3,4,5,1,2]<br> 输出：1<br> 解释：原数组为 [1,2,3,4,5] ，旋转 3 次得到输入数组。<br> 示例 2：</p><p>输入：nums = [4,5,6,7,0,1,2]<br> 输出：0<br> 解释：原数组为 [0,1,2,4,5,6,7] ，旋转 4 次得到输入数组。<br> 示例 3：</p><p>输入：nums = [11,13,15,17]<br> 输出：11<br> 解释：原数组为 [11,13,15,17] ，旋转 4 次得到输入数组。</p><p>提示：</p><p>n == nums.length<br> 1 &lt;= n &lt;= 5000<br> -5000 &lt;= nums[i] &lt;= 5000<br> nums 中的所有整数 互不相同<br> nums 原来是一个升序排序的数组，并进行了 1 至 n 次旋转</p><h1 id="v1-暴力循环" tabindex="-1"><a class="header-anchor" href="#v1-暴力循环"><span>v1-暴力循环</span></a></h1><h2 id="思路" tabindex="-1"><a class="header-anchor" href="#思路"><span>思路</span></a></h2><p>最朴素的暴力循环的方式</p><p>我们首先想办法，确定上下限。</p><p>直接从开始到结束来一遍</p><h2 id="解法" tabindex="-1"><a class="header-anchor" href="#解法"><span>解法</span></a></h2><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> int</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> findMin</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(</span><span style="--shiki-light:#C18401;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">[] nums) {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        int</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> min </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> Integer</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">MAX_VALUE</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        for</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> num </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">:</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> nums) {</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">            min </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> Math</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">min</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(num, min);</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">        }</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        return</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> min</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">    }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="效果" tabindex="-1"><a class="header-anchor" href="#效果"><span>效果</span></a></h2><p>0ms 击败 100.00%</p><p>这一题的测试用例有问题，没有区分度。</p><h1 id="v2-二分法迭代" tabindex="-1"><a class="header-anchor" href="#v2-二分法迭代"><span>v2-二分法迭代</span></a></h1><h2 id="和-t033-对比" tabindex="-1"><a class="header-anchor" href="#和-t033-对比"><span>和 T033 对比</span></a></h2><h3 id="🔍-题目目标对比" tabindex="-1"><a class="header-anchor" href="#🔍-题目目标对比"><span>🔍 题目目标对比</span></a></h3><table><thead><tr><th>题号</th><th>名称</th><th>要做什么？</th><th>是否包含重复元素？</th></tr></thead><tbody><tr><td>T033</td><td>搜索旋转排序数组</td><td>在<strong>旋转排序数组中搜索一个指定值</strong>（返回下标）</td><td>❌ 不含重复</td></tr><tr><td>T153</td><td>寻找最小值</td><td>找出这个<strong>旋转数组中的最小值</strong></td><td>❌ 不含重复（但有 T154 含重复）</td></tr></tbody></table><h3 id="🎯-它们的本质区别" tabindex="-1"><a class="header-anchor" href="#🎯-它们的本质区别"><span>🎯 它们的本质区别</span></a></h3><table><thead><tr><th>项</th><th>T033（搜索目标值）</th><th>T153（找最小值）</th></tr></thead><tbody><tr><td>📌 <strong>核心问题</strong></td><td>target 在哪里？</td><td>最小值在哪里？</td></tr><tr><td>🔄 <strong>判断逻辑</strong></td><td>哪一边是<strong>有序的</strong>，target 落在哪边？</td><td>哪一边是<strong>无序的</strong>，最小值在无序那边</td></tr><tr><td>🎯 <strong>目标值</strong></td><td>可能在左边或右边</td><td>肯定在<strong>最小的那一段</strong></td></tr><tr><td>🔁 <strong>偏移后影响</strong></td><td>会影响 target 的位置判断</td><td>只关注最小值在哪里</td></tr></tbody></table><h3 id="🧠-更形象地理解" tabindex="-1"><a class="header-anchor" href="#🧠-更形象地理解"><span>🧠 更形象地理解</span></a></h3><p>T033 是“<strong>找值</strong>”</p><p>我们拿个例子：</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">nums </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> [</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">4</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">5</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">6</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">7</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">0</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">2</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">]</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> target </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 6</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>它本质上是在问：</p><blockquote><p>“在这个被旋转的数组里，目标值在哪里？”</p></blockquote><p>你需要识别数组中哪一半是升序，然后看 target 应该在哪边，就继续二分。</p><p>👉 逻辑是：</p><ul><li><strong>哪一半是有序的？</strong></li><li>target 是否落在有序段中？落在就往那边搜</li></ul><p>T153 是“<strong>找最小值</strong>”</p><p>这个题并不关心 target，只关心：</p><blockquote><p>“哪一边是乱的？乱的那边才会有最小值。”</p></blockquote><p>同样的数组：</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">nums </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> [</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">4</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">5</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">6</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">7</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">0</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">2</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">]</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>我们需要找 <code>0</code>。</p><p>👉 逻辑是：</p><ul><li><p>比较 <code>nums[mid]</code> 和 <code>nums[right]</code></p><ul><li>如果 <code>nums[mid] &gt; nums[right]</code>：最小值在右边（mid 一定不是最小）</li><li>否则：最小值在左边或就是 mid</li></ul></li></ul><h2 id="思路-1" tabindex="-1"><a class="header-anchor" href="#思路-1"><span>思路</span></a></h2><p>我还是比较倾向于实用经典二分的模板</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">while</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> (left </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">&lt;=</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> right) {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    int</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> mid </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> ...</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    if</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> (</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">...</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">) {</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">        ...</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">    } </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">else</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> {</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">        ...</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">    }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>不然各种边界条件，完全记不住。</p><h2 id="实现" tabindex="-1"><a class="header-anchor" href="#实现"><span>实现</span></a></h2><p>我认为下面的解法，才是真方便结合模板记忆的方法。</p><p>二分法的精髓在于我们必须找到一种数据的特征，来过滤掉一半的数据。</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> int</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> findMin</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(</span><span style="--shiki-light:#C18401;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">[] nums) {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        int</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> left </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 0</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        int</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> right </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> nums</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">length</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">-</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">        // 记录最小值</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        int</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> min </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> nums[</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">0</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">]</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        while</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> (left </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">&lt;=</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> right) {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">            int</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> mid </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> left </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">+</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> (right</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">-</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">left) </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">/</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 2</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">            // 整体有序</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">            if</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(nums[left] </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">&lt;=</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> nums[right]) {</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">                min </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> Math</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">min</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(min, nums[left]);</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">                return</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> min</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">            }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">            // 更新最小值</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">            min </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> Math</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">min</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(min, nums[mid]);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">            // 左边有序，最小值在右边</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">            if</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(nums[left] </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">&lt;=</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> nums[mid]) {</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">                left </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> mid </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">+</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">            } </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">else</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> {</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">                // 右边有序，最小值在左边</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">                right</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> mid</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">-</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">            }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">        }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        return</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> min</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">    }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="效果-1" tabindex="-1"><a class="header-anchor" href="#效果-1"><span>效果</span></a></h2><p>0ms 击败 100.00%</p><h1 id="补充-可视化效果" tabindex="-1"><a class="header-anchor" href="#补充-可视化效果"><span>补充-可视化效果</span></a></h1><blockquote><p><a href="https://houbb.github.io/leetcode-notes/leetcode/visible/T153-binary-search-find-minimum-in-rotated-sorted-array.html" target="_blank" rel="noopener noreferrer">可视化效果</a></p></blockquote><h1 id="项目开源" tabindex="-1"><a class="header-anchor" href="#项目开源"><span>项目开源</span></a></h1><blockquote><p><a href="https://houbb.github.io/" target="_blank" rel="noopener noreferrer">技术博客</a></p></blockquote><blockquote><p><a href="https://houbb.github.io/leetcode-notes/leetcode/visible/index.html" target="_blank" rel="noopener noreferrer">leetcode-visual 资源可视化</a></p></blockquote><blockquote><p><a href="https://github.com/houbb/leetcode" target="_blank" rel="noopener noreferrer">leetcode 算法实现</a></p></blockquote><h1 id="小结" tabindex="-1"><a class="header-anchor" href="#小结"><span>小结</span></a></h1><p>希望本文对你有帮助，如果有其他想法的话，也可以评论区和大家分享哦。</p><p>各位极客的点赞收藏转发，是老马持续写作的最大动力！</p><p>下一节我们将讲解二分的实战题目，感兴趣的小伙伴可以关注一波，精彩内容，不容错过。</p><h1 id="参考资料" tabindex="-1"><a class="header-anchor" href="#参考资料"><span>参考资料</span></a></h1><p><a href="https://leetcode.cn/problems/binary-search/description/" target="_blank" rel="noopener noreferrer">https://leetcode.cn/problems/binary-search/description/</a></p>`,71)]))}const r=i(e,[["render",h]]),d=JSON.parse('{"path":"/posts/leetcode/topliked-100/search/2020-06-06-algorithm-000-leetcode-data-struct-001-search-00-binary-search-02-leetcode-08-T153.html","title":"二分查找法？binary-search-02-leetcode 153. 寻找旋转排序数组中的最小值","lang":"zh-CN","frontmatter":{"title":"二分查找法？binary-search-02-leetcode 153. 寻找旋转排序数组中的最小值","date":"2020-06-08T00:00:00.000Z","categories":["TopLiked100"],"tags":["algorithm","data-struct","topics","leetcode","binary-search","sf"],"published":true,"description":"二分查找算法 大家好，我是老马。 今天我们一起来学习一下数组密切相关的二分查找算法力扣实战。 我们来看一下二分法当数组不再严格递增，但仍保有一定规律，可以通过二分定位区间 153. 寻找旋转排序数组中的最小值 已知一个长度为 n 的数组，预先按照升序排列，经由 1 到 n 次 旋转 后，得到输入数组。 例如，原数组 nums = [0,1,2,4,5,...","head":[["meta",{"property":"og:url","content":"https://houbb.github.io/leetcode-notes/posts/leetcode/topliked-100/search/2020-06-06-algorithm-000-leetcode-data-struct-001-search-00-binary-search-02-leetcode-08-T153.html"}],["meta",{"property":"og:site_name","content":"老马啸西风"}],["meta",{"property":"og:title","content":"二分查找法？binary-search-02-leetcode 153. 寻找旋转排序数组中的最小值"}],["meta",{"property":"og:description","content":"二分查找算法 大家好，我是老马。 今天我们一起来学习一下数组密切相关的二分查找算法力扣实战。 我们来看一下二分法当数组不再严格递增，但仍保有一定规律，可以通过二分定位区间 153. 寻找旋转排序数组中的最小值 已知一个长度为 n 的数组，预先按照升序排列，经由 1 到 n 次 旋转 后，得到输入数组。 例如，原数组 nums = [0,1,2,4,5,..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-09-24T02:52:43.000Z"}],["meta",{"property":"article:tag","content":"algorithm"}],["meta",{"property":"article:tag","content":"data-struct"}],["meta",{"property":"article:tag","content":"topics"}],["meta",{"property":"article:tag","content":"leetcode"}],["meta",{"property":"article:tag","content":"binary-search"}],["meta",{"property":"article:tag","content":"sf"}],["meta",{"property":"article:published_time","content":"2020-06-08T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2025-09-24T02:52:43.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"二分查找法？binary-search-02-leetcode 153. 寻找旋转排序数组中的最小值\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2020-06-08T00:00:00.000Z\\",\\"dateModified\\":\\"2025-09-24T02:52:43.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"老马啸西风\\",\\"url\\":\\"https://houbb.github.io\\"}]}"]]},"git":{"createdTime":1755499309000,"updatedTime":1758682363000,"contributors":[{"name":"binbin.hou","username":"","email":"binbin.hou@huifu.com","commits":4},{"name":"bbhou","username":"bbhou","email":"1557740299@qq.com","commits":3,"url":"https://github.com/bbhou"}]},"readingTime":{"minutes":4.4,"words":1321},"filePathRelative":"posts/leetcode/topliked-100/search/2020-06-06-algorithm-000-leetcode-data-struct-001-search-00-binary-search-02-leetcode-08-T153.md","localizedDate":"2020年6月8日","excerpt":"\\n<p>大家好，我是老马。</p>\\n<p>今天我们一起来学习一下数组密切相关的二分查找算法力扣实战。</p>\\n<p>我们来看一下二分法当数组不再严格递增，但仍保有一定规律，可以通过<strong>二分定位区间</strong></p>\\n<h1>153. 寻找旋转排序数组中的最小值</h1>\\n<p>已知一个长度为 n 的数组，预先按照升序排列，经由 1 到 n 次 旋转 后，得到输入数组。</p>\\n<p>例如，原数组 nums = [0,1,2,4,5,6,7] 在变化后可能得到：<br>\\n若旋转 4 次，则可以得到 [4,5,6,7,0,1,2]<br>\\n若旋转 7 次，则可以得到 [0,1,2,4,5,6,7]<br>\\n注意，数组 [a[0], a[1], a[2], ..., a[n-1]] 旋转一次 的结果为数组 [a[n-1], a[0], a[1], a[2], ..., a[n-2]] 。</p>","autoDesc":true}');export{r as comp,d as data};
