import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as t,a as r,o as h}from"./app-Cbb6KCGF.js";const s={};function o(n,a){return h(),t("div",null,a[0]||(a[0]=[r('<h1 id="拓展阅读" tabindex="-1"><a class="header-anchor" href="#拓展阅读"><span>拓展阅读</span></a></h1><p><a href="https://houbb.github.io/2018/08/13/consistent-hash" target="_blank" rel="noopener noreferrer">一致性 hash 算法</a></p><p><a href="https://houbb.github.io/2018/05/30/hash-impl" target="_blank" rel="noopener noreferrer">java hash 实现</a></p><p><a href="https://houbb.github.io/2018/05/30/hash-conflict" target="_blank" rel="noopener noreferrer">hash 冲突处理</a></p><p><a href="https://houbb.github.io/2018/12/05/bloom-filter" target="_blank" rel="noopener noreferrer">bloom filter</a></p><p><a href="https://houbb.github.io/2019/04/01/BloomFilter-best-practice" target="_blank" rel="noopener noreferrer">bloom filter 使用最佳实践，让你少采坑！</a></p><h1 id="todo" tabindex="-1"><a class="header-anchor" href="#todo"><span>todo</span></a></h1><p>工具包包的封装+文档</p><p>资源可视化</p><p>前后端===》项目</p><p>弱点解决===》场景解决方案/技术咨询</p><h1 id="chat" tabindex="-1"><a class="header-anchor" href="#chat"><span>chat</span></a></h1><h1 id="详细介绍一下-一致性哈希" tabindex="-1"><a class="header-anchor" href="#详细介绍一下-一致性哈希"><span>详细介绍一下 一致性哈希</span></a></h1><p>一致性哈希（<strong>Consistent Hashing</strong>）是一种为了解决分布式系统中<strong>节点频繁增删带来的数据重分布问题</strong>的哈希算法，广泛应用于缓存系统（如：Redis Cluster、Memcached）、分布式存储系统（如：Cassandra、Ceph）和负载均衡等场景。</p><hr><h2 id="✨-背景问题-为什么需要一致性哈希" tabindex="-1"><a class="header-anchor" href="#✨-背景问题-为什么需要一致性哈希"><span>✨ 背景问题：为什么需要一致性哈希？</span></a></h2><h3 id="常规哈希的缺点" tabindex="-1"><a class="header-anchor" href="#常规哈希的缺点"><span>常规哈希的缺点</span></a></h3><p>假设我们要将数据分配到 3 台缓存服务器上，通常做法是：</p><div class="language-text line-numbers-mode" data-highlighter="shiki" data-ext="text" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>hash(key) % N</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>其中 <code>N = 3</code> 是服务器数量。</p><p>但问题是：</p><ul><li>当服务器增减时，比如从 3 台变成 4 台，所有 key 的 <code>hash(key) % 4</code> 的结果都会改变。</li><li>这导致几乎<strong>所有的数据都需要重新映射和迁移</strong>，效率极低，也不利于系统稳定。</li></ul><hr><h2 id="🧠-一致性哈希的核心思想" tabindex="-1"><a class="header-anchor" href="#🧠-一致性哈希的核心思想"><span>🧠 一致性哈希的核心思想</span></a></h2><p>一致性哈希的核心是将整个<strong>哈希值空间组织成一个“环”</strong>（0 ~ 2³² - 1），然后：</p><ol><li><p><strong>将服务器映射到哈希环上</strong>：<br> 对每个服务器节点计算哈希值，放到哈希环上对应的位置。</p></li><li><p><strong>将数据映射到哈希环上</strong>：<br> 对每个数据的 key 也计算哈希值，找到环上“第一个顺时针大于等于该值的节点”，将其存储在该节点。</p></li><li><p><strong>当节点增加或删除时，仅影响局部数据的重新分布</strong>，大大减少了数据迁移量。</p></li></ol><hr><h2 id="🎯-一致性哈希的具体流程" tabindex="-1"><a class="header-anchor" href="#🎯-一致性哈希的具体流程"><span>🎯 一致性哈希的具体流程</span></a></h2><h3 id="_1-构造哈希环" tabindex="-1"><a class="header-anchor" href="#_1-构造哈希环"><span>1. 构造哈希环</span></a></h3><ul><li>使用一个固定范围的哈希函数（如 <code>MD5</code>），将整个哈希空间看作一个 0 到 2³²-1 的环。</li><li>每个服务器节点根据其 IP 或名称哈希成一个点，放在环上。</li></ul><h3 id="_2-数据存储策略" tabindex="-1"><a class="header-anchor" href="#_2-数据存储策略"><span>2. 数据存储策略</span></a></h3><ul><li>对数据 key 哈希后，顺时针找第一个服务器节点。</li><li>如果到了最大值也找不到，则回环到最开始。</li></ul><h3 id="_3-增删节点操作" tabindex="-1"><a class="header-anchor" href="#_3-增删节点操作"><span>3. 增删节点操作</span></a></h3><ul><li><p><strong>增加节点</strong>：<br> 只会影响该节点“前一个节点”和它之间的数据，这部分数据会迁移到新节点。</p></li><li><p><strong>删除节点</strong>：<br> 该节点负责的数据迁移到它的下一个节点即可。</p></li></ul><hr><h2 id="🎮-举个例子" tabindex="-1"><a class="header-anchor" href="#🎮-举个例子"><span>🎮 举个例子</span></a></h2><h3 id="环上服务器分布" tabindex="-1"><a class="header-anchor" href="#环上服务器分布"><span>环上服务器分布：</span></a></h3><table><thead><tr><th>服务器</th><th>哈希值</th></tr></thead><tbody><tr><td>A</td><td>100</td></tr><tr><td>B</td><td>300</td></tr><tr><td>C</td><td>600</td></tr></tbody></table><p>现在 key = <code>user123</code>，哈希值为 250：</p><ul><li><p>它会顺时针映射到 B 节点（300）。</p></li><li><p>若插入一个新节点 D（哈希值 = 200），</p><ul><li><code>user123</code> 将落到 D。</li><li>其他 key 不变。</li></ul></li></ul><p>这样，就只迁移了极少量的数据。</p><hr><h2 id="🧩-虚拟节点-virtual-nodes" tabindex="-1"><a class="header-anchor" href="#🧩-虚拟节点-virtual-nodes"><span>🧩 虚拟节点（Virtual Nodes）</span></a></h2><p>现实中服务器节点不可能完全均匀分布，为了解决<strong>数据倾斜</strong>问题，引入了虚拟节点。</p><ul><li>每个物理节点对应多个虚拟节点（如 ServerA-1, ServerA-2 等），映射到不同位置。</li><li>数据映射还是按虚拟节点来，虚拟节点内部再映射到真实服务器。</li><li>这样可以<strong>均衡数据分布</strong>，防止某个节点压力过大。</li></ul><hr><h2 id="🏗-应用场景" tabindex="-1"><a class="header-anchor" href="#🏗-应用场景"><span>🏗 应用场景</span></a></h2><ol><li><p><strong>分布式缓存系统</strong></p><ul><li>如：Memcached、Redis Cluster</li><li>解决节点扩容/缩容导致的大规模缓存失效问题</li></ul></li><li><p><strong>分布式存储系统</strong></p><ul><li>如：Cassandra、HBase、Riak</li><li>数据分区和副本路由</li></ul></li><li><p><strong>负载均衡系统</strong></p><ul><li>动态添加、下线后端服务器时，尽量减少请求扰动</li></ul></li></ol><hr><h2 id="✅-一致性哈希的优点" tabindex="-1"><a class="header-anchor" href="#✅-一致性哈希的优点"><span>✅ 一致性哈希的优点</span></a></h2><ul><li>节点变动影响最小：只迁移局部数据</li><li>支持节点动态增删</li><li>结合虚拟节点后负载均衡效果更好</li><li>非常适合大规模分布式环境</li></ul><hr><h2 id="⚠️-注意事项-缺点" tabindex="-1"><a class="header-anchor" href="#⚠️-注意事项-缺点"><span>⚠️ 注意事项 / 缺点</span></a></h2><ul><li>实现相对复杂，哈希函数选择影响均匀性</li><li>虚拟节点过多会增加维护成本</li><li>哈希环理论基础需要一定学习成本</li></ul><hr><h2 id="总结一句话" tabindex="-1"><a class="header-anchor" href="#总结一句话"><span>总结一句话：</span></a></h2><blockquote><p><strong>一致性哈希</strong>通过把节点和数据映射到一个虚拟的哈希环中，结合顺时针查找策略，实现了高效的数据分布和最小的数据迁移，是分布式系统中解决“节点变动引起数据重分布”的核心算法之一。</p></blockquote><p>如你需要，我可以画一张图来直观展示整个哈希环、节点与 key 的映射过程。是否需要？</p>',58)]))}const p=e(s,[["render",o]]),d=JSON.parse('{"path":"/posts/algorithm/hash/2018-05-30-hash-15-chat-hash-load-balance-consist-hash.html","title":"Hash-15-聊一聊哈希负载均衡之一致性哈希 Consistent Hashing","lang":"zh-CN","frontmatter":{"title":"Hash-15-聊一聊哈希负载均衡之一致性哈希 Consistent Hashing","date":"2018-05-30T00:00:00.000Z","categories":["Algorithm"],"tags":["algorithm","hash","hashing","load-balance"],"published":true,"description":"拓展阅读 一致性 hash 算法 java hash 实现 hash 冲突处理 bloom filter bloom filter 使用最佳实践，让你少采坑！ todo 工具包包的封装+文档 资源可视化 前后端===》项目 弱点解决===》场景解决方案/技术咨询 chat 详细介绍一下 一致性哈希 一致性哈希（Consistent Hashing）是一...","head":[["meta",{"property":"og:url","content":"https://houbb.github.io/leetcode-notes/posts/algorithm/hash/2018-05-30-hash-15-chat-hash-load-balance-consist-hash.html"}],["meta",{"property":"og:site_name","content":"老马啸西风"}],["meta",{"property":"og:title","content":"Hash-15-聊一聊哈希负载均衡之一致性哈希 Consistent Hashing"}],["meta",{"property":"og:description","content":"拓展阅读 一致性 hash 算法 java hash 实现 hash 冲突处理 bloom filter bloom filter 使用最佳实践，让你少采坑！ todo 工具包包的封装+文档 资源可视化 前后端===》项目 弱点解决===》场景解决方案/技术咨询 chat 详细介绍一下 一致性哈希 一致性哈希（Consistent Hashing）是一..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-08-23T04:59:26.000Z"}],["meta",{"property":"article:tag","content":"algorithm"}],["meta",{"property":"article:tag","content":"hash"}],["meta",{"property":"article:tag","content":"hashing"}],["meta",{"property":"article:tag","content":"load-balance"}],["meta",{"property":"article:published_time","content":"2018-05-30T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2025-08-23T04:59:26.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Hash-15-聊一聊哈希负载均衡之一致性哈希 Consistent Hashing\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2018-05-30T00:00:00.000Z\\",\\"dateModified\\":\\"2025-08-23T04:59:26.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"老马啸西风\\",\\"url\\":\\"https://houbb.github.io\\"}]}"]]},"git":{"createdTime":1755925166000,"updatedTime":1755925166000,"contributors":[{"name":"bbhou","username":"bbhou","email":"1557740299@qq.com","commits":1,"url":"https://github.com/bbhou"}]},"readingTime":{"minutes":3.91,"words":1174},"filePathRelative":"posts/algorithm/hash/2018-05-30-hash-15-chat-hash-load-balance-consist-hash.md","localizedDate":"2018年5月30日","excerpt":"\\n<p><a href=\\"https://houbb.github.io/2018/08/13/consistent-hash\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">一致性 hash 算法</a></p>\\n<p><a href=\\"https://houbb.github.io/2018/05/30/hash-impl\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">java hash 实现</a></p>\\n<p><a href=\\"https://houbb.github.io/2018/05/30/hash-conflict\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">hash 冲突处理</a></p>","autoDesc":true}');export{p as comp,d as data};
