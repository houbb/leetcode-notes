import{_ as t}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as r,a,o as p}from"./app-Cbb6KCGF.js";const o={};function s(n,e){return p(),r("div",null,e[0]||(e[0]=[a('<h1 id="开源地址" tabindex="-1"><a class="header-anchor" href="#开源地址"><span>开源地址</span></a></h1><p>为了便于大家学习，所有实现均已开源。欢迎 fork + star~</p><blockquote><p><a href="https://github.com/houbb/leetcode" target="_blank" rel="noopener noreferrer">https://github.com/houbb/leetcode</a></p></blockquote><h1 id="题目" tabindex="-1"><a class="header-anchor" href="#题目"><span>题目</span></a></h1><p>给定一个非负整数数组 nums 和一个整数 k ，你需要将这个数组分成 k 个非空的连续子数组。</p><p>设计一个算法使得这 k 个子数组各自和的最大值最小。</p><p>示例 1：</p><p>输入：nums = [7,2,5,10,8], k = 2<br> 输出：18<br> 解释：<br> 一共有四种方法将 nums 分割为 2 个子数组。<br> 其中最好的方式是将其分为 [7,2,5] 和 [10,8] 。<br> 因为此时这两个子数组各自的和的最大值为18，在所有情况中最小。</p><p>示例 2：</p><p>输入：nums = [1,2,3,4,5], k = 2<br> 输出：9<br> 示例 3：</p><p>输入：nums = [1,4,4], k = 3<br> 输出：4</p><p>提示：</p><p>1 &lt;= nums.length &lt;= 1000</p><p>0 &lt;= nums[i] &lt;= 10^6</p><p>1 &lt;= k &lt;= min(50, nums.length)</p><h1 id="v1-基本前缀和-bf" tabindex="-1"><a class="header-anchor" href="#v1-基本前缀和-bf"><span>v1-基本前缀和+BF</span></a></h1><h2 id="思路" tabindex="-1"><a class="header-anchor" href="#思路"><span>思路</span></a></h2><p>前缀和提前构架好整个前缀和数组，方便计算子数组的和。</p><p>但是这里构建好前缀和实际上还要做两件事：</p><p>1）如何把数组拆分为 k 个子数组？</p><p>2）如何保证 k 个子数组的各自和的最大值最小</p><p>本质是一个什么问题？</p><p>暴力算法算出所有的结果可能性？</p><h2 id="子问题1-拆分" tabindex="-1"><a class="header-anchor" href="#子问题1-拆分"><span>子问题1-拆分</span></a></h2><p>将数组拆分为 k 个连续非空子数组，有多少种方式？应该如何计算？</p><p>backtracking? 回溯？</p><h2 id="子问题2-最小值" tabindex="-1"><a class="header-anchor" href="#子问题2-最小值"><span>子问题2-最小值</span></a></h2><p>这个还算好解决，可以存储一下，对比即可。</p><p>感觉直接做这一题有点难，先做其他题目找找感觉，</p><p>TBC.....</p><h2 id="小结" tabindex="-1"><a class="header-anchor" href="#小结"><span>小结</span></a></h2><h1 id="参考资料" tabindex="-1"><a class="header-anchor" href="#参考资料"><span>参考资料</span></a></h1><p><a href="https://leetcode.cn/problems/longest-well-performing-interval/submissions/578871050/?envType=problem-list-v2&amp;envId=prefix-sum" target="_blank" rel="noopener noreferrer">https://leetcode.cn/problems/longest-well-performing-interval/submissions/578871050/?envType=problem-list-v2&amp;envId=prefix-sum</a></p>',33)]))}const h=t(o,[["render",s]]),m=JSON.parse('{"path":"/posts/leetcode/history1/2020-06-06-algorithm-020-leetcode-52-prefix-sum-410-split-array-largest-sum.html","title":"52-410. split-array-largest-sum  力扣 410. 分割数组的最大值","lang":"zh-CN","frontmatter":{"title":"52-410. split-array-largest-sum  力扣 410. 分割数组的最大值","date":"2020-06-08T00:00:00.000Z","categories":["Algorithm"],"tags":["algorithm","prefix-sum","leetcode"],"published":true,"description":"开源地址 为了便于大家学习，所有实现均已开源。欢迎 fork + star~ https://github.com/houbb/leetcode 题目 给定一个非负整数数组 nums 和一个整数 k ，你需要将这个数组分成 k 个非空的连续子数组。 设计一个算法使得这 k 个子数组各自和的最大值最小。 示例 1： 输入：nums = [7,2,5,10...","head":[["meta",{"property":"og:url","content":"https://houbb.github.io/leetcode-notes/posts/leetcode/history1/2020-06-06-algorithm-020-leetcode-52-prefix-sum-410-split-array-largest-sum.html"}],["meta",{"property":"og:site_name","content":"老马啸西风"}],["meta",{"property":"og:title","content":"52-410. split-array-largest-sum  力扣 410. 分割数组的最大值"}],["meta",{"property":"og:description","content":"开源地址 为了便于大家学习，所有实现均已开源。欢迎 fork + star~ https://github.com/houbb/leetcode 题目 给定一个非负整数数组 nums 和一个整数 k ，你需要将这个数组分成 k 个非空的连续子数组。 设计一个算法使得这 k 个子数组各自和的最大值最小。 示例 1： 输入：nums = [7,2,5,10..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-08-22T12:19:07.000Z"}],["meta",{"property":"article:tag","content":"algorithm"}],["meta",{"property":"article:tag","content":"prefix-sum"}],["meta",{"property":"article:tag","content":"leetcode"}],["meta",{"property":"article:published_time","content":"2020-06-08T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2025-08-22T12:19:07.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"52-410. split-array-largest-sum  力扣 410. 分割数组的最大值\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2020-06-08T00:00:00.000Z\\",\\"dateModified\\":\\"2025-08-22T12:19:07.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"老马啸西风\\",\\"url\\":\\"https://houbb.github.io\\"}]}"]]},"git":{"createdTime":1755499309000,"updatedTime":1755865147000,"contributors":[{"name":"binbin.hou","username":"","email":"binbin.hou@huifu.com","commits":2},{"name":"bbhou","username":"bbhou","email":"1557740299@qq.com","commits":2,"url":"https://github.com/bbhou"}]},"readingTime":{"minutes":1.52,"words":456},"filePathRelative":"posts/leetcode/history1/2020-06-06-algorithm-020-leetcode-52-prefix-sum-410-split-array-largest-sum.md","localizedDate":"2020年6月8日","excerpt":"\\n<p>为了便于大家学习，所有实现均已开源。欢迎 fork + star~</p>\\n<blockquote>\\n<p><a href=\\"https://github.com/houbb/leetcode\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">https://github.com/houbb/leetcode</a></p>\\n</blockquote>\\n<h1>题目</h1>\\n<p>给定一个非负整数数组 nums 和一个整数 k ，你需要将这个数组分成 k 个非空的连续子数组。</p>\\n<p>设计一个算法使得这 k 个子数组各自和的最大值最小。</p>","autoDesc":true}');export{h as comp,m as data};
