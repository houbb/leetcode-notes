import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as r,a as d,o as a}from"./app-DLdOzarQ.js";const o={};function n(l,t){return a(),r("div",null,t[0]||(t[0]=[d('<h1 id="数组" tabindex="-1"><a class="header-anchor" href="#数组"><span>数组</span></a></h1><p>大家好，我是老马。</p><p>今天我们一起来学习一下数组这种数据结构。</p><h2 id="主要知识" tabindex="-1"><a class="header-anchor" href="#主要知识"><span>主要知识</span></a></h2><p>数组需要拆分下面几个部分：</p><ol><li><p>理论介绍</p></li><li><p>源码分析</p></li><li><p>数据结构实现？</p></li><li><p>题目练习（按照算法思想分类）</p></li><li><p>梳理对应的 sdk 包</p></li><li><p>应用实战</p></li></ol><p>因为这个是 leetcode 系列，所以重点是 4、5(对4再一次总结)。</p><p>为了照顾没有基础的小伙伴，会简单介绍一下1的基础理论。</p><p>简单介绍1，重点为4。其他不是本系列的重点。</p><h1 id="chat" tabindex="-1"><a class="header-anchor" href="#chat"><span>chat</span></a></h1><h1 id="介绍一下数组" tabindex="-1"><a class="header-anchor" href="#介绍一下数组"><span>介绍一下数组</span></a></h1><p>下面是对数组（Array）这个数据结构介绍，包括它的基本概念、特点、常见操作、时间复杂度分析、优缺点、以及在实际中的应用。</p><hr><h2 id="一、什么是数组-array" tabindex="-1"><a class="header-anchor" href="#一、什么是数组-array"><span>一、什么是数组（Array）？</span></a></h2><p><strong>数组（Array）</strong> 是一种<strong>线性数据结构</strong>，用于存储<strong>固定大小</strong>的<strong>同类型元素集合</strong>。这些元素在内存中是<strong>连续存储</strong>的，可以通过**索引（index）**直接访问。</p><p>比如一个整数数组：<code>[10, 20, 30, 40]</code>，其中第一个元素 <code>10</code> 的索引是 0，第二个是 1，以此类推。</p><hr><h2 id="二、数组的特点" tabindex="-1"><a class="header-anchor" href="#二、数组的特点"><span>二、数组的特点</span></a></h2><table><thead><tr><th>特性</th><th>说明</th></tr></thead><tbody><tr><td>顺序存储</td><td>数组的元素在内存中是连续存放的</td></tr><tr><td>随机访问</td><td>可以通过下标 <code>O(1)</code> 时间快速访问任意元素</td></tr><tr><td>类型一致</td><td>数组中的所有元素类型必须相同（在强类型语言中）</td></tr><tr><td>长度固定</td><td>大多数语言中，定义后大小不能改变（如 Java、C/C++ 中的普通数组）</td></tr></tbody></table><hr><h2 id="三、常见操作及复杂度" tabindex="-1"><a class="header-anchor" href="#三、常见操作及复杂度"><span>三、常见操作及复杂度</span></a></h2><table><thead><tr><th>操作</th><th>说明</th><th>时间复杂度</th></tr></thead><tbody><tr><td>访问元素</td><td>通过下标访问 <code>arr[i]</code></td><td><code>O(1)</code></td></tr><tr><td>更新元素</td><td>修改某个位置的值</td><td><code>O(1)</code></td></tr><tr><td>插入元素</td><td>在中间插入一个新值（要移动元素）</td><td><code>O(n)</code></td></tr><tr><td>删除元素</td><td>删除中间某个值（要移动元素）</td><td><code>O(n)</code></td></tr><tr><td>遍历数组</td><td>用循环访问每个元素</td><td><code>O(n)</code></td></tr><tr><td>查找元素</td><td>线性查找（无序数组）</td><td><code>O(n)</code></td></tr><tr><td>二分查找</td><td>在有序数组中查找</td><td><code>O(log n)</code></td></tr></tbody></table><hr><h2 id="四、数组的优缺点" tabindex="-1"><a class="header-anchor" href="#四、数组的优缺点"><span>四、数组的优缺点</span></a></h2><h3 id="✅-优点" tabindex="-1"><a class="header-anchor" href="#✅-优点"><span>✅ 优点</span></a></h3><ul><li><strong>访问效率高</strong>：通过索引快速读取或修改元素，时间复杂度为 <code>O(1)</code>。</li><li><strong>结构简单</strong>：实现容易，适合用作其他数据结构的底层基础（如堆、栈、队列等）。</li><li><strong>空间紧凑</strong>：连续内存分配，节省空间。</li></ul><h3 id="❌-缺点" tabindex="-1"><a class="header-anchor" href="#❌-缺点"><span>❌ 缺点</span></a></h3><ul><li><strong>插入/删除效率低</strong>：非尾部插入或删除需要移动大量元素。</li><li><strong>容量固定</strong>：定义时必须指定大小，不易动态扩容（除非使用动态数组，如 <code>ArrayList</code>）。</li><li><strong>内存要求高</strong>：连续内存块在大数组下可能导致内存</li></ul><h1 id="密切相关的算法" tabindex="-1"><a class="header-anchor" href="#密切相关的算法"><span>密切相关的算法</span></a></h1><h2 id="✅-数组密切关联的核心算法整理" tabindex="-1"><a class="header-anchor" href="#✅-数组密切关联的核心算法整理"><span>✅ 数组密切关联的核心算法整理</span></a></h2><hr><h3 id="🟢-一、查找类算法-适用于有序-无序数组" tabindex="-1"><a class="header-anchor" href="#🟢-一、查找类算法-适用于有序-无序数组"><span>🟢 一、查找类算法（适用于有序/无序数组）</span></a></h3><ul><li><p><strong>二分查找（Binary Search）</strong></p><ul><li>要求数组有序，时间复杂度 <code>O(log n)</code></li><li>应用：查找目标值、左边界、右边界（lower_bound/upper_bound）</li><li>✨ LeetCode 模板题：704、35、34</li></ul></li><li><p><strong>哈希查找（Hash + Map）</strong></p><ul><li>用于无序数组中快速定位目标值或频次统计</li><li>应用：两数之和、前缀频率统计、元素是否重复</li></ul></li></ul><hr><h3 id="🔵-二、指针-窗口类算法-适合线性遍历、局部范围处理" tabindex="-1"><a class="header-anchor" href="#🔵-二、指针-窗口类算法-适合线性遍历、局部范围处理"><span>🔵 二、指针/窗口类算法（适合线性遍历、局部范围处理）</span></a></h3><ul><li><p><strong>双指针（Two Pointers）</strong></p><ul><li>用于处理有序数组、区间问题、去重等</li><li>典型场景：快慢指针、对撞指针</li><li>✨ 例题：26（原地去重）、167（两数之和 II）、283（移动零）</li></ul></li><li><p><strong>滑动窗口（Sliding Window）</strong></p><ul><li>动态维护一个区间，用于求解最大/最小子数组、满足条件的子数组</li><li>分为：固定窗口 &amp; 可变窗口</li><li>✨ 例题：209（最小子数组）、3（无重复字符的最长子串）</li></ul></li></ul><hr><h3 id="🟡-三、前缀思想类算法" tabindex="-1"><a class="header-anchor" href="#🟡-三、前缀思想类算法"><span>🟡 三、前缀思想类算法</span></a></h3><ul><li><p><strong>前缀和（Prefix Sum）</strong></p><ul><li>快速计算任意子数组的和，时间从 O(n) 降到 O(1)</li><li>应用：子数组和固定值、二维区域和</li><li>✨ 例题：560（和为 K 的子数组）、303（区域和检索）</li></ul></li><li><p><strong>差分数组（Difference Array）</strong></p><ul><li>主要用于区间更新优化，减少重复计算</li><li>✨ 应用题：370（区间加法）</li></ul></li></ul><hr><h3 id="🟠-四、排序类算法-很多题的前置步骤" tabindex="-1"><a class="header-anchor" href="#🟠-四、排序类算法-很多题的前置步骤"><span>🟠 四、排序类算法（很多题的前置步骤）</span></a></h3><ul><li><p><strong>冒泡/插入/选择排序</strong></p><ul><li>入门级算法，理解排序原理和交换机制</li></ul></li><li><p><strong>快速排序、归并排序</strong></p><ul><li>快速排序：分治法的代表，平均 O(n log n)</li><li>归并排序：适合求逆序对等场景</li><li>✨ 例题：912（排序数组）、315（计算右侧小于当前元素的个数）</li></ul></li><li><p><strong>排序后处理类问题</strong></p><ul><li>如：三数之和（排序后双指针）、合并区间、最大间距</li></ul></li></ul><hr><h3 id="🔴-五、构造类-模拟类算法" tabindex="-1"><a class="header-anchor" href="#🔴-五、构造类-模拟类算法"><span>🔴 五、构造类 / 模拟类算法</span></a></h3><ul><li><p><strong>数组旋转</strong>（翻转法、环状替换）</p><ul><li>✨ 例题：189（旋转数组）</li></ul></li><li><p><strong>原地修改 / 原地删除元素</strong></p><ul><li>应用场景广泛，涉及数组压缩、空间优化</li><li>✨ 例题：27（移除元素）、80（删除有序数组中重复项 II）</li></ul></li><li><p><strong>矩阵处理</strong>（二维数组的进阶）</p><ul><li>旋转矩阵、螺旋遍历、压缩行列等</li><li>✨ 例题：48（旋转图像）、73（矩阵置零）</li></ul></li></ul><hr><h3 id="🟣-六、组合与变形类算法" tabindex="-1"><a class="header-anchor" href="#🟣-六、组合与变形类算法"><span>🟣 六、组合与变形类算法</span></a></h3><ul><li><p><strong>子集 / 子数组 / 子序列 枚举</strong></p><ul><li>回溯、位运算、滑动窗口等</li><li>✨ 例题：78（子集）、90（子集 II）</li></ul></li><li><p><strong>贪心算法 + 数组</strong></p><ul><li>特别适合调度问题、区间覆盖、跳跃游戏</li><li>✨ 例题：55（能否跳到最后）、45（最小跳跃次数）</li></ul></li><li><p><strong>堆栈模拟数组操作（单调栈/单调队列）</strong></p><ul><li>用于求区间最大最小值、下一个更大元素</li><li>✨ 例题：739（每日温度）、84（柱状图最大矩形）</li></ul></li></ul><h2 id="从-leetcode-推荐最值得练习的-10-道数组题" tabindex="-1"><a class="header-anchor" href="#从-leetcode-推荐最值得练习的-10-道数组题"><span>从 leetcode 推荐最值得练习的 10 道数组题</span></a></h2><p>LeetCode 上有许多经典的数组问题，它们涉及不同的技术点和技巧，以下是我推荐的最值得练习的 10 道数组题（按难度从易到难排序）：</p><h3 id="_1-two-sum-1" tabindex="-1"><a class="header-anchor" href="#_1-two-sum-1"><span>1. <strong>Two Sum (1)</strong></span></a></h3><ul><li><strong>题目链接</strong>: <a href="https://leetcode.com/problems/two-sum/" target="_blank" rel="noopener noreferrer">Two Sum</a></li><li><strong>难度</strong>: 简单</li><li><strong>重点</strong>: 基本的哈希表技巧，快速查找已遍历过的元素。</li></ul><h3 id="_2-best-time-to-buy-and-sell-stock-121" tabindex="-1"><a class="header-anchor" href="#_2-best-time-to-buy-and-sell-stock-121"><span>2. <strong>Best Time to Buy and Sell Stock (121)</strong></span></a></h3><ul><li><strong>题目链接</strong>: <a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock/" target="_blank" rel="noopener noreferrer">Best Time to Buy and Sell Stock</a></li><li><strong>难度</strong>: 简单</li><li><strong>重点</strong>: 动态规划思想，遍历数组时维护最小值。</li></ul><h3 id="_3-rotate-array-189" tabindex="-1"><a class="header-anchor" href="#_3-rotate-array-189"><span>3. <strong>Rotate Array (189)</strong></span></a></h3><ul><li><strong>题目链接</strong>: <a href="https://leetcode.com/problems/rotate-array/" target="_blank" rel="noopener noreferrer">Rotate Array</a></li><li><strong>难度</strong>: 中等</li><li><strong>重点</strong>: 数组旋转，可以通过反转三次数组来解决。</li></ul><h3 id="_4-move-zeroes-283" tabindex="-1"><a class="header-anchor" href="#_4-move-zeroes-283"><span>4. <strong>Move Zeroes (283)</strong></span></a></h3><ul><li><strong>题目链接</strong>: <a href="https://leetcode.com/problems/move-zeroes/" target="_blank" rel="noopener noreferrer">Move Zeroes</a></li><li><strong>难度</strong>: 简单</li><li><strong>重点</strong>: 数组操作，双指针技巧。</li></ul><h3 id="_5-container-with-most-water-11" tabindex="-1"><a class="header-anchor" href="#_5-container-with-most-water-11"><span>5. <strong>Container With Most Water (11)</strong></span></a></h3><ul><li><strong>题目链接</strong>: <a href="https://leetcode.com/problems/container-with-most-water/" target="_blank" rel="noopener noreferrer">Container With Most Water</a></li><li><strong>难度</strong>: 中等</li><li><strong>重点</strong>: 双指针技巧，找出最大面积。</li></ul><h3 id="_6-3sum-15" tabindex="-1"><a class="header-anchor" href="#_6-3sum-15"><span>6. <strong>3Sum (15)</strong></span></a></h3><ul><li><strong>题目链接</strong>: <a href="https://leetcode.com/problems/3sum/" target="_blank" rel="noopener noreferrer">3Sum</a></li><li><strong>难度</strong>: 中等</li><li><strong>重点</strong>: 排序+双指针技巧，找到所有满足条件的三元组。</li></ul><h3 id="_7-subarray-sum-equals-k-560" tabindex="-1"><a class="header-anchor" href="#_7-subarray-sum-equals-k-560"><span>7. <strong>Subarray Sum Equals K (560)</strong></span></a></h3><ul><li><strong>题目链接</strong>: <a href="https://leetcode.com/problems/subarray-sum-equals-k/" target="_blank" rel="noopener noreferrer">Subarray Sum Equals K</a></li><li><strong>难度</strong>: 中等</li><li><strong>重点</strong>: 前缀和+哈希表，动态求解连续子数组和。</li></ul><h3 id="_8-maximum-subarray-53" tabindex="-1"><a class="header-anchor" href="#_8-maximum-subarray-53"><span>8. <strong>Maximum Subarray (53)</strong></span></a></h3><ul><li><strong>题目链接</strong>: <a href="https://leetcode.com/problems/maximum-subarray/" target="_blank" rel="noopener noreferrer">Maximum Subarray</a></li><li><strong>难度</strong>: 中等</li><li><strong>重点</strong>: 动态规划，寻找最大和子数组。</li></ul><h3 id="_9-product-of-array-except-self-238" tabindex="-1"><a class="header-anchor" href="#_9-product-of-array-except-self-238"><span>9. <strong>Product of Array Except Self (238)</strong></span></a></h3><ul><li><strong>题目链接</strong>: <a href="https://leetcode.com/problems/product-of-array-except-self/" target="_blank" rel="noopener noreferrer">Product of Array Except Self</a></li><li><strong>难度</strong>: 中等</li><li><strong>重点</strong>: 线性时间解决问题，使用前缀积和后缀积。</li></ul><h3 id="_10-find-minimum-in-rotated-sorted-array-153" tabindex="-1"><a class="header-anchor" href="#_10-find-minimum-in-rotated-sorted-array-153"><span>10. <strong>Find Minimum in Rotated Sorted Array (153)</strong></span></a></h3><ul><li><strong>题目链接</strong>: <a href="https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/" target="_blank" rel="noopener noreferrer">Find Minimum in Rotated Sorted Array</a></li><li><strong>难度</strong>: 中等</li><li><strong>重点</strong>: 二分查找，处理旋转数组。</li></ul><p>这些题目覆盖了数组操作的多种常见模式，掌握它们可以帮助你提高在数组处理上的能力，特别是对于面试中的数组问题。</p><h1 id="拓展的一些技巧和类型" tabindex="-1"><a class="header-anchor" href="#拓展的一些技巧和类型"><span>拓展的一些技巧和类型</span></a></h1><p>这是个很棒的问题！</p><p>在算法题中，<strong>数组相关的技巧</strong> 是很多题目的核心基础。你已经列出了很多重要的技巧：</p><ul><li>✅ 遍历</li><li>✅ 滑动窗口</li><li>✅ 双指针</li><li>✅ 前缀和</li><li>✅ 差分数组</li><li>✅ 矩阵技巧（如二维前缀和、螺旋、DFS/BFS 等）</li></ul><p>除了这些，还有不少<strong>和数组关系非常密切的算法/技巧</strong>，我来分类整理一下，方便你系统掌握。</p><hr><h2 id="🧠-一、数据预处理类技巧-和前缀和-差分类似" tabindex="-1"><a class="header-anchor" href="#🧠-一、数据预处理类技巧-和前缀和-差分类似"><span>🧠 一、数据预处理类技巧（和前缀和/差分类似）</span></a></h2><table><thead><tr><th>技巧</th><th>说明</th><th>常见题目</th></tr></thead><tbody><tr><td>✅ 前缀积 / 前缀最大/最小</td><td><code>pre[i] = pre[i-1] * nums[i]</code>，常用于快速计算积或范围最值</td><td>LeetCode 238</td></tr><tr><td>✅ 后缀数组</td><td>从右往左构建，与前缀数组搭配使用</td><td>LeetCode 238、42</td></tr><tr><td>✅ 计数数组（桶）</td><td>频率统计、哈希表的替代品</td><td>LeetCode 347、164</td></tr><tr><td>✅ 差分前缀和结合</td><td>比如差分解决多次区间修改，前缀和还原</td><td>LeetCode 1109、1094</td></tr></tbody></table><hr><h2 id="⚡-二、查找类技巧-离散化、二分、哈希" tabindex="-1"><a class="header-anchor" href="#⚡-二、查找类技巧-离散化、二分、哈希"><span>⚡ 二、查找类技巧（离散化、二分、哈希）</span></a></h2><table><thead><tr><th>技巧</th><th>说明</th><th>适用场景</th></tr></thead><tbody><tr><td>✅ 离散化</td><td>把大范围数字映射到小范围</td><td>树状数组 / 线段树 等数据结构配合</td></tr><tr><td>✅ 二分查找 / 二分答案</td><td><code>O(logn)</code> 查找目标元素 / 判断某个条件是否可行</td><td>LeetCode 34、875、1283</td></tr><tr><td>✅ 哈希表</td><td>统计频率/判断存在性，处理重复值</td><td>TwoSum、SubarraySum 等</td></tr><tr><td>✅ 坐标哈希</td><td>用于处理稀疏数组、稀疏矩阵</td><td>LeetCode 2536、1034</td></tr></tbody></table><hr><h2 id="🧊-三、空间压缩-动态技巧" tabindex="-1"><a class="header-anchor" href="#🧊-三、空间压缩-动态技巧"><span>🧊 三、空间压缩/动态技巧</span></a></h2><table><thead><tr><th>技巧</th><th>说明</th><th>例子</th></tr></thead><tbody><tr><td>✅ 状态压缩</td><td>使用位运算表示数组/集合的状态</td><td>LeetCode 698、691</td></tr><tr><td>✅ 差分 + 前缀和优化空间</td><td>将二维更新压成一维</td><td>LeetCode 370</td></tr><tr><td>✅ 滚动数组（滚动DP）</td><td>节省空间的动态规划技巧</td><td>LeetCode 70、62</td></tr><tr><td>✅ 双端队列优化窗口</td><td>滑动窗口最值 / 单调队列</td><td>LeetCode 239、862</td></tr></tbody></table><hr><h2 id="💥-四、排序类-归并-树状结构" tabindex="-1"><a class="header-anchor" href="#💥-四、排序类-归并-树状结构"><span>💥 四、排序类 + 归并 + 树状结构</span></a></h2><table><thead><tr><th>技巧</th><th>说明</th><th>应用</th></tr></thead><tbody><tr><td>✅ 排序 + 枚举/分类</td><td>常与贪心/双指针结合</td><td>LeetCode 56、435</td></tr><tr><td>✅ 归并排序求逆序对</td><td>利用 merge 步计算逆序对个数</td><td>LeetCode 315</td></tr><tr><td>✅ 树状数组</td><td>支持前缀和查询 + 单点修改</td><td>LeetCode 307、315</td></tr><tr><td>✅ 线段树</td><td>支持区间修改/查询</td><td>LeetCode 307、699</td></tr><tr><td>✅ 并查集（按秩+路径压缩）</td><td>用于连通块判断，常见在图+数组混合题</td><td>LeetCode 547、1319</td></tr></tbody></table><hr><h2 id="🌈-五、子数组-子序列类技巧" tabindex="-1"><a class="header-anchor" href="#🌈-五、子数组-子序列类技巧"><span>🌈 五、子数组/子序列类技巧</span></a></h2><table><thead><tr><th>技巧</th><th>说明</th><th>常用套路</th></tr></thead><tbody><tr><td>✅ 枚举子数组/子序列</td><td>暴力 + 优化（滑窗、前缀和、哈希等）</td><td>LeetCode 560、523</td></tr><tr><td>✅ 中心扩展</td><td>常用于最长回文子串</td><td>LeetCode 5</td></tr><tr><td>✅ 动态规划</td><td>子序列/子数组的结构性递推</td><td>LeetCode 300、53、198</td></tr><tr><td>✅ 单调栈</td><td>查找下一个更大/更小元素</td><td>LeetCode 84、739、496</td></tr></tbody></table><hr><h2 id="📐-六、矩阵和二维数组技巧-和数组密切相关" tabindex="-1"><a class="header-anchor" href="#📐-六、矩阵和二维数组技巧-和数组密切相关"><span>📐 六、矩阵和二维数组技巧（和数组密切相关）</span></a></h2><table><thead><tr><th>技巧</th><th>说明</th><th>应用</th></tr></thead><tbody><tr><td>✅ 二维前缀和</td><td>预处理二维区域和</td><td>LeetCode 304、1314</td></tr><tr><td>✅ 二维差分</td><td>多次修改 + 一次还原</td><td>LeetCode 2536</td></tr><tr><td>✅ DFS/BFS 遍历</td><td>图 + 矩阵的基础</td><td>LeetCode 200、695</td></tr><tr><td>✅ 螺旋遍历</td><td>处理旋转、走位问题</td><td>LeetCode 54、59</td></tr><tr><td>✅ 滑动窗口最大值</td><td>二维滑动窗口优化</td><td>LeetCode 239（扩展）</td></tr></tbody></table><hr><h2 id="🧩-七、其他零散但实用技巧" tabindex="-1"><a class="header-anchor" href="#🧩-七、其他零散但实用技巧"><span>🧩 七、其他零散但实用技巧</span></a></h2><table><thead><tr><th>技巧</th><th>说明</th><th>应用题目</th></tr></thead><tbody><tr><td>✅ 贪心与数组结合</td><td>常结合排序、遍历处理区间/覆盖问题</td><td>LeetCode 452、435</td></tr><tr><td>✅ 快速幂/前缀积</td><td>数组积相关处理</td><td>LeetCode 238、1481</td></tr><tr><td>✅ 模拟题技巧</td><td>比如模拟消除、旋转、重排等</td><td>LeetCode 73、289</td></tr><tr><td>✅ 滚动哈希</td><td>快速查找重复子串</td><td>LeetCode 1044、187</td></tr></tbody></table><hr><h2 id="🔚-总结表格" tabindex="-1"><a class="header-anchor" href="#🔚-总结表格"><span>🔚 总结表格</span></a></h2><table><thead><tr><th>分类</th><th>代表技巧</th></tr></thead><tbody><tr><td>遍历类</td><td>遍历、双指针、滑窗</td></tr><tr><td>前缀/差分类</td><td>前缀和、差分、后缀数组</td></tr><tr><td>查找类</td><td>二分、哈希、离散化</td></tr><tr><td>空间/状态优化</td><td>状压、滚动数组、差分压缩</td></tr><tr><td>排序/归并类</td><td>排序、归并逆序对、树状数组、线段树</td></tr><tr><td>子数组/序列</td><td>动规、中心扩展、单调栈</td></tr><tr><td>矩阵类</td><td>二维差分、DFS/BFS、旋转模拟</td></tr><tr><td>特殊技巧</td><td>快速幂、滚动哈希、模拟题技巧</td></tr></tbody></table><hr><p>如果你是为了刷题而整理这类知识，我可以帮你做一张「<strong>数组技巧知识图谱 + 题目索引表</strong>」，要不要试试？</p>',102)]))}const h=e(o,[["render",n]]),p=JSON.parse('{"path":"/posts/leetcode/top-100-liked/array/2020-06-06-algorithm-000-leetcode-data-struct-001-array-00-overview.html","title":"leetcode 数组专题 力扣数据结构之数组-00-概览","lang":"zh-CN","frontmatter":{"title":"leetcode 数组专题 力扣数据结构之数组-00-概览","date":"2020-06-08T00:00:00.000Z","categories":["Algorithm"],"tags":["algorithm","data-struct","topics","leetcode","sf"],"published":true,"description":"数组 大家好，我是老马。 今天我们一起来学习一下数组这种数据结构。 主要知识 数组需要拆分下面几个部分： 理论介绍 源码分析 数据结构实现？ 题目练习（按照算法思想分类） 梳理对应的 sdk 包 应用实战 因为这个是 leetcode 系列，所以重点是 4、5(对4再一次总结)。 为了照顾没有基础的小伙伴，会简单介绍一下1的基础理论。 简单介绍1，重点...","head":[["meta",{"property":"og:url","content":"https://houbb.github.io/leetcode-notes/posts/leetcode/top-100-liked/array/2020-06-06-algorithm-000-leetcode-data-struct-001-array-00-overview.html"}],["meta",{"property":"og:site_name","content":"老马啸西风"}],["meta",{"property":"og:title","content":"leetcode 数组专题 力扣数据结构之数组-00-概览"}],["meta",{"property":"og:description","content":"数组 大家好，我是老马。 今天我们一起来学习一下数组这种数据结构。 主要知识 数组需要拆分下面几个部分： 理论介绍 源码分析 数据结构实现？ 题目练习（按照算法思想分类） 梳理对应的 sdk 包 应用实战 因为这个是 leetcode 系列，所以重点是 4、5(对4再一次总结)。 为了照顾没有基础的小伙伴，会简单介绍一下1的基础理论。 简单介绍1，重点..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-08-30T18:54:20.000Z"}],["meta",{"property":"article:tag","content":"algorithm"}],["meta",{"property":"article:tag","content":"data-struct"}],["meta",{"property":"article:tag","content":"topics"}],["meta",{"property":"article:tag","content":"leetcode"}],["meta",{"property":"article:tag","content":"sf"}],["meta",{"property":"article:published_time","content":"2020-06-08T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2025-08-30T18:54:20.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"leetcode 数组专题 力扣数据结构之数组-00-概览\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2020-06-08T00:00:00.000Z\\",\\"dateModified\\":\\"2025-08-30T18:54:20.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"老马啸西风\\",\\"url\\":\\"https://houbb.github.io\\"}]}"]]},"git":{"createdTime":1755499309000,"updatedTime":1756580060000,"contributors":[{"name":"binbin.hou","username":"","email":"binbin.hou@huifu.com","commits":2},{"name":"bbhou","username":"bbhou","email":"1557740299@qq.com","commits":2,"url":"https://github.com/bbhou"}]},"readingTime":{"minutes":9.92,"words":2977},"filePathRelative":"posts/leetcode/top-100-liked/array/2020-06-06-algorithm-000-leetcode-data-struct-001-array-00-overview.md","localizedDate":"2020年6月8日","excerpt":"\\n<p>大家好，我是老马。</p>\\n<p>今天我们一起来学习一下数组这种数据结构。</p>\\n<h2>主要知识</h2>\\n<p>数组需要拆分下面几个部分：</p>\\n<ol>\\n<li>\\n<p>理论介绍</p>\\n</li>\\n<li>\\n<p>源码分析</p>\\n</li>\\n<li>\\n<p>数据结构实现？</p>\\n</li>\\n<li>\\n<p>题目练习（按照算法思想分类）</p>\\n</li>\\n<li>\\n<p>梳理对应的 sdk 包</p>\\n</li>\\n<li>\\n<p>应用实战</p>\\n</li>\\n</ol>\\n<p>因为这个是 leetcode 系列，所以重点是 4、5(对4再一次总结)。</p>\\n<p>为了照顾没有基础的小伙伴，会简单介绍一下1的基础理论。</p>","autoDesc":true}');export{h as comp,p as data};
