import{_ as s}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as t,a as i,o as e}from"./app-aeBU5i96.js";const h={};function n(l,a){return e(),t("div",null,a[0]||(a[0]=[i(`<h1 id="拓展阅读" tabindex="-1"><a class="header-anchor" href="#拓展阅读"><span>拓展阅读</span></a></h1><p><a href="https://houbb.github.io/2018/08/13/consistent-hash" target="_blank" rel="noopener noreferrer">一致性 hash 算法</a></p><p><a href="https://houbb.github.io/2018/05/30/hash-impl" target="_blank" rel="noopener noreferrer">java hash 实现</a></p><p><a href="https://houbb.github.io/2018/05/30/hash-conflict" target="_blank" rel="noopener noreferrer">hash 冲突处理</a></p><p><a href="https://houbb.github.io/2018/12/05/bloom-filter" target="_blank" rel="noopener noreferrer">bloom filter</a></p><p><a href="https://houbb.github.io/2019/04/01/BloomFilter-best-practice" target="_blank" rel="noopener noreferrer">bloom filter 使用最佳实践，让你少采坑！</a></p><h1 id="todo" tabindex="-1"><a class="header-anchor" href="#todo"><span>todo</span></a></h1><p>sdk 包的封装+文档</p><h1 id="chat" tabindex="-1"><a class="header-anchor" href="#chat"><span>chat</span></a></h1><h1 id="详细介绍一下-hashmap" tabindex="-1"><a class="header-anchor" href="#详细介绍一下-hashmap"><span>详细介绍一下 HashMap</span></a></h1><p>好的，我们这就来详细讲讲 Java 中的核心数据结构之一：<strong><code>HashMap</code></strong>。</p><p>它是基于哈希表实现的一个**键值对（Key-Value）**结构，是 Java 最常用的数据结构之一。</p><hr><h2 id="✅-一句话总结" tabindex="-1"><a class="header-anchor" href="#✅-一句话总结"><span>✅ 一句话总结</span></a></h2><blockquote><p><code>HashMap</code> 是一个根据 key 的 <code>hashCode()</code> 值快速存取 value 的集合，底层用 <strong>数组 + 链表 + 红黑树</strong> 实现，<strong>时间复杂度接近 O(1)</strong>。</p></blockquote><hr><h2 id="🧠-核心特性" tabindex="-1"><a class="header-anchor" href="#🧠-核心特性"><span>🧠 核心特性</span></a></h2><table><thead><tr><th>特性</th><th>说明</th></tr></thead><tbody><tr><td>非线程安全</td><td>多线程用 <code>ConcurrentHashMap</code></td></tr><tr><td>key/value 都允许为 null</td><td>但只能有一个 null key</td></tr><tr><td>无序</td><td>插入顺序不被保证（不同于 <code>LinkedHashMap</code>）</td></tr><tr><td>基于哈希表实现</td><td>查询、插入快，冲突时通过链表或红黑树处理</td></tr></tbody></table><hr><h2 id="🔧-底层结构概览" tabindex="-1"><a class="header-anchor" href="#🔧-底层结构概览"><span>🔧 底层结构概览</span></a></h2><p>Java 8 以后，<code>HashMap</code> 的底层结构是：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>数组（table） + 链表（Node） + 红黑树（TreeNode）</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>HashMap</span></span>
<span class="line"><span>  └── Node[] table   ← hash后定位桶</span></span>
<span class="line"><span>           ↓</span></span>
<span class="line"><span>       每个桶要么是：</span></span>
<span class="line"><span>       - null（没有元素）</span></span>
<span class="line"><span>       - Node（链表结构）</span></span>
<span class="line"><span>       - TreeNode（红黑树结构）</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr><h2 id="🔢-关键参数" tabindex="-1"><a class="header-anchor" href="#🔢-关键参数"><span>🔢 关键参数</span></a></h2><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>初始容量（default 16）</td><td>创建时桶数组大小（可以调整）</td></tr><tr><td>加载因子（load factor，默认 0.75）</td><td>决定扩容时机（负载阈值）</td></tr><tr><td>阈值（threshold）</td><td>等于 <code>容量 * 加载因子</code>，超了就扩容</td></tr><tr><td>树化阈值（TREEIFY_THRESHOLD=8）</td><td>桶中链表长度 ≥ 8 时会转成红黑树</td></tr><tr><td>退化阈值（UNTREEIFY_THRESHOLD=6）</td><td>树中节点少于6时退回链表</td></tr></tbody></table><hr><h2 id="🧮-常见操作实现原理" tabindex="-1"><a class="header-anchor" href="#🧮-常见操作实现原理"><span>🧮 常见操作实现原理</span></a></h2><h3 id="_1-put-k-key-v-value-–-添加键值对" tabindex="-1"><a class="header-anchor" href="#_1-put-k-key-v-value-–-添加键值对"><span>1. <code>put(K key, V value)</code> – 添加键值对</span></a></h3><ul><li><p>调用 <code>key.hashCode()</code> 计算哈希值。</p></li><li><p>用 <code>(hash &amp; (table.length - 1))</code> 定位桶索引。</p></li><li><p>冲突情况：</p><ul><li><p>桶为空 → 插入新节点</p></li><li><p>桶已有：</p><ul><li>判断是否相同 key（通过 equals），相同就覆盖</li><li>不同 key → 链表追加 → 超过 8 个转为红黑树</li></ul></li></ul></li></ul><p>📌 <strong>为什么用 <code>(hash &amp; (length - 1)</code> 而不是 <code>%</code>？</strong></p><ul><li>位运算比 <code>%</code> 运算快。</li><li>前提：length 是 2 的幂。</li></ul><hr><h3 id="_2-get-object-key-–-获取-value" tabindex="-1"><a class="header-anchor" href="#_2-get-object-key-–-获取-value"><span>2. <code>get(Object key)</code> – 获取 value</span></a></h3><ul><li>计算 key 的哈希值 → 定位桶。</li><li>如果是链表，就按链表遍历。</li><li>如果是红黑树，用红黑树查找。</li></ul><p>时间复杂度：</p><table><thead><tr><th>结构</th><th>查找复杂度</th></tr></thead><tbody><tr><td>数组</td><td>O(1)</td></tr><tr><td>链表</td><td>O(n)</td></tr><tr><td>红黑树</td><td>O(logn)</td></tr></tbody></table><hr><h3 id="_3-remove-object-key-–-删除元素" tabindex="-1"><a class="header-anchor" href="#_3-remove-object-key-–-删除元素"><span>3. <code>remove(Object key)</code> – 删除元素</span></a></h3><ul><li>跟 <code>get()</code> 类似：先找到 key 所在的桶和节点，再把它从链表/红黑树中断开。</li></ul><hr><h3 id="_4-扩容-resize" tabindex="-1"><a class="header-anchor" href="#_4-扩容-resize"><span>4. 扩容（resize）</span></a></h3><ul><li>当实际元素数量超过阈值（threshold）时，就要扩容。</li><li>默认每次扩容为原来的<strong>2倍</strong>。</li><li>所有元素要<strong>重新计算 hash、重新分配桶位</strong>，代价很高。</li></ul><hr><h2 id="🌳-链表-vs-红黑树的转换条件-java-8" tabindex="-1"><a class="header-anchor" href="#🌳-链表-vs-红黑树的转换条件-java-8"><span>🌳 链表 vs 红黑树的转换条件（Java 8）</span></a></h2><table><thead><tr><th>条件</th><th>动作</th></tr></thead><tbody><tr><td>链表长度 ≥ 8 且桶数组长度 ≥ 64</td><td>链表 → 红黑树</td></tr><tr><td>树节点数量 &lt; 6</td><td>红黑树 → 链表</td></tr></tbody></table><p>这样做的好处是：在 hash 冲突多时，避免链表过长影响性能。</p><hr><h2 id="🧪-示例代码演示" tabindex="-1"><a class="header-anchor" href="#🧪-示例代码演示"><span>🧪 示例代码演示</span></a></h2><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">Map</span><span style="--shiki-light:#E45649;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">String</span><span style="--shiki-light:#E45649;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> String</span><span style="--shiki-light:#E45649;--shiki-dark:#ABB2BF;">&gt;</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> map </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> HashMap</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&lt;&gt;</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">()</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">map</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">put</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;name&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;Alice&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">map</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">put</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;job&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;Developer&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">System</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">out</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">println</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">map</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">get</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;name&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">));</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // Alice</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">map</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">put</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;name&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;Bob&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // 覆盖旧值</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">System</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">out</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">println</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">map</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">get</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;name&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">));</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // Bob</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr><h2 id="🚩-为什么-hashmap-不是线程安全的" tabindex="-1"><a class="header-anchor" href="#🚩-为什么-hashmap-不是线程安全的"><span>🚩 为什么 HashMap 不是线程安全的？</span></a></h2><p>多个线程同时操作时：</p><ul><li>比如同时执行 put，可能同时扩容、覆盖同一个桶 → 会造成数据错乱、死循环。</li></ul><p>👉 解决方案：</p><ul><li>使用 <code>Collections.synchronizedMap(new HashMap&lt;&gt;())</code></li><li>更推荐用：<strong><code>ConcurrentHashMap</code></strong>（支持更高并发）</li></ul><hr><h2 id="🚨-面试高频问题小结" tabindex="-1"><a class="header-anchor" href="#🚨-面试高频问题小结"><span>🚨 面试高频问题小结</span></a></h2><table><thead><tr><th>问题</th><th>简要回答</th></tr></thead><tbody><tr><td>HashMap 底层结构是什么？</td><td>数组 + 链表 + 红黑树</td></tr><tr><td>为何数组长度是 2 的幂？</td><td>便于 <code>(hash &amp; (length - 1))</code> 快速取模</td></tr><tr><td>HashMap 和 Hashtable 区别？</td><td>前者非线程安全，后者线程安全但效率低</td></tr><tr><td>Java 8 对 HashMap 做了哪些优化？</td><td>链表超过阈值后转红黑树，提升冲突性能</td></tr><tr><td>HashMap 线程不安全表现？</td><td>并发 put 时可能覆盖、丢数据、死循环等</td></tr></tbody></table><hr><h2 id="📌-总结-hashmap-的优缺点" tabindex="-1"><a class="header-anchor" href="#📌-总结-hashmap-的优缺点"><span>📌 总结：HashMap 的优缺点</span></a></h2><table><thead><tr><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>查询快 O(1)</td><td>并发不安全</td></tr><tr><td>key/value 灵活</td><td>可能哈希冲突、扩容代价高</td></tr><tr><td>自动扩容/树化优化</td><td>红黑树查找效率没有数组快</td></tr></tbody></table><hr><p>如果你想我带你画一个 HashMap 动态插入或扩容的图、或者解析下源码中 <code>putVal()</code>、<code>resize()</code> 方法的实现细节，我也可以继续展开 😄 是否需要继续深入？</p>`,64)]))}const p=s(h,[["render",n]]),o=JSON.parse('{"path":"/posts/algorithm/hash/2018-05-30-hash-12-chat-hash-data-struct-hashmap.html","title":"Hash-12-聊一聊哈希数据结构之 HashMap","lang":"zh-CN","frontmatter":{"title":"Hash-12-聊一聊哈希数据结构之 HashMap","date":"2018-05-30T00:00:00.000Z","categories":["Algorithm"],"tags":["algorithm","hash","hashing"],"published":true,"description":"拓展阅读 一致性 hash 算法 java hash 实现 hash 冲突处理 bloom filter bloom filter 使用最佳实践，让你少采坑！ todo sdk 包的封装+文档 chat 详细介绍一下 HashMap 好的，我们这就来详细讲讲 Java 中的核心数据结构之一：HashMap。 它是基于哈希表实现的一个**键值对（Key-...","head":[["meta",{"property":"og:url","content":"https://houbb.github.io/leetcode-notes/posts/algorithm/hash/2018-05-30-hash-12-chat-hash-data-struct-hashmap.html"}],["meta",{"property":"og:site_name","content":"老马啸西风"}],["meta",{"property":"og:title","content":"Hash-12-聊一聊哈希数据结构之 HashMap"}],["meta",{"property":"og:description","content":"拓展阅读 一致性 hash 算法 java hash 实现 hash 冲突处理 bloom filter bloom filter 使用最佳实践，让你少采坑！ todo sdk 包的封装+文档 chat 详细介绍一下 HashMap 好的，我们这就来详细讲讲 Java 中的核心数据结构之一：HashMap。 它是基于哈希表实现的一个**键值对（Key-..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-08-23T04:59:26.000Z"}],["meta",{"property":"article:tag","content":"algorithm"}],["meta",{"property":"article:tag","content":"hash"}],["meta",{"property":"article:tag","content":"hashing"}],["meta",{"property":"article:published_time","content":"2018-05-30T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2025-08-23T04:59:26.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Hash-12-聊一聊哈希数据结构之 HashMap\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2018-05-30T00:00:00.000Z\\",\\"dateModified\\":\\"2025-08-23T04:59:26.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"老马啸西风\\",\\"url\\":\\"https://houbb.github.io\\"}]}"]]},"git":{"createdTime":1755925166000,"updatedTime":1755925166000,"contributors":[{"name":"bbhou","username":"bbhou","email":"1557740299@qq.com","commits":1,"url":"https://github.com/bbhou"}]},"readingTime":{"minutes":3.61,"words":1082},"filePathRelative":"posts/algorithm/hash/2018-05-30-hash-12-chat-hash-data-struct-hashmap.md","localizedDate":"2018年5月30日","excerpt":"\\n<p><a href=\\"https://houbb.github.io/2018/08/13/consistent-hash\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">一致性 hash 算法</a></p>\\n<p><a href=\\"https://houbb.github.io/2018/05/30/hash-impl\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">java hash 实现</a></p>\\n<p><a href=\\"https://houbb.github.io/2018/05/30/hash-conflict\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">hash 冲突处理</a></p>","autoDesc":true}');export{p as comp,o as data};
