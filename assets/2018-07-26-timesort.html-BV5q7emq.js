import{_ as i}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as s,a,o as n}from"./app-DBrlZJhV.js";const t={};function r(o,e){return n(),s("div",null,e[0]||(e[0]=[a(`<h1 id="time-sort" tabindex="-1"><a class="header-anchor" href="#time-sort"><span>Time Sort</span></a></h1><p>Timsort: A very fast , <code>O(n log n)</code>, stable sorting algorithm built for the real world — not constructed in academia.</p><h2 id="算法简介" tabindex="-1"><a class="header-anchor" href="#算法简介"><span>算法简介</span></a></h2><p>Timsort 是一种对真实数据有效的排序算法，而不是在学术实验室中创建的。</p><p>Tim Peters在2001年为Python编程语言创建了Timsort。Timsort首先分析它要排序的列表，然后根据列表的分析选择一种方法。</p><p>自从该算法被发明以来，它在Python、Java、Android平台和GNU Octave中被用作默认的排序算法。</p><p>Timsort的大O符号是O(n log n)，为了学习大O符号，<a href="https://hackernoon.com/you-need-to-understand-big-o-notation-now-4ada3d2ec93a" target="_blank" rel="noopener noreferrer">请阅读它</a>。</p><h2 id="具体" tabindex="-1"><a class="header-anchor" href="#具体"><span>具体</span></a></h2><p>Timsort的排序时间与 <code>Mergesort</code>(归并排序) 一样，比大多数其他类型的排序都要快。</p><p>Timsort 实际上使用了插入排序和归并排序，您很快就会看到。</p><p>Peters设计了Timsort以使用在大多数现实世界的数据集中存在的已经有序的元素。</p><p>它将这些已经有序的元素称为“自然运行”。它迭代数据，将元素收集到运行中，并同时将这些运行合并到一个运行中。</p><h2 id="插入元素低于-64-个" tabindex="-1"><a class="header-anchor" href="#插入元素低于-64-个"><span>插入元素低于 64 个</span></a></h2><p>如果我们要排序的数组中元素少于64个，Timsort将执行<strong>插入排序</strong>。</p><p>插入排序是对小列表最有效的简单排序。在更大的列表中，它的速度很慢，但在小列表中却非常快。</p><p>插入排序的概念如下:</p><ul><li><p>逐个查看元素</p></li><li><p>通过在正确的位置插入元素来建立排序列表</p></li></ul><h3 id="例子" tabindex="-1"><a class="header-anchor" href="#例子"><span>例子</span></a></h3><ul><li>待排序数组</li></ul><p><code>[34, 10, 64, 51, 32, 21]</code></p><ul><li>具体排序过程</li></ul><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>[34, 10, 64, 51, 32, 21]</span></span>
<span class="line"><span>[10, 34, 64, 51, 32, 21]</span></span>
<span class="line"><span>[10, 34, 51, 64, 32, 21]</span></span>
<span class="line"><span>[10, 34, 51, 64, 32, 21]</span></span>
<span class="line"><span>[10, 32, 34, 51, 64, 21]</span></span>
<span class="line"><span>[10, 21, 32, 34, 51, 64]</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="排序元素超过-64-个" tabindex="-1"><a class="header-anchor" href="#排序元素超过-64-个"><span>排序元素超过 64 个</span></a></h2><p>如果列表大于64个元素，算法将首先遍历列表，查找严格递增或递减的部分。</p><p>如果这个部分是递减的，它就会反转这个部分。</p><ul><li>递减</li></ul><p>所以如果运行是递减的，它会是这样的(运行在粗体中):</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>[3, 2, 1, 9, 17, 34]</span></span>
<span class="line"><span>[1, 2, 3, 9, 17, 34]</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>非递减</li></ul><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>[2, 3, 4, 17, 94]</span></span>
<span class="line"><span>[2, 3, 4, 17, 94]</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>ps: 图示主要指数组前 3 个元素(严格递增或递减的部分)？</p><p>minrun 是根据数组的大小确定的大小。</p><p>算法选择它，以便在一个随机数组中大多数运行的长度是或变成minrun。当运行次数等于或略小于2次幂时，合并2个数组会更有效。</p><p>Timsort选择minrun以确保这种效率，方法是<strong>确保minrun等于或小于2的幂</strong>。</p><p>算法选择minrun范围为32到64(含)。它选择minrun，使原始数组的长度除以minrun，等于或略小于2的幂。</p><p>如果运行的长度小于minrun，则计算从minrun运行的长度。使用这个新数字，您可以在运行之前获取许多项，并执行插入排序以创建新的运行。</p><p>如果minrun是63，运行的长度是33，那么 <code>63 - 33 = 30</code>。</p><p>然后从运行结束前获取30个元素，这是来自运行[33]的30个项目，然后执行插入排序以创建新的运行。</p><p>在这部分完成之后，我们现在应该有一堆排序的运行在列表中。</p><h1 id="merge-归并" tabindex="-1"><a class="header-anchor" href="#merge-归并"><span>Merge (归并)</span></a></h1><p>Timsort现在执行归并排序来合并运行。但是，Timsort确保在合并排序时保持稳定和合并平衡。</p><p>为了保持稳定，我们不应该交换两个相等的数值。这不仅保持了它们在列表中的原始位置，而且使算法更快。我们将很快讨论合并平衡。</p><p>当Timsort发现运行时，它将它们添加到堆栈中。一个简单的堆栈是这样的:</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>a</span></span>
<span class="line"><span></span></span>
<span class="line"><span>b</span></span>
<span class="line"><span></span></span>
<span class="line"><span>c</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>想象一堆盘子。你不能从底部取盘子，所以你必须从顶部取。堆栈也是如此。</p><p>Timsort试图在归并排序运行时平衡两个相互竞争的需求。</p><p>一方面，我们希望尽可能地推迟合并，以便利用稍后可能出现的模式。</p><p>但我们更希望尽快进行合并，以利用刚才发现的运行仍然在内存层次结构中较高的运行。</p><p>我们也不能延迟合并“太长”，因为它消耗内存来记住仍然没有合并的运行，并且堆栈有一个固定的大小。</p><p>为了确保我们有这个妥协，Timsort跟踪栈上最近的三个项目，并创建两个必须符合这些项目的规则:</p><ol><li><p>A &gt; B+C</p></li><li><p>B &gt; C</p></li></ol><p>其中A、B和C是栈上最近的三个项目。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>What turned out to be a good compromise maintains two invariants on the stack entries, where A, B and C are the lengths of the three righmost not-yet merged slices. —— by Tim Peters</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>通常，合并不同长度的相邻运行是很困难的。更困难的是我们必须保持稳定。</p><p>为了解决这个问题，Timsort将临时内存放在一边。它将两个运行中的较小的(同时调用运行A和B)放入临时内存中。</p><h1 id="galloping-飞驰的" tabindex="-1"><a class="header-anchor" href="#galloping-飞驰的"><span>Galloping (飞驰的)</span></a></h1><p>当Timsort正在合并A和B时，它注意到一个运行已经连续多次“获胜”。</p><p>如果运行A由比运行B小得多的数组成，那么运行A会回到原来的位置。合并这两个运行将需要大量的工作来实现什么。</p><p>通常情况下，数据会有一些预先存在的内部结构。Timsort假设如果很多运行a的值都低于运行B的值，那么很可能a的值会继续小于B。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>A = [1,2,3,4]</span></span>
<span class="line"><span>B = [5,6,7,8]</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>Timsort然后将进入快速模式。Timsort不是检查 <code>[0]</code> 和 <code>b[0]</code>，<br> 而是对 <code>[0]</code> 中 <code>b[0]</code> 的适当位置进行二分查找(binary search)。</p><p>这样，Timsort就可以将a的整个部分移动到合适的位置。</p><p>然后Timsort在B中搜索 <code>[0]</code> 的适当位置，Timsort就会同时移动 B 的整个部分，并将其放到合适的位置。</p><p>让我们来看看这个。Timsort检查 <code>B[0]</code> (即5)并使用二进制搜索查找a中的正确位置。</p><p><code>B[0]</code> 属于A的后面，Timsort检查 <code>[0]</code> (也就是1)在B的正确位置，所以我们要看看1在哪里。</p><p>这个数在 B 的开头，我们现在知道 B 在 A 的末尾，A 在 B 的开头。</p><p>如果 <code>B[0]</code> 的合适位置非常接近A的起点(反之亦然)，那么这个操作就不值得了。</p><p>另外，Timsort注意到了这一点，通过增加连续的 A-only 或 B-only 胜数来增加以后进入 gallop 模式的难度。</p><p>如果快速模式是值得的，Timsort让它更容易重新进入。</p><p>简而言之，Timsort做了两件事:</p><ul><li><p>具有预先存在的内部结构的数组的一致性</p></li><li><p>能够保持稳定的排序</p></li></ul><p>以前，为了实现稳定排序，您必须使用整数将列表中的项目压缩，并将其排序为元组数组。</p><h2 id="code-代码" tabindex="-1"><a class="header-anchor" href="#code-代码"><span>Code (代码)</span></a></h2><p>如果您对代码不感兴趣，可以跳过这一部分。</p><p><a href="https://github.com/python/cpython/blob/master/Objects/listobject.c" target="_blank" rel="noopener noreferrer">Timsort 源码地址</a></p><p>ps: 后面感兴趣，可以写一个 java 版本的。</p><h1 id="拓展阅读" tabindex="-1"><a class="header-anchor" href="#拓展阅读"><span>拓展阅读</span></a></h1><p><a href="https://houbb.github.io/2016/07/14/Sort" target="_blank" rel="noopener noreferrer">基础排序算法</a></p><p><a href="https://houbb.github.io/2018/10/25/guava-group-sort" target="_blank" rel="noopener noreferrer">Guava sort</a></p><h1 id="参考资料" tabindex="-1"><a class="header-anchor" href="#参考资料"><span>参考资料</span></a></h1><p><a href="https://hackernoon.com/timsort-the-fastest-sorting-algorithm-youve-never-heard-of-36b28417f399" target="_blank" rel="noopener noreferrer">https://hackernoon.com/timsort-the-fastest-sorting-algorithm-youve-never-heard-of-36b28417f399</a></p><p><a href="https://mp.weixin.qq.com/s/gBHmBLGILd6rZ-6cuelw0Q" target="_blank" rel="noopener noreferrer">这可能是你听说过最快的稳定排序算法</a></p>`,82)]))}const d=i(t,[["render",r]]),h=JSON.parse('{"path":"/posts/leetcode/sorts/2018-07-26-timesort.html","title":"Time Sort","lang":"zh-CN","frontmatter":{"title":"Time Sort","date":"2018-07-26T00:00:00.000Z","categories":["Algorithm"],"tags":["algorithm","sort"],"published":true,"description":"Time Sort Timsort: A very fast , O(n log n), stable sorting algorithm built for the real world — not constructed in academia. 算法简介 Timsort 是一种对真实数据有效的排序算法，而不是在学术实验室中创建的。 Tim Pet...","head":[["meta",{"property":"og:url","content":"https://houbb.github.io/leetcode-notes/posts/leetcode/sorts/2018-07-26-timesort.html"}],["meta",{"property":"og:site_name","content":"老马啸西风"}],["meta",{"property":"og:title","content":"Time Sort"}],["meta",{"property":"og:description","content":"Time Sort Timsort: A very fast , O(n log n), stable sorting algorithm built for the real world — not constructed in academia. 算法简介 Timsort 是一种对真实数据有效的排序算法，而不是在学术实验室中创建的。 Tim Pet..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-08-23T04:59:26.000Z"}],["meta",{"property":"article:tag","content":"algorithm"}],["meta",{"property":"article:tag","content":"sort"}],["meta",{"property":"article:published_time","content":"2018-07-26T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2025-08-23T04:59:26.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Time Sort\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2018-07-26T00:00:00.000Z\\",\\"dateModified\\":\\"2025-08-23T04:59:26.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"老马啸西风\\",\\"url\\":\\"https://houbb.github.io\\"}]}"]]},"git":{"createdTime":1755925166000,"updatedTime":1755925166000,"contributors":[{"name":"bbhou","username":"bbhou","email":"1557740299@qq.com","commits":1,"url":"https://github.com/bbhou"}]},"readingTime":{"minutes":6.36,"words":1909},"filePathRelative":"posts/leetcode/sorts/2018-07-26-timesort.md","localizedDate":"2018年7月26日","excerpt":"\\n<p>Timsort: A very fast , <code>O(n log n)</code>, stable sorting algorithm built for the real world — not constructed in academia.</p>\\n<h2>算法简介</h2>\\n<p>Timsort 是一种对真实数据有效的排序算法，而不是在学术实验室中创建的。</p>\\n<p>Tim Peters在2001年为Python编程语言创建了Timsort。Timsort首先分析它要排序的列表，然后根据列表的分析选择一种方法。</p>\\n<p>自从该算法被发明以来，它在Python、Java、Android平台和GNU Octave中被用作默认的排序算法。</p>","autoDesc":true}');export{d as comp,h as data};
