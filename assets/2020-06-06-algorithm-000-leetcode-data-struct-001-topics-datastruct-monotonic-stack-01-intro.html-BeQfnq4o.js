import{_ as s}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as a,a as t,o as n}from"./app-BFHuJZDu.js";const e={};function h(l,i){return n(),a("div",null,i[0]||(i[0]=[t(`<h1 id="数组" tabindex="-1"><a class="header-anchor" href="#数组"><span>数组</span></a></h1><p>大家好，我是老马。</p><p>今天我们一起来学习一下数组这种数据结构。</p><h2 id="主要知识" tabindex="-1"><a class="header-anchor" href="#主要知识"><span>主要知识</span></a></h2><p>数组需要拆分下面几个部分：</p><ol><li><p>理论介绍</p></li><li><p>源码分析</p></li><li><p>数据结构实现？</p></li><li><p>题目练习（按照算法思想分类）</p></li><li><p>梳理对应的 sdk 包</p></li><li><p>应用实战</p></li></ol><p>因为这个是 leetcode 系列，所以重点是 4、5(对4再一次总结)。</p><p>为了照顾没有基础的小伙伴，会简单介绍一下1的基础理论。</p><p>简单介绍1，重点为4。其他不是本系列的重点。</p><h1 id="数据结构篇" tabindex="-1"><a class="header-anchor" href="#数据结构篇"><span>数据结构篇</span></a></h1><h2 id="通用基础" tabindex="-1"><a class="header-anchor" href="#通用基础"><span>通用基础</span></a></h2><p>链表</p><p>树</p><p>哈希表</p><p>stack 栈</p><p>queue 队列</p><p>ordered set 有序集合</p><p>heap 堆</p><p>graph 图</p><h2 id="进阶" tabindex="-1"><a class="header-anchor" href="#进阶"><span>进阶</span></a></h2><p>并查集</p><p>字典树</p><p>线段树</p><p>树状数组</p><p>后缀数组</p><h1 id="chat" tabindex="-1"><a class="header-anchor" href="#chat"><span>chat</span></a></h1><p><a href="https://leetcode.cn/studyplan/top-100-liked/" target="_blank" rel="noopener noreferrer">https://leetcode.cn/studyplan/top-100-liked/</a></p><h2 id="详细介绍一下力扣数据结构之-monotonic-stack" tabindex="-1"><a class="header-anchor" href="#详细介绍一下力扣数据结构之-monotonic-stack"><span>详细介绍一下力扣数据结构之 Monotonic Stack</span></a></h2><p>下面我会带你系统了解一下 LeetCode 中非常重要的数据结构技巧：<strong>单调栈（Monotonic Stack）</strong>，从概念到实战，一步步讲清楚。</p><hr><h2 id="🧠-一句话理解什么是单调栈" tabindex="-1"><a class="header-anchor" href="#🧠-一句话理解什么是单调栈"><span>🧠 一句话理解什么是单调栈？</span></a></h2><blockquote><p><strong>单调栈是一种栈结构，始终保持其中的元素“单调递增”或“单调递减”顺序，用于快速找到左/右侧第一个大于或小于当前元素的值或下标。</strong></p></blockquote><hr><h2 id="🧱-单调栈的结构和分类" tabindex="-1"><a class="header-anchor" href="#🧱-单调栈的结构和分类"><span>🧱 单调栈的结构和分类</span></a></h2><ul><li>按照 <strong>栈中元素的大小顺序</strong>，单调栈分为两种：</li></ul><table><thead><tr><th>类型</th><th>栈内顺序</th><th>用途</th></tr></thead><tbody><tr><td>单调递增栈</td><td>从栈底到栈顶：值越来越大</td><td>用于找“右边第一个更小的数”</td></tr><tr><td>单调递减栈</td><td>从栈底到栈顶：值越来越小</td><td>用于找“右边第一个更大的数”</td></tr></tbody></table><blockquote><p>📌 注意：“单调递增栈” 是用于找 <strong>更小值</strong>，因为遇到更小的值时才会出栈。</p></blockquote><hr><h2 id="👀-常见应用场景" tabindex="-1"><a class="header-anchor" href="#👀-常见应用场景"><span>👀 常见应用场景</span></a></h2><table><thead><tr><th>典型题型</th><th>LeetCode 题号</th><th>说明</th></tr></thead><tbody><tr><td>下一个更大元素</td><td>496、739、503</td><td>找右边第一个比它大的元素</td></tr><tr><td>栈中最大矩形</td><td>84</td><td>柱状图中最大矩形面积</td></tr><tr><td>最小栈问题</td><td>155</td><td>常见栈技巧</td></tr><tr><td>单调队列 / 单调栈综合</td><td>42、862</td><td>接雨水、滑动窗口</td></tr></tbody></table><hr><h2 id="🔁-单调栈的通用模板-以单调递增栈为例" tabindex="-1"><a class="header-anchor" href="#🔁-单调栈的通用模板-以单调递增栈为例"><span>🔁 单调栈的通用模板（以单调递增栈为例）</span></a></h2><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 用来存索引（为了能计算距离）</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">Deque</span><span style="--shiki-light:#E45649;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">Integer</span><span style="--shiki-light:#E45649;--shiki-dark:#ABB2BF;">&gt;</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> stack </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> ArrayDeque</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&lt;&gt;</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">()</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">for</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> (</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> i </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 0</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> i </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">&lt;</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> nums</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">length</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> i</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">++</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">) {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    while</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> (</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">!</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">stack</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">isEmpty</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">()</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> &amp;&amp;</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> nums[</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">stack</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">peek</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">()</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">] </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">&gt;</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> nums[i]) {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        int</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> topIndex </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> stack</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">pop</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">        // 可以在这里处理逻辑，比如更新左边/右边更小值</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">    }</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">    stack</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">push</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(i);</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr><h2 id="📘-示例题讲解-leetcode-739-每日温度" tabindex="-1"><a class="header-anchor" href="#📘-示例题讲解-leetcode-739-每日温度"><span>📘 示例题讲解：LeetCode 739. 每日温度</span></a></h2><blockquote><p>给定一个数组 <code>temperatures</code>，返回一个数组 <code>answer</code>，其中 <code>answer[i]</code> 表示第 i 天之后才会有更高温度的天数。如果没有更高温，填 0。</p></blockquote><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#C18401;--shiki-dark:#C678DD;"> int</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">[] </span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">dailyTemperatures</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(</span><span style="--shiki-light:#C18401;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">[] temperatures) {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    int</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> n </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> temperatures</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">length</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#C678DD;">    int</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">[] res </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#C18401;--shiki-dark:#C678DD;"> int</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">[n]</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">    Deque</span><span style="--shiki-light:#E45649;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">Integer</span><span style="--shiki-light:#E45649;--shiki-dark:#ABB2BF;">&gt;</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> stack </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> ArrayDeque</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&lt;&gt;</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">()</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    for</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> (</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> i </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 0</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> i </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">&lt;</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> n</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> i</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">++</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">) {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        while</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> (</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">!</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">stack</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">isEmpty</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">()</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> &amp;&amp;</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> temperatures[i] </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">&gt;</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> temperatures[</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">stack</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">peek</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">()</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">]) {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">            int</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> prevIndex </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> stack</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">pop</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">            res[prevIndex] </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> i </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">-</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> prevIndex</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // 当前温度比栈顶高，计算间隔</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">        }</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">        stack</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">push</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(i);</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // 栈存的是下标</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    return</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> res</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="✅-理解点" tabindex="-1"><a class="header-anchor" href="#✅-理解点"><span>✅ 理解点：</span></a></h3><ul><li>栈里始终是「温度递减」的下标。</li><li>一旦遇到更高温度，就开始“清算”。</li></ul><hr><h2 id="🔍-单调栈-vs-普通栈" tabindex="-1"><a class="header-anchor" href="#🔍-单调栈-vs-普通栈"><span>🔍 单调栈 vs 普通栈</span></a></h2><table><thead><tr><th>项目</th><th>普通栈</th><th>单调栈</th></tr></thead><tbody><tr><td>目的</td><td>后进先出</td><td>维护单调序</td></tr><tr><td>应用</td><td>通用场景</td><td>查找“左右第一个更大/小的值”</td></tr><tr><td>出栈条件</td><td>无条件 pop</td><td>满足单调性被破坏才 pop</td></tr></tbody></table><hr><h2 id="🧠-单调栈常见变种" tabindex="-1"><a class="header-anchor" href="#🧠-单调栈常见变种"><span>🧠 单调栈常见变种</span></a></h2><ul><li><strong>维护值</strong>：直接将 <code>nums[i]</code> 入栈（适合不需要索引）</li><li><strong>维护索引</strong>：将 <code>i</code> 入栈（适合需要计算间隔距离）</li><li><strong>哨兵技巧</strong>：数组首尾加 0 或 ∞，避免边界处理</li><li><strong>双向遍历</strong>：处理左边和右边第一个更大/更小值</li></ul><hr><h2 id="🧪-小练习题推荐" tabindex="-1"><a class="header-anchor" href="#🧪-小练习题推荐"><span>🧪 小练习题推荐</span></a></h2><table><thead><tr><th>题目</th><th>说明</th></tr></thead><tbody><tr><td>LeetCode 496. Next Greater Element I</td><td>单调栈基础</td></tr><tr><td>LeetCode 503. Next Greater Element II</td><td>循环数组</td></tr><tr><td>LeetCode 84. Largest Rectangle in Histogram</td><td>单调栈经典题</td></tr><tr><td>LeetCode 42. Trapping Rain Water</td><td>单调栈 + 双指针技巧结合</td></tr></tbody></table><hr><h2 id="🔚-总结" tabindex="-1"><a class="header-anchor" href="#🔚-总结"><span>🔚 总结</span></a></h2><p>单调栈的核心价值在于：</p><ul><li>快速找出某个元素左右第一个大于/小于它的元素</li><li>用于处理那些「相对大小有要求」的区间问题</li><li>一般时间复杂度是 O(n)，因为每个元素最多只进栈和出栈一次</li></ul><h2 id="我日常使用-java-是不是可以用优先级队列替代" tabindex="-1"><a class="header-anchor" href="#我日常使用-java-是不是可以用优先级队列替代"><span>我日常使用 java 是不是可以用优先级队列替代</span></a></h2><p>你问得非常好！我们来认真比较一下：<strong>日常使用 Java 时，能不能用优先级队列（PriorityQueue）来替代单调栈？</strong></p><p>先给出结论：</p><hr><h2 id="🧾-简明结论" tabindex="-1"><a class="header-anchor" href="#🧾-简明结论"><span>🧾 简明结论：</span></a></h2><blockquote><p><strong>不能互相替代。优先级队列和单调栈是两种</strong>核心目标不同<strong>的数据结构。</strong></p></blockquote><hr><h2 id="✅-为什么不能替代" tabindex="-1"><a class="header-anchor" href="#✅-为什么不能替代"><span>✅ 为什么不能替代？</span></a></h2><h3 id="📌-1-功能不同" tabindex="-1"><a class="header-anchor" href="#📌-1-功能不同"><span>📌 1. 功能不同</span></a></h3><table><thead><tr><th>数据结构</th><th>核心用途</th><th>支持操作</th><th>特点</th></tr></thead><tbody><tr><td>单调栈</td><td>维护元素单调递增/递减</td><td>查找左/右第一个更大/更小元素</td><td>位置敏感，顺序相关</td></tr><tr><td>优先队列</td><td>维护元素整体最大/最小值</td><td>快速取最大/最小值</td><td>与顺序无关，只在意大小</td></tr></tbody></table><hr><h3 id="📌-2-举例说明-用错就错" tabindex="-1"><a class="header-anchor" href="#📌-2-举例说明-用错就错"><span>📌 2. 举例说明（用错就错）</span></a></h3><h4 id="👉-示例一-leetcode-739-每日温度-找右边第一个更高温度" tabindex="-1"><a class="header-anchor" href="#👉-示例一-leetcode-739-每日温度-找右边第一个更高温度"><span>👉 示例一：LeetCode 739 每日温度（找右边第一个更高温度）</span></a></h4><p>你用<strong>单调栈</strong>：</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">Deque</span><span style="--shiki-light:#E45649;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">Integer</span><span style="--shiki-light:#E45649;--shiki-dark:#ABB2BF;">&gt;</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> stack </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> ArrayDeque</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&lt;&gt;</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">()</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><ul><li>维护的是下标的<strong>相对顺序</strong></li><li>一旦当前温度比栈顶高 → 出栈并计算「距离」</li></ul><p>你如果用 <strong>PriorityQueue</strong>：</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">PriorityQueue</span><span style="--shiki-light:#E45649;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">Integer</span><span style="--shiki-light:#E45649;--shiki-dark:#ABB2BF;">&gt;</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> pq </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> PriorityQueue</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&lt;&gt;</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">()</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><ul><li>只能拿到<strong>最小/最大温度</strong></li><li>根本无法知道「这个温度在原数组的哪个位置」</li></ul><p>📌 <strong>优先队列不保顺序、不支持左右关系 → 完全不适合做“左右第一个比我大/小”的问题！</strong></p><hr><h2 id="🔍-容易误用的场景对比" tabindex="-1"><a class="header-anchor" href="#🔍-容易误用的场景对比"><span>🔍 容易误用的场景对比</span></a></h2><table><thead><tr><th>目标</th><th>推荐结构</th><th>替代可能？</th></tr></thead><tbody><tr><td>找左右第一个更大/小</td><td>单调栈 ✅</td><td>❌</td></tr><tr><td>维护当前窗口最大/最小值</td><td>单调队列 ✅</td><td>优先队列 ❌（有延迟）</td></tr><tr><td>快速取最大/最小元素</td><td>优先队列 ✅</td><td>❌</td></tr><tr><td>找数组中第 K 大</td><td>优先队列 ✅</td><td>单调栈 ❌</td></tr><tr><td>维护滑动窗口最大值</td><td>单调队列 ✅</td><td>优先队列 ❌（需要懒删除）</td></tr></tbody></table><hr><h2 id="🧠-什么时候用单调栈-什么时候用-priorityqueue" tabindex="-1"><a class="header-anchor" href="#🧠-什么时候用单调栈-什么时候用-priorityqueue"><span>🧠 什么时候用单调栈，什么时候用 PriorityQueue？</span></a></h2><table><thead><tr><th>场景</th><th>用这个</th></tr></thead><tbody><tr><td>需要找“左边/右边第一个比我大/小” → 顺序敏感</td><td><strong>单调栈</strong></td></tr><tr><td>需要快速找到“当前所有值中的最大/最小值”</td><td><strong>PriorityQueue</strong></td></tr><tr><td>要找 top-K</td><td><strong>PriorityQueue</strong></td></tr><tr><td>要处理区间最大值 / 单调性优化</td><td><strong>单调队列 / 单调栈</strong></td></tr></tbody></table><hr><h2 id="🧪-实战建议" tabindex="-1"><a class="header-anchor" href="#🧪-实战建议"><span>🧪 实战建议</span></a></h2><p>你写代码时可以这样判断：</p><h3 id="❓-我想快速找到一个最大-最小值-→-✅-用-priorityqueue" tabindex="-1"><a class="header-anchor" href="#❓-我想快速找到一个最大-最小值-→-✅-用-priorityqueue"><span>❓“我想快速找到一个最大/最小值” → ✅ 用 <code>PriorityQueue</code></span></a></h3><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">PriorityQueue</span><span style="--shiki-light:#E45649;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">Integer</span><span style="--shiki-light:#E45649;--shiki-dark:#ABB2BF;">&gt;</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> minHeap </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> PriorityQueue</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&lt;&gt;</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">()</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // 最小堆</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">PriorityQueue</span><span style="--shiki-light:#E45649;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">Integer</span><span style="--shiki-light:#E45649;--shiki-dark:#ABB2BF;">&gt;</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> maxHeap </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> PriorityQueue</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&lt;&gt;</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">((a</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> b) </span><span style="--shiki-light:#C18401;--shiki-dark:#C678DD;">-&gt;</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> b </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">-</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> a)</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // 最大堆</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="❓-我想找一个值的左边-右边第一个比它大-小的数-→-✅-用单调栈" tabindex="-1"><a class="header-anchor" href="#❓-我想找一个值的左边-右边第一个比它大-小的数-→-✅-用单调栈"><span>❓“我想找一个值的左边/右边第一个比它大/小的数” → ✅ 用单调栈</span></a></h3><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">Deque</span><span style="--shiki-light:#E45649;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">Integer</span><span style="--shiki-light:#E45649;--shiki-dark:#ABB2BF;">&gt;</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> stack </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> ArrayDeque</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&lt;&gt;</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">()</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><hr><h2 id="🧭-总结一句话" tabindex="-1"><a class="header-anchor" href="#🧭-总结一句话"><span>🧭 总结一句话：</span></a></h2><blockquote><p><strong>优先级队列用于“全局最大最小”，单调栈用于“相邻关系判断”。</strong></p><p>二者无法互相替代，用错结构会导致逻辑错误、性能低下甚至题目做不出来。</p></blockquote>`,98)]))}const r=s(e,[["render",h]]),d=JSON.parse('{"path":"/posts/leetcode/topliked-100/data-struct/2020-06-06-algorithm-000-leetcode-data-struct-001-topics-datastruct-monotonic-stack-01-intro.html","title":"进阶数据结构篇专题之单调栈 Monotonic Stack","lang":"zh-CN","frontmatter":{"title":"进阶数据结构篇专题之单调栈 Monotonic Stack","date":"2020-06-08T00:00:00.000Z","categories":["TopLiked100"],"tags":["algorithm","data-struct","topics","leetcode","fenwick-tree","sf"],"published":true,"description":"数组 大家好，我是老马。 今天我们一起来学习一下数组这种数据结构。 主要知识 数组需要拆分下面几个部分： 理论介绍 源码分析 数据结构实现？ 题目练习（按照算法思想分类） 梳理对应的 sdk 包 应用实战 因为这个是 leetcode 系列，所以重点是 4、5(对4再一次总结)。 为了照顾没有基础的小伙伴，会简单介绍一下1的基础理论。 简单介绍1，重点...","head":[["meta",{"property":"og:url","content":"https://houbb.github.io/leetcode-notes/posts/leetcode/topliked-100/data-struct/2020-06-06-algorithm-000-leetcode-data-struct-001-topics-datastruct-monotonic-stack-01-intro.html"}],["meta",{"property":"og:site_name","content":"老马啸西风"}],["meta",{"property":"og:title","content":"进阶数据结构篇专题之单调栈 Monotonic Stack"}],["meta",{"property":"og:description","content":"数组 大家好，我是老马。 今天我们一起来学习一下数组这种数据结构。 主要知识 数组需要拆分下面几个部分： 理论介绍 源码分析 数据结构实现？ 题目练习（按照算法思想分类） 梳理对应的 sdk 包 应用实战 因为这个是 leetcode 系列，所以重点是 4、5(对4再一次总结)。 为了照顾没有基础的小伙伴，会简单介绍一下1的基础理论。 简单介绍1，重点..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-09-24T02:52:43.000Z"}],["meta",{"property":"article:tag","content":"algorithm"}],["meta",{"property":"article:tag","content":"data-struct"}],["meta",{"property":"article:tag","content":"topics"}],["meta",{"property":"article:tag","content":"leetcode"}],["meta",{"property":"article:tag","content":"fenwick-tree"}],["meta",{"property":"article:tag","content":"sf"}],["meta",{"property":"article:published_time","content":"2020-06-08T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2025-09-24T02:52:43.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"进阶数据结构篇专题之单调栈 Monotonic Stack\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2020-06-08T00:00:00.000Z\\",\\"dateModified\\":\\"2025-09-24T02:52:43.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"老马啸西风\\",\\"url\\":\\"https://houbb.github.io\\"}]}"]]},"git":{"createdTime":1755499309000,"updatedTime":1758682363000,"contributors":[{"name":"binbin.hou","username":"","email":"binbin.hou@huifu.com","commits":4},{"name":"bbhou","username":"bbhou","email":"1557740299@qq.com","commits":3,"url":"https://github.com/bbhou"}]},"readingTime":{"minutes":5.8,"words":1739},"filePathRelative":"posts/leetcode/topliked-100/data-struct/2020-06-06-algorithm-000-leetcode-data-struct-001-topics-datastruct-monotonic-stack-01-intro.md","localizedDate":"2020年6月8日","excerpt":"\\n<p>大家好，我是老马。</p>\\n<p>今天我们一起来学习一下数组这种数据结构。</p>\\n<h2>主要知识</h2>\\n<p>数组需要拆分下面几个部分：</p>\\n<ol>\\n<li>\\n<p>理论介绍</p>\\n</li>\\n<li>\\n<p>源码分析</p>\\n</li>\\n<li>\\n<p>数据结构实现？</p>\\n</li>\\n<li>\\n<p>题目练习（按照算法思想分类）</p>\\n</li>\\n<li>\\n<p>梳理对应的 sdk 包</p>\\n</li>\\n<li>\\n<p>应用实战</p>\\n</li>\\n</ol>\\n<p>因为这个是 leetcode 系列，所以重点是 4、5(对4再一次总结)。</p>\\n<p>为了照顾没有基础的小伙伴，会简单介绍一下1的基础理论。</p>","autoDesc":true}');export{r as comp,d as data};
