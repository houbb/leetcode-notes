import{_ as t}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as a,a as i,o as s}from"./app-CQ3qWz9M.js";const r={};function n(l,e){return s(),a("div",null,e[0]||(e[0]=[i(`<h1 id="数组" tabindex="-1"><a class="header-anchor" href="#数组"><span>数组</span></a></h1><p>大家好，我是老马。</p><p>今天我们一起来学习一下数组这种数据结构。</p><h2 id="主要知识" tabindex="-1"><a class="header-anchor" href="#主要知识"><span>主要知识</span></a></h2><p>数组需要拆分下面几个部分：</p><ol><li><p>理论介绍</p></li><li><p>源码分析</p></li><li><p>数据结构实现？</p></li><li><p>题目练习（按照算法思想分类）</p></li><li><p>梳理对应的 sdk 包</p></li><li><p>应用实战</p></li></ol><p>因为这个是 leetcode 系列，所以重点是 4、5(对4再一次总结)。</p><p>为了照顾没有基础的小伙伴，会简单介绍一下1的基础理论。</p><p>简单介绍1，重点为4。其他不是本系列的重点。</p><h1 id="chat" tabindex="-1"><a class="header-anchor" href="#chat"><span>chat</span></a></h1><h2 id="详细介绍一下力扣算法之动态规划" tabindex="-1"><a class="header-anchor" href="#详细介绍一下力扣算法之动态规划"><span>详细介绍一下力扣算法之动态规划</span></a></h2><p>动态规划（Dynamic Programming，简称 DP） 的完整入门与进阶指南，适合零基础或有一定经验但想系统梳理的你。</p><hr><h2 id="🔍-一、什么是动态规划" tabindex="-1"><a class="header-anchor" href="#🔍-一、什么是动态规划"><span>🔍 一、什么是动态规划？</span></a></h2><p>动态规划的核心思想是：</p><blockquote><p>将原问题拆分成若干子问题，保存（“记忆”）每个子问题的解，从而避免重复计算。</p></blockquote><p>通俗来说：</p><blockquote><p>把“重复子问题”的答案提前算好存起来，再一步步“拼接”出最终答案。</p></blockquote><h3 id="✅-具备以下几个特点的问题-适合用-dp" tabindex="-1"><a class="header-anchor" href="#✅-具备以下几个特点的问题-适合用-dp"><span>✅ 具备以下几个特点的问题，适合用 DP：</span></a></h3><table><thead><tr><th>特点</th><th>含义</th></tr></thead><tbody><tr><td>最优子结构</td><td>整体最优由局部最优决定</td></tr><tr><td>重叠子问题</td><td>子问题之间重复出现</td></tr><tr><td>状态转移方程</td><td>当前状态由前一状态转移而来</td></tr></tbody></table><hr><h2 id="🎯-二、dp-问题的常见分类-按状态和结构" tabindex="-1"><a class="header-anchor" href="#🎯-二、dp-问题的常见分类-按状态和结构"><span>🎯 二、DP 问题的常见分类（按状态和结构）</span></a></h2><p>我们可以从维度、场景两个方向分类：</p><h3 id="✅-1-按维度分类" tabindex="-1"><a class="header-anchor" href="#✅-1-按维度分类"><span>✅ 1. 按维度分类</span></a></h3><table><thead><tr><th>类型</th><th>举例题目</th><th>说明</th></tr></thead><tbody><tr><td>一维 DP</td><td><a href="https://leetcode.cn/problems/climbing-stairs/" target="_blank" rel="noopener noreferrer">70. 爬楼梯</a></td><td>dp[i] 表示第 i 步的方案数</td></tr><tr><td>二维 DP</td><td><a href="https://leetcode.cn/problems/longest-common-subsequence/" target="_blank" rel="noopener noreferrer">1143. 最长公共子序列</a></td><td>dp[i][j] 表示两个字符串前 i/j 个字符的匹配</td></tr><tr><td>状态压缩</td><td><a href="https://leetcode.cn/problems/house-robber/" target="_blank" rel="noopener noreferrer">198. 打家劫舍</a></td><td>用两个变量滚动存储</td></tr></tbody></table><hr><h3 id="✅-2-按题型场景分类" tabindex="-1"><a class="header-anchor" href="#✅-2-按题型场景分类"><span>✅ 2. 按题型场景分类</span></a></h3><h4 id="🧱-1-背包类" tabindex="-1"><a class="header-anchor" href="#🧱-1-背包类"><span>🧱 1）背包类</span></a></h4><ul><li><a href="https://leetcode.cn/problems/partition-equal-subset-sum/" target="_blank" rel="noopener noreferrer">416. 分割等和子集</a></li><li><a href="https://leetcode.cn/problems/ones-and-zeroes/" target="_blank" rel="noopener noreferrer">474. 一和零</a></li><li><a href="https://leetcode.cn/problems/coin-change-2/" target="_blank" rel="noopener noreferrer">518. 零钱兑换 II</a></li></ul><h4 id="🧩-2-字符串匹配类" tabindex="-1"><a class="header-anchor" href="#🧩-2-字符串匹配类"><span>🧩 2）字符串匹配类</span></a></h4><ul><li><a href="https://leetcode.cn/problems/longest-common-subsequence/" target="_blank" rel="noopener noreferrer">1143. 最长公共子序列</a></li><li><a href="https://leetcode.cn/problems/edit-distance/" target="_blank" rel="noopener noreferrer">72. 编辑距离</a></li><li><a href="https://leetcode.cn/problems/distinct-subsequences/" target="_blank" rel="noopener noreferrer">115. 不同的子序列</a></li></ul><h4 id="🏃-3-路径计数类" tabindex="-1"><a class="header-anchor" href="#🏃-3-路径计数类"><span>🏃 3）路径计数类</span></a></h4><ul><li><a href="https://leetcode.cn/problems/unique-paths/" target="_blank" rel="noopener noreferrer">62. 不同路径</a></li><li><a href="https://leetcode.cn/problems/minimum-path-sum/" target="_blank" rel="noopener noreferrer">64. 最小路径和</a></li><li><a href="https://leetcode.cn/problems/unique-paths-ii/" target="_blank" rel="noopener noreferrer">63. 不同路径 II（含障碍物）</a></li></ul><h4 id="🧠-4-区间类" tabindex="-1"><a class="header-anchor" href="#🧠-4-区间类"><span>🧠 4）区间类</span></a></h4><ul><li><a href="https://leetcode.cn/problems/burst-balloons/" target="_blank" rel="noopener noreferrer">312. 戳气球</a></li><li><a href="https://leetcode.cn/problems/minimum-cost-to-merge-stones/" target="_blank" rel="noopener noreferrer">1000. 合并石头的最低成本</a></li></ul><h4 id="🏠-5-选择取舍类" tabindex="-1"><a class="header-anchor" href="#🏠-5-选择取舍类"><span>🏠 5）选择取舍类</span></a></h4><ul><li><a href="https://leetcode.cn/problems/house-robber/" target="_blank" rel="noopener noreferrer">198. 打家劫舍</a></li><li><a href="https://leetcode.cn/problems/house-robber-ii/" target="_blank" rel="noopener noreferrer">213. 打家劫舍 II</a></li><li><a href="https://leetcode.cn/problems/delete-and-earn/" target="_blank" rel="noopener noreferrer">740. 删除并获得点数</a></li></ul><hr><h2 id="🧪-三、动态规划的五步通用套路-核心" tabindex="-1"><a class="header-anchor" href="#🧪-三、动态规划的五步通用套路-核心"><span>🧪 三、动态规划的五步通用套路（核心！）</span></a></h2><blockquote><p>一定要记住这个模板！几乎所有 DP 题都可以套进去。</p></blockquote><h3 id="🧩-第一步-定义状态-dp-i-或-dp-i-j" tabindex="-1"><a class="header-anchor" href="#🧩-第一步-定义状态-dp-i-或-dp-i-j"><span>🧩 第一步：定义状态 <code>dp[i]</code> 或 <code>dp[i][j]</code></span></a></h3><ul><li>表示什么含义？</li><li>例如：“到第 i 个物品的最优解” or “前 i 个字符匹配的状态”</li></ul><h3 id="🧩-第二步-状态转移方程" tabindex="-1"><a class="header-anchor" href="#🧩-第二步-状态转移方程"><span>🧩 第二步：状态转移方程</span></a></h3><ul><li>当前状态如何由前一状态推导？</li><li>示例：<code>dp[i] = dp[i-1] + dp[i-2]</code>（爬楼梯）</li></ul><h3 id="🧩-第三步-初始条件-base-case" tabindex="-1"><a class="header-anchor" href="#🧩-第三步-初始条件-base-case"><span>🧩 第三步：初始条件（base case）</span></a></h3><ul><li>如：<code>dp[0] = 1</code>, <code>dp[1] = 1</code> 等</li></ul><h3 id="🧩-第四步-遍历顺序-从小到大-从后往前" tabindex="-1"><a class="header-anchor" href="#🧩-第四步-遍历顺序-从小到大-从后往前"><span>🧩 第四步：遍历顺序（从小到大？从后往前？）</span></a></h3><ul><li>根据转移关系写 <code>for</code> 循环的方向</li></ul><h3 id="🧩-第五步-返回值" tabindex="-1"><a class="header-anchor" href="#🧩-第五步-返回值"><span>🧩 第五步：返回值</span></a></h3><ul><li>最终要返回的状态值是什么？<code>dp[n]</code> 还是最大值等</li></ul><hr><h2 id="🧭-四、几个经典题目讲解-快速理解-dp" tabindex="-1"><a class="header-anchor" href="#🧭-四、几个经典题目讲解-快速理解-dp"><span>🧭 四、几个经典题目讲解（快速理解 DP）</span></a></h2><hr><h3 id="🎯-例题一-70-爬楼梯" tabindex="-1"><a class="header-anchor" href="#🎯-例题一-70-爬楼梯"><span>🎯 例题一：<a href="https://leetcode.cn/problems/climbing-stairs/" target="_blank" rel="noopener noreferrer">70. 爬楼梯</a></span></a></h3><h4 id="❓题意" tabindex="-1"><a class="header-anchor" href="#❓题意"><span>❓题意：</span></a></h4><p>每次可以爬 1 或 2 级台阶，问有多少种方法爬到 n 阶。</p><h4 id="✅-五步走" tabindex="-1"><a class="header-anchor" href="#✅-五步走"><span>✅ 五步走：</span></a></h4><ol><li>状态定义：<code>dp[i]</code> 表示爬到第 i 阶的方法数</li><li>状态转移方程：<code>dp[i] = dp[i-1] + dp[i-2]</code></li><li>初始化：<code>dp[0] = 1</code>, <code>dp[1] = 1</code></li><li>遍历顺序：从小到大</li><li>返回值：<code>dp[n]</code></li></ol><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> int</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> climbStairs</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> n) {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    if</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> (n </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">&lt;=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 1</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">) </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">return</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#C678DD;">    int</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">[] dp </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#C18401;--shiki-dark:#C678DD;"> int</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">[n </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">+</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 1</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">]</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">    dp[</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">0</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">] </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> dp[</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">1</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">] </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    for</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> (</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> i </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 2</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> i </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">&lt;=</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> n</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> i</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">++</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">) {</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">        dp[i] </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> dp[i </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">-</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 1</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">] </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">+</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> dp[i </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">-</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 2</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">]</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">    }</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    return</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> dp[n]</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr><h3 id="🎯-例题二-1143-最长公共子序列" tabindex="-1"><a class="header-anchor" href="#🎯-例题二-1143-最长公共子序列"><span>🎯 例题二：<a href="https://leetcode.cn/problems/longest-common-subsequence/" target="_blank" rel="noopener noreferrer">1143. 最长公共子序列</a></span></a></h3><h4 id="❓题意-1" tabindex="-1"><a class="header-anchor" href="#❓题意-1"><span>❓题意：</span></a></h4><p>给定两个字符串，找出它们最长公共子序列的长度。</p><h4 id="✅-五步走-1" tabindex="-1"><a class="header-anchor" href="#✅-五步走-1"><span>✅ 五步走：</span></a></h4><ol><li><p>状态定义：<code>dp[i][j]</code> 表示 <code>text1[0..i-1]</code> 和 <code>text2[0..j-1]</code> 的最长公共子序列长度</p></li><li><p>状态转移方程：</p><ul><li>若 <code>s1[i-1] == s2[j-1]</code>，<code>dp[i][j] = dp[i-1][j-1] + 1</code></li><li>否则 <code>dp[i][j] = max(dp[i-1][j], dp[i][j-1])</code></li></ul></li><li><p>初始化：<code>dp[0][*] = 0</code>, <code>dp[*][0] = 0</code></p></li><li><p>遍历顺序：<code>i</code> 从 1 到 m，<code>j</code> 从 1 到 n</p></li><li><p>返回值：<code>dp[m][n]</code></p></li></ol><hr><h3 id="🎯-例题三-198-打家劫舍" tabindex="-1"><a class="header-anchor" href="#🎯-例题三-198-打家劫舍"><span>🎯 例题三：<a href="https://leetcode.cn/problems/house-robber/" target="_blank" rel="noopener noreferrer">198. 打家劫舍</a></span></a></h3><h4 id="❓题意-2" tabindex="-1"><a class="header-anchor" href="#❓题意-2"><span>❓题意：</span></a></h4><p>不能抢相邻的房子，问能抢到的最大金额。</p><h4 id="✅-五步走-2" tabindex="-1"><a class="header-anchor" href="#✅-五步走-2"><span>✅ 五步走：</span></a></h4><ol><li>状态定义：<code>dp[i]</code> 表示前 i 个房子能抢到的最大金额</li><li>状态转移方程：<code>dp[i] = max(dp[i-1], dp[i-2] + nums[i])</code></li><li>初始化：<code>dp[0] = nums[0]</code>, <code>dp[1] = max(nums[0], nums[1])</code></li><li>遍历顺序：从 i = 2 开始</li><li>返回值：<code>dp[n-1]</code></li></ol><hr><h2 id="📦-五、动态规划常用优化技巧" tabindex="-1"><a class="header-anchor" href="#📦-五、动态规划常用优化技巧"><span>📦 五、动态规划常用优化技巧</span></a></h2><table><thead><tr><th>技巧</th><th>说明</th></tr></thead><tbody><tr><td>滚动数组</td><td>用两个变量代替整个 dp 数组，节省空间</td></tr><tr><td>状态压缩</td><td>用位图或 mask 表示多个状态</td></tr><tr><td>记忆化搜索</td><td>顶层递归 + 哈希缓存结果</td></tr><tr><td>单调队列优化</td><td>用于区间 DP、滑动窗口 DP 场景</td></tr><tr><td>二维转一维</td><td>有时 dp[i][j] 只和 dp[i-1][j]、dp[i][j-1] 有关</td></tr></tbody></table><hr><h2 id="🗂-六、leetcode-刷题路径推荐-从易到难" tabindex="-1"><a class="header-anchor" href="#🗂-六、leetcode-刷题路径推荐-从易到难"><span>🗂 六、LeetCode 刷题路径推荐（从易到难）</span></a></h2><table><thead><tr><th>难度</th><th>题目</th><th>技巧类型</th></tr></thead><tbody><tr><td>🌱 简单</td><td><a href="https://leetcode.cn/problems/climbing-stairs/" target="_blank" rel="noopener noreferrer">70. 爬楼梯</a></td><td>一维 DP</td></tr><tr><td>🌿 简单</td><td><a href="https://leetcode.cn/problems/house-robber/" target="_blank" rel="noopener noreferrer">198. 打家劫舍</a></td><td>状态转移</td></tr><tr><td>🌼 中等</td><td><a href="https://leetcode.cn/problems/longest-common-subsequence/" target="_blank" rel="noopener noreferrer">1143. 最长公共子序列</a></td><td>二维 DP</td></tr><tr><td>🌺 中等</td><td><a href="https://leetcode.cn/problems/minimum-path-sum/" target="_blank" rel="noopener noreferrer">64. 最小路径和</a></td><td>路径 DP</td></tr><tr><td>🌸 中等</td><td><a href="https://leetcode.cn/problems/coin-change/" target="_blank" rel="noopener noreferrer">322. 零钱兑换</a></td><td>背包 DP</td></tr><tr><td>🌵 中等</td><td><a href="https://leetcode.cn/problems/partition-equal-subset-sum/" target="_blank" rel="noopener noreferrer">416. 分割等和子集</a></td><td>0-1 背包</td></tr><tr><td>🌊 困难</td><td><a href="https://leetcode.cn/problems/edit-distance/" target="_blank" rel="noopener noreferrer">72. 编辑距离</a></td><td>字符串匹配</td></tr><tr><td>🔥 困难</td><td><a href="https://leetcode.cn/problems/regular-expression-matching/" target="_blank" rel="noopener noreferrer">10. 正则表达式匹配</a></td><td>状态设计 + DP</td></tr><tr><td>🔮 困难</td><td><a href="https://leetcode.cn/problems/burst-balloons/" target="_blank" rel="noopener noreferrer">312. 戳气球</a></td><td>区间 DP</td></tr></tbody></table><hr><h2 id="✅-七、小结" tabindex="-1"><a class="header-anchor" href="#✅-七、小结"><span>✅ 七、小结</span></a></h2><table><thead><tr><th>要素</th><th>示例</th></tr></thead><tbody><tr><td>状态定义</td><td><code>dp[i]</code>、<code>dp[i][j]</code></td></tr><tr><td>状态转移</td><td>当前状态依赖前一状态</td></tr><tr><td>初始值</td><td>明确边界和起始点</td></tr><tr><td>返回值</td><td>通常是最后一个状态</td></tr><tr><td>优化方向</td><td>滚动数组 / 记忆化 / 压缩状态</td></tr></tbody></table><h1 id="开源项目" tabindex="-1"><a class="header-anchor" href="#开源项目"><span>开源项目</span></a></h1><p>为方便大家学习，所有相关文档和代码均已开源。</p><p><a href="https://houbb.github.io/leetcode-notes/leetcode/visible/index.html" target="_blank" rel="noopener noreferrer">leetcode-visual 资源可视化</a></p><p><a href="https://github.com/houbb/leetcode" target="_blank" rel="noopener noreferrer">leetcode 算法实现源码</a></p><p><a href="https://github.com/houbb/leetcode-notes" target="_blank" rel="noopener noreferrer">leetcode 刷题学习笔记</a></p><p><a href="https://houbb.github.io/" target="_blank" rel="noopener noreferrer">老马技术博客</a></p><h1 id="小结" tabindex="-1"><a class="header-anchor" href="#小结"><span>小结</span></a></h1><p>希望本文对你有帮助，如果有其他想法的话，也可以评论区和大家分享哦。</p><p>各位极客的点赞收藏转发，是老马持续写作的最大动力！</p><p>下一节我们将讲解力扣经典，感兴趣的小伙伴可以关注一波，精彩内容，不容错过。</p>`,90)]))}const p=t(r,[["render",n]]),o=JSON.parse('{"path":"/posts/leetcode/topliked-100/dp/2020-06-06-algorithm-000-leetcode-data-struct-001-topics-algorithms-dp-01-intro.html","title":"算法篇专题之动态规划 dynamic-programming 01-入门介绍","lang":"zh-CN","frontmatter":{"title":"算法篇专题之动态规划 dynamic-programming 01-入门介绍","date":"2020-06-08T00:00:00.000Z","categories":["TopLiked100"],"tags":["algorithm","data-struct","topics","leetcode","dynamic-programming","dp","sf"],"published":true,"description":"数组 大家好，我是老马。 今天我们一起来学习一下数组这种数据结构。 主要知识 数组需要拆分下面几个部分： 理论介绍 源码分析 数据结构实现？ 题目练习（按照算法思想分类） 梳理对应的 sdk 包 应用实战 因为这个是 leetcode 系列，所以重点是 4、5(对4再一次总结)。 为了照顾没有基础的小伙伴，会简单介绍一下1的基础理论。 简单介绍1，重点...","head":[["meta",{"property":"og:url","content":"https://houbb.github.io/leetcode-notes/posts/leetcode/topliked-100/dp/2020-06-06-algorithm-000-leetcode-data-struct-001-topics-algorithms-dp-01-intro.html"}],["meta",{"property":"og:site_name","content":"老马啸西风"}],["meta",{"property":"og:title","content":"算法篇专题之动态规划 dynamic-programming 01-入门介绍"}],["meta",{"property":"og:description","content":"数组 大家好，我是老马。 今天我们一起来学习一下数组这种数据结构。 主要知识 数组需要拆分下面几个部分： 理论介绍 源码分析 数据结构实现？ 题目练习（按照算法思想分类） 梳理对应的 sdk 包 应用实战 因为这个是 leetcode 系列，所以重点是 4、5(对4再一次总结)。 为了照顾没有基础的小伙伴，会简单介绍一下1的基础理论。 简单介绍1，重点..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-09-24T02:52:43.000Z"}],["meta",{"property":"article:tag","content":"algorithm"}],["meta",{"property":"article:tag","content":"data-struct"}],["meta",{"property":"article:tag","content":"topics"}],["meta",{"property":"article:tag","content":"leetcode"}],["meta",{"property":"article:tag","content":"dynamic-programming"}],["meta",{"property":"article:tag","content":"dp"}],["meta",{"property":"article:tag","content":"sf"}],["meta",{"property":"article:published_time","content":"2020-06-08T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2025-09-24T02:52:43.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"算法篇专题之动态规划 dynamic-programming 01-入门介绍\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2020-06-08T00:00:00.000Z\\",\\"dateModified\\":\\"2025-09-24T02:52:43.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"老马啸西风\\",\\"url\\":\\"https://houbb.github.io\\"}]}"]]},"git":{"createdTime":1755499309000,"updatedTime":1758682363000,"contributors":[{"name":"binbin.hou","username":"","email":"binbin.hou@huifu.com","commits":4},{"name":"bbhou","username":"bbhou","email":"1557740299@qq.com","commits":4,"url":"https://github.com/bbhou"}]},"readingTime":{"minutes":5.81,"words":1743},"filePathRelative":"posts/leetcode/topliked-100/dp/2020-06-06-algorithm-000-leetcode-data-struct-001-topics-algorithms-dp-01-intro.md","localizedDate":"2020年6月8日","excerpt":"\\n<p>大家好，我是老马。</p>\\n<p>今天我们一起来学习一下数组这种数据结构。</p>\\n<h2>主要知识</h2>\\n<p>数组需要拆分下面几个部分：</p>\\n<ol>\\n<li>\\n<p>理论介绍</p>\\n</li>\\n<li>\\n<p>源码分析</p>\\n</li>\\n<li>\\n<p>数据结构实现？</p>\\n</li>\\n<li>\\n<p>题目练习（按照算法思想分类）</p>\\n</li>\\n<li>\\n<p>梳理对应的 sdk 包</p>\\n</li>\\n<li>\\n<p>应用实战</p>\\n</li>\\n</ol>\\n<p>因为这个是 leetcode 系列，所以重点是 4、5(对4再一次总结)。</p>\\n<p>为了照顾没有基础的小伙伴，会简单介绍一下1的基础理论。</p>","autoDesc":true}');export{p as comp,o as data};
