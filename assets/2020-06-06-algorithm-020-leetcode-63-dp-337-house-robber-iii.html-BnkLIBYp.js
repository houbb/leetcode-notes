import{_ as t}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as a,a as o,o as i}from"./app-Doy7jLuz.js";const r={};function p(s,e){return i(),a("div",null,e[0]||(e[0]=[o(`<h1 id="题目" tabindex="-1"><a class="header-anchor" href="#题目"><span>题目</span></a></h1><p>小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为 root 。</p><p>除了 root 之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。</p><p>如果 两个直接相连的房子在同一天晚上被打劫 ，房屋将自动报警。</p><p>给定二叉树的 root 。</p><p>返回 在不触动警报的情况下 ，小偷能够盗取的最高金额 。</p><p>示例 1:</p><figure><img src="https://assets.leetcode.com/uploads/2021/03/10/rob1-tree.jpg" alt="demo1" tabindex="0" loading="lazy"><figcaption>demo1</figcaption></figure><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>输入: root = [3,2,3,null,3,null,1]</span></span>
<span class="line"><span>输出: 7</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>解释: 小偷一晚能够盗取的最高金额 3 + 3 + 1 = 7</p><p>示例 2:</p><figure><img src="https://assets.leetcode.com/uploads/2021/03/10/rob2-tree.jpg" alt="demo2" tabindex="0" loading="lazy"><figcaption>demo2</figcaption></figure><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>输入: root = [3,4,5,1,3,null,1]</span></span>
<span class="line"><span>输出: 9</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>解释: 小偷一晚能够盗取的最高金额 4 + 5 = 9</p><h1 id="v1-dp" tabindex="-1"><a class="header-anchor" href="#v1-dp"><span>v1-dp</span></a></h1><h2 id="这一题还上一题的区别" tabindex="-1"><a class="header-anchor" href="#这一题还上一题的区别"><span>这一题还上一题的区别</span></a></h2><p>首先我们就不吐槽题目本身了。</p><p>这一题主要是一个树的遍历问题：</p><p>树要如何实现遍历呢？</p><p>中序 前序 后序 层序</p><h2 id="个人思路" tabindex="-1"><a class="header-anchor" href="#个人思路"><span>个人思路</span></a></h2><h3 id="初始化" tabindex="-1"><a class="header-anchor" href="#初始化"><span>初始化</span></a></h3><h2 id="效果" tabindex="-1"><a class="header-anchor" href="#效果"><span>效果</span></a></h2><h2 id="小结" tabindex="-1"><a class="header-anchor" href="#小结"><span>小结</span></a></h2><p>这一题和上一题基本上是一样的。</p><p>区别就是把环拆分为 2 个子数组，然后复用上一题的解法。</p><p>这样，可以让实现变得非常简单。</p><p>DP 的性能一直没话说，最主要是要考虑清楚几个点：</p><p>1）数据初始化</p><p>2）递推公式</p><p>3）最大值的对比获取+返回</p><p>最难的是递推公式的获取。</p><p>当然还可以做内存的压缩改进。</p><h1 id="参考资料" tabindex="-1"><a class="header-anchor" href="#参考资料"><span>参考资料</span></a></h1><p><a href="https://leetcode.cn/problems/house-robber/description/?envType=problem-list-v2&amp;envId=dynamic-programming" target="_blank" rel="noopener noreferrer">https://leetcode.cn/problems/house-robber/description/?envType=problem-list-v2&amp;envId=dynamic-programming</a></p>`,35)]))}const l=t(r,[["render",p]]),c=JSON.parse('{"path":"/posts/leetcode/history1/2020-06-06-algorithm-020-leetcode-63-dp-337-house-robber-iii.html","title":"62-337. house-robber-iii  力扣 337. 打家劫舍 III  dynamic-programming","lang":"zh-CN","frontmatter":{"title":"62-337. house-robber-iii  力扣 337. 打家劫舍 III  dynamic-programming","date":"2020-06-08T00:00:00.000Z","categories":["Algorithm"],"tags":["algorithm","dp","dynamic-programming","leetcode"],"published":true,"description":"题目 小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为 root 。 除了 root 之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果 两个直接相连的房子在同一天晚上被打劫 ，房屋将自动报警。 给定二叉树的 root 。 返回 在不触动警报的情况下 ，小偷...","head":[["meta",{"property":"og:url","content":"https://houbb.github.io/leetcode-notes/posts/leetcode/history1/2020-06-06-algorithm-020-leetcode-63-dp-337-house-robber-iii.html"}],["meta",{"property":"og:site_name","content":"老马啸西风"}],["meta",{"property":"og:title","content":"62-337. house-robber-iii  力扣 337. 打家劫舍 III  dynamic-programming"}],["meta",{"property":"og:description","content":"题目 小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为 root 。 除了 root 之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果 两个直接相连的房子在同一天晚上被打劫 ，房屋将自动报警。 给定二叉树的 root 。 返回 在不触动警报的情况下 ，小偷..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://assets.leetcode.com/uploads/2021/03/10/rob1-tree.jpg"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-08-22T12:19:07.000Z"}],["meta",{"property":"article:tag","content":"algorithm"}],["meta",{"property":"article:tag","content":"dp"}],["meta",{"property":"article:tag","content":"dynamic-programming"}],["meta",{"property":"article:tag","content":"leetcode"}],["meta",{"property":"article:published_time","content":"2020-06-08T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2025-08-22T12:19:07.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"62-337. house-robber-iii  力扣 337. 打家劫舍 III  dynamic-programming\\",\\"image\\":[\\"https://assets.leetcode.com/uploads/2021/03/10/rob1-tree.jpg\\",\\"https://assets.leetcode.com/uploads/2021/03/10/rob2-tree.jpg\\"],\\"datePublished\\":\\"2020-06-08T00:00:00.000Z\\",\\"dateModified\\":\\"2025-08-22T12:19:07.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"老马啸西风\\",\\"url\\":\\"https://houbb.github.io\\"}]}"]]},"git":{"createdTime":1755499309000,"updatedTime":1755865147000,"contributors":[{"name":"binbin.hou","username":"","email":"binbin.hou@huifu.com","commits":2},{"name":"bbhou","username":"bbhou","email":"1557740299@qq.com","commits":2,"url":"https://github.com/bbhou"}]},"readingTime":{"minutes":1.51,"words":453},"filePathRelative":"posts/leetcode/history1/2020-06-06-algorithm-020-leetcode-63-dp-337-house-robber-iii.md","localizedDate":"2020年6月8日","excerpt":"\\n<p>小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为 root 。</p>\\n<p>除了 root 之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。</p>\\n<p>如果 两个直接相连的房子在同一天晚上被打劫 ，房屋将自动报警。</p>\\n<p>给定二叉树的 root 。</p>\\n<p>返回 在不触动警报的情况下 ，小偷能够盗取的最高金额 。</p>\\n<p>示例 1:</p>\\n<figure><img src=\\"https://assets.leetcode.com/uploads/2021/03/10/rob1-tree.jpg\\" alt=\\"demo1\\" tabindex=\\"0\\" loading=\\"lazy\\"><figcaption>demo1</figcaption></figure>","autoDesc":true}');export{l as comp,c as data};
