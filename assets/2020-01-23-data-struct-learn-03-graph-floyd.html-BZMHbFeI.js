import{_ as s}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as a,a as n,o as h}from"./app-DP7ZrycQ.js";const t={};function e(p,i){return h(),a("div",null,i[0]||(i[0]=[n(`<h1 id="floyd算法" tabindex="-1"><a class="header-anchor" href="#floyd算法"><span>Floyd算法</span></a></h1><h2 id="定义概览" tabindex="-1"><a class="header-anchor" href="#定义概览"><span>定义概览</span></a></h2><p>Floyd-Warshall算法（Floyd-Warshall algorithm）是解决任意两点间的最短路径的一种算法，可以正确处理有向图或负权的最短路径问题，同时也被用于计算有向图的传递闭包。</p><p>Floyd-Warshall算法的时间复杂度为O(N<sup>3)，空间复杂度为O(N</sup>2)。</p><h2 id="算法描述" tabindex="-1"><a class="header-anchor" href="#算法描述"><span>算法描述</span></a></h2><h3 id="_1-算法思想原理" tabindex="-1"><a class="header-anchor" href="#_1-算法思想原理"><span>1) 算法思想原理：</span></a></h3><p>Floyd算法是一个经典的动态规划算法。用通俗的语言来描述的话，首先我们的目标是寻找从点i到点j的最短路径。</p><p>从动态规划的角度看问题，我们需要为这个目标重新做一个诠释（这个诠释正是动态规划最富创造力的精华所在）</p><p>从任意节点i到任意节点j的最短路径不外乎2种可能，1是直接从i到j，2是从i经过若干个节点k到j。所以，我们假设Dis(i,j)为节点u到节点v的最短路径的距离，对于每一个节点k，我们检查Dis(i,k) + Dis(k,j) &lt; Dis(i,j)是否成立，如果成立，证明从i到k再到j的路径比i直接到j的路径短，我们便设置Dis(i,j) = Dis(i,k) + Dis(k,j)，这样一来，当我们遍历完所有节点k，Dis(i,j)中记录的便是i到j的最短路径的距离。</p><h3 id="_2-算法描述" tabindex="-1"><a class="header-anchor" href="#_2-算法描述"><span>2) 算法描述：</span></a></h3><p>a. 从任意一条单边路径开始。所有两点之间的距离是边的权，如果两点之间没有边相连，则权为无穷大。</p><p>b. 对于每一对顶点 u 和 v，看看是否存在一个顶点 w 使得从 u 到 w 再到 v 比己知的路径更短。如果是更新它。</p><h2 id="floyd算法过程矩阵的计算-十字交叉法" tabindex="-1"><a class="header-anchor" href="#floyd算法过程矩阵的计算-十字交叉法"><span>Floyd算法过程矩阵的计算----十字交叉法</span></a></h2><p>方法：两条线，从左上角开始计算一直到右下角 如下所示</p><p>给出矩阵，其中矩阵A是邻接矩阵，而矩阵Path记录u,v两点之间最短路径所必须经过的点</p><figure><img src="https://user-images.githubusercontent.com/18375710/73129326-d4667300-401b-11ea-969f-12b3fea9178c.png" alt="image" tabindex="0" loading="lazy"><figcaption>image</figcaption></figure><p>相应计算方法如下：</p><figure><img src="https://user-images.githubusercontent.com/18375710/73129335-1394c400-401c-11ea-8cce-46487518504a.png" alt="image" tabindex="0" loading="lazy"><figcaption>image</figcaption></figure><figure><img src="https://user-images.githubusercontent.com/18375710/73129343-4b037080-401c-11ea-8e9f-54c06447354d.png" alt="image" tabindex="0" loading="lazy"><figcaption>image</figcaption></figure><figure><img src="https://user-images.githubusercontent.com/18375710/73129347-6c645c80-401c-11ea-8909-cd11765d45e3.png" alt="image" tabindex="0" loading="lazy"><figcaption>image</figcaption></figure><h2 id="代码实现" tabindex="-1"><a class="header-anchor" href="#代码实现"><span>代码实现</span></a></h2><h3 id="java-版本" tabindex="-1"><a class="header-anchor" href="#java-版本"><span>java 版本</span></a></h3><p>核心代码只有 4 行，实在令人赞叹。</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">private</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> floyd</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">() {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    for</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> (</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> k </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 0</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> k </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">&lt;</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> n</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> k</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">++</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">) {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        for</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> (</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> i </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 0</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> i </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">&lt;</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> n</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> i</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">++</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">) {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">            for</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> (</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> j </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 0</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> j </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">&lt;</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> n</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> j</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">++</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">) {</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">                a[i][j] </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> Math</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">min</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(a[i][j], a[i][k] </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">+</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> a[k][j]);</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">            }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">        }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    // 打印</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    for</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> (</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> i </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 0</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> i </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">&lt;</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> n</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> i</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">++</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">) {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        for</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> (</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> j </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> i </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">+</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> j </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">&lt;</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> n</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> j</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">++</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">) {</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">            System</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">out</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">println</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(i </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">+</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &quot; &quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> +</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> j </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">+</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &quot;:&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> +</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> a[i][j]);</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">        }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">    }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="正确性分析" tabindex="-1"><a class="header-anchor" href="#正确性分析"><span>正确性分析</span></a></h3><p>核心代码只有四行，三行循环，一行更新，的确十分简洁优雅，可是这四行代码为什么就能求出任意两点的最短路径呢？</p><p>看代码的特点，很显然特别像是一种动态规划，确实，之前也说过该算法是基于动态规划的。</p><p>我们从动态规划的角度考虑，解动态规划题目的重点就是合理的定义状态，划分阶段，我们定义 f[k][i][j] 为经过前k的节点，从i到j所能得到的最短路径，f[k][i][j]可以从f[k-1][i][j]转移过来，即不经过第k个节点，也可以从f[k-1][i][k]+f[k-1][k][j]转移过来，即经过第k个节点。</p><p>观察一下这个状态的定义，满足不满足<strong>最优子结构和无后效性原则。</strong></p><ul><li>最优子结构</li></ul><p>图结构中一个显而易见的定理：</p><p>最短路径的子路径仍然是最短路径, 这个定理显而易见，比如一条从a到e的最短路a-&gt;b-&gt;c-&gt;d-&gt;e 那么 a-&gt;b-&gt;c 一定是a到c的最短路c-&gt;d-&gt;e一定是c到e的最短路，反过来，如果说一条最短路必须要经过点k，那么i-&gt;k的最短路加上k-&gt;j的最短路一定是i-&gt;j 经过k的最短路，因此，最优子结构可以保证。</p><ul><li>无后效性</li></ul><p>状态f[k][i][j]由f[k-1][i][j]，f[k-1][i,k] 以及f[k-1][k][j]转移过来，很容易可以看出，f[k] 的状态完全由f[k-1]转移过来，只要我们把k放倒最外层循环中，就能保证无后效性。</p><p>满足以上两个要求，我们即证明了Floyd算法是正确的。</p><p>我们最后得出一个状态转移方程：<code>f[k][i][j] = min(f[k-1][i][k],f[k-1][i][k],f[k-1][k][j])</code> ，可以观察到，这个三维的状态转移方程可以使用滚动数组进行优化。</p><h3 id="k-为什么要放在最外层" tabindex="-1"><a class="header-anchor" href="#k-为什么要放在最外层"><span>K 为什么要放在最外层</span></a></h3><p>采用动态规划思想，<code>f[k][i][j]</code> 表示 i 和 j 之间可以通过编号为 1...k 的节点的最短路径。</p><p><code>f[0][i][j]</code> 初值为原图的邻接矩阵。</p><p><code>f[k][i][j]</code>则可以从<code>f[k-1][i][j]</code>转移来，表示 i 到 j 不经过 k 这个节点。</p><p>也可以 <code>f[k-1][i][k]+f[k-1][k][j]</code> 从转移过来，表示经过 k 这个点。</p><p>意思即 <code>f[k][i][j]=min(f[k-1][i][j], f[k-1][i][k]+f[k-1][k][j])</code></p><p>然后你就会发现 f 最外层一维空间可以省略，因为 f[k] 只与 f[k-1] 有关。</p><p>虽然这个算法非常简单，但也需要找点时间理解这个算法，就不会再有这种问题啦。</p><p><strong>Floyd算法的本质是DP，而k是DP的阶段，因此要写最外面。</strong></p><p>想象一个图，<strong>讨论的是要从1点到达3点，是直接走还是经过中间点2，从而确定两点之间的最短路径</strong>。</p><h1 id="滚动数组优化" tabindex="-1"><a class="header-anchor" href="#滚动数组优化"><span>滚动数组优化</span></a></h1><p>滚动数组是一种动态规划中常见的降维优化的方式，应用广泛（背包dp等），可以极大的减少空间复杂度。</p><p>在我们求出的状态转移方程中，我们在更新f[k]层状态的时候，用到f[k-1]层的值，f[k-2] f[k-3]层的值就直接废弃了。</p><p>所以我们大可让第一层的大小从n变成2,再进一步，我们在f[k]层更新f[k][i][j]的时候，f[k-1][i][k] 和 f[k-1][k][j] 我们如果能保证，在更新k层另外一组路径m-&gt;n的时候，不受前面更新过的f[k][i][j]的影响，就可以把第一维度去掉了。</p><p>我们现在去掉第一个维度，写成我们在代码中的那样，就是f[i][j] 依赖 f[i][k] + f[k][j] 我们在更新f[m][n]的时候，用到了f[m][k] + f[k][n] 假设f[i][j]的更新影响到了f[m][k] 或者 f[k][m] 即 {m=i,k=j} 或者 {k=i,n=j} 这时候有两种情况，j和k是同一个点，或者i和k是同一个点，那么 f[i][j] = f[i][j] + f[j][j]，或者f[i][j] = f[i][i]+f[i][j] 这时候，我们所谓的“前面更新的点对”还是这两个点本来的路径，也就是说，唯一两种在某一层先更新的点，影响到后更新的点的情况，是完全合理的，所以说，我们即时把第一维去掉，也满足无后效性原则。</p><p>因此可以用滚动数组优化。</p><p>优化之后的状态转移方程即为：<code>f[i][j] = min(f[i][j],f[i][k]+f[k][j])</code>。</p><h1 id="求具体路径" tabindex="-1"><a class="header-anchor" href="#求具体路径"><span>求具体路径：</span></a></h1><p>我们上面仅仅是知道了最短路径的长度，实际应用中我们常常是需要知道具体的路径，在Floyd算法中怎么求具体路径呢，很简单，我们只需要记录下来在更新f[i][j]的时候，用到的中间节点是哪个就可以了。</p><p>假设我们用path[i][j]记录从i到j松弛的节点k，那么从i到j,肯定是先从i到k，然后再从k到j， 那么我们在找出path[i][k] , path[k][j]即可。</p><p>即 i到k的最短路是 <code>i -&gt; path[i][k] -&gt; k -&gt; path[k][j] -&gt; k</code> q\` 然后求path[i][k]和path[k][j] ，一直到某两个节点没有中间节点为止，代码如下：</p><p>在更新路径的时候：</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">if</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(a[i][k]</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">&gt;</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">temp){</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">    a[i][j] </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> temp</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">    path[i][j] </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> k</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>求路径的时候：</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> String</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> getPath</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(</span><span style="--shiki-light:#C18401;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">[][] path</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> int</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> i</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> int</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> j) {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    if</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> (path[i][j] </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">==</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> -</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">1</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">) {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        return</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &quot; &quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">+</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">i</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">+</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot; &quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">+</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">j</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">    } </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">else</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        int</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> k </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> path[i][j]</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        return</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> getPath</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(path</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> i</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> k)</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">+</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot; &quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">+</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">getPath</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(path</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> k</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> j)</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">+</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot; &quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">    }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h1 id="总结" tabindex="-1"><a class="header-anchor" href="#总结"><span>总结</span></a></h1><p>Floyd算法只能在不存在负权环的情况下使用，因为其并不能判断负权环，上面也说过，如果有负权环，那么最短路将无意义，因为我们可以不断走负权环，这样最短路径值便成为了负无穷。</p><p>但是其可以处理带负权边但是无负权环的情况。</p><p>以上就是求多源最短路的Floyd算法，基于动态规划，十分优雅。</p><p>但是其复杂度确实是不敢恭维，因为要维护一个路径矩阵，因此空间复杂度达到了O(n<sup>2)，时间复杂度达到了O(n</sup>3)，只有在数据规模很小的时候，才适合使用这个算法，但是在实际的应用中，求单源最短路是最常见的，比如在路由算法中，某个节点仅需要知道从这个节点出发到达其他节点的最短路径，而不需要知道其他点的情况，因此在路由算法中最适合的应该是单源最短路算法，Dijkstra算法。</p><h1 id="拓展阅读" tabindex="-1"><a class="header-anchor" href="#拓展阅读"><span>拓展阅读</span></a></h1><p><a href="https://houbb.github.io/2020/01/23/data-struct-learn-03-graph-dijkstra" target="_blank" rel="noopener noreferrer">Dijkstra 算法</a></p><h2 id="_6-大算法" tabindex="-1"><a class="header-anchor" href="#_6-大算法"><span>6 大算法</span></a></h2><p><a href="">贪心算法</a></p><p><a href="">动态规划算法</a></p><h1 id="参考资料" tabindex="-1"><a class="header-anchor" href="#参考资料"><span>参考资料</span></a></h1><h2 id="书籍" tabindex="-1"><a class="header-anchor" href="#书籍"><span>书籍</span></a></h2><p>《大话数据结构》</p><h2 id="blog" tabindex="-1"><a class="header-anchor" href="#blog"><span>blog</span></a></h2><p><a href="https://www.zhihu.com/question/30955032?sort=created" target="_blank" rel="noopener noreferrer">知乎-Floyd算法为什么把k放在最外层？</a></p><p><a href="https://zhuanlan.zhihu.com/p/33162490" target="_blank" rel="noopener noreferrer">知乎-算法系列——四种最短路算法：Floyd，Dijkstra，Bellman-Ford，SPFA</a></p><p><a href="https://zhuanlan.zhihu.com/p/72248451" target="_blank" rel="noopener noreferrer">知乎-Floyd 算法</a></p><p><a href="https://blog.csdn.net/zhao5502169/article/details/77505811" target="_blank" rel="noopener noreferrer">CSDN-为什么Floyd算法中k必须放在最外层</a></p><p><a href="https://www.cnblogs.com/biyeymyhjob/archive/2012/07/31/2615833.html" target="_blank" rel="noopener noreferrer">cnblogs-最短路径—Dijkstra算法和Floyd算法</a></p><p><a href="https://www.cnblogs.com/ssyfj/p/9495960.html" target="_blank" rel="noopener noreferrer">数据结构（五）图---最短路径（弗洛伊德算法）</a></p><p><a href="https://www.cnblogs.com/wangyuliang/p/9216365.html" target="_blank" rel="noopener noreferrer">Floyd-傻子也能看懂的弗洛伊德算法（转）</a></p>`,82)]))}const r=s(t,[["render",e]]),d=JSON.parse('{"path":"/posts/leetcode/datastruct/2020-01-23-data-struct-learn-03-graph-floyd.html","title":"图最短路径算法之弗洛伊德算法（Floyd）","lang":"zh-CN","frontmatter":{"title":"图最短路径算法之弗洛伊德算法（Floyd）","date":"2020-01-23T00:00:00.000Z","categories":["Data-Struct"],"tags":["data-struct","java","sh"],"published":true,"description":"Floyd算法 定义概览 Floyd-Warshall算法（Floyd-Warshall algorithm）是解决任意两点间的最短路径的一种算法，可以正确处理有向图或负权的最短路径问题，同时也被用于计算有向图的传递闭包。 Floyd-Warshall算法的时间复杂度为O(N3)，空间复杂度为O(N2)。 算法描述 1) 算法思想原理： Floyd算法...","head":[["meta",{"property":"og:url","content":"https://houbb.github.io/leetcode-notes/posts/leetcode/datastruct/2020-01-23-data-struct-learn-03-graph-floyd.html"}],["meta",{"property":"og:site_name","content":"老马啸西风"}],["meta",{"property":"og:title","content":"图最短路径算法之弗洛伊德算法（Floyd）"}],["meta",{"property":"og:description","content":"Floyd算法 定义概览 Floyd-Warshall算法（Floyd-Warshall algorithm）是解决任意两点间的最短路径的一种算法，可以正确处理有向图或负权的最短路径问题，同时也被用于计算有向图的传递闭包。 Floyd-Warshall算法的时间复杂度为O(N3)，空间复杂度为O(N2)。 算法描述 1) 算法思想原理： Floyd算法..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://user-images.githubusercontent.com/18375710/73129326-d4667300-401b-11ea-969f-12b3fea9178c.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-08-20T16:01:00.000Z"}],["meta",{"property":"article:tag","content":"data-struct"}],["meta",{"property":"article:tag","content":"java"}],["meta",{"property":"article:tag","content":"sh"}],["meta",{"property":"article:published_time","content":"2020-01-23T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2025-08-20T16:01:00.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"图最短路径算法之弗洛伊德算法（Floyd）\\",\\"image\\":[\\"https://user-images.githubusercontent.com/18375710/73129326-d4667300-401b-11ea-969f-12b3fea9178c.png\\",\\"https://user-images.githubusercontent.com/18375710/73129335-1394c400-401c-11ea-8cce-46487518504a.png\\",\\"https://user-images.githubusercontent.com/18375710/73129343-4b037080-401c-11ea-8e9f-54c06447354d.png\\",\\"https://user-images.githubusercontent.com/18375710/73129347-6c645c80-401c-11ea-8909-cd11765d45e3.png\\"],\\"datePublished\\":\\"2020-01-23T00:00:00.000Z\\",\\"dateModified\\":\\"2025-08-20T16:01:00.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"老马啸西风\\",\\"url\\":\\"https://houbb.github.io\\"}]}"]]},"git":{"createdTime":1755705660000,"updatedTime":1755705660000,"contributors":[{"name":"bbhou","username":"bbhou","email":"1557740299@qq.com","commits":1,"url":"https://github.com/bbhou"}]},"readingTime":{"minutes":8.76,"words":2628},"filePathRelative":"posts/leetcode/datastruct/2020-01-23-data-struct-learn-03-graph-floyd.md","localizedDate":"2020年1月23日","excerpt":"\\n<h2>定义概览</h2>\\n<p>Floyd-Warshall算法（Floyd-Warshall algorithm）是解决任意两点间的最短路径的一种算法，可以正确处理有向图或负权的最短路径问题，同时也被用于计算有向图的传递闭包。</p>\\n<p>Floyd-Warshall算法的时间复杂度为O(N<sup>3)，空间复杂度为O(N</sup>2)。</p>\\n<h2>算法描述</h2>\\n<h3>1) 算法思想原理：</h3>\\n<p>Floyd算法是一个经典的动态规划算法。用通俗的语言来描述的话，首先我们的目标是寻找从点i到点j的最短路径。</p>\\n<p>从动态规划的角度看问题，我们需要为这个目标重新做一个诠释（这个诠释正是动态规划最富创造力的精华所在）</p>","autoDesc":true}');export{r as comp,d as data};
