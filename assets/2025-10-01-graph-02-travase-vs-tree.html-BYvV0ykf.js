import{_ as i}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as a,a as t,o as n}from"./app-Cbb6KCGF.js";const h={};function l(e,s){return n(),a("div",null,s[0]||(s[0]=[t(`<h1 id="图可以用-dfs-遍历-是不是就可以用-bfs-遍历-区别的场景是" tabindex="-1"><a class="header-anchor" href="#图可以用-dfs-遍历-是不是就可以用-bfs-遍历-区别的场景是"><span>图可以用 dfs 遍历，是不是就可以用 BFS 遍历？区别的场景是？</span></a></h1><p>完全可以先确认一点：<strong>在图中，理论上只要能用 DFS 遍历的图，也可以用 BFS 遍历</strong>，因为两者都是遍历整个连通分量的算法。</p><p>它们的根本区别不在“能否遍历”，而在<strong>遍历顺序、应用场景和性能差异</strong>。</p><p>下面详细分析：</p><hr><h2 id="一、dfs-和-bfs-的核心区别" tabindex="-1"><a class="header-anchor" href="#一、dfs-和-bfs-的核心区别"><span>一、DFS 和 BFS 的核心区别</span></a></h2><table><thead><tr><th>特性</th><th>DFS</th><th>BFS</th></tr></thead><tbody><tr><td>遍历顺序</td><td>深度优先，尽可能沿一条路径走到底再回溯</td><td>广度优先，按层（距离起点的步数）访问</td></tr><tr><td>数据结构</td><td>栈 / 递归调用栈</td><td>队列</td></tr><tr><td>访问顺序</td><td>先访问子节点最深的路径</td><td>先访问距离起点最近的节点</td></tr><tr><td>适用场景</td><td>搜索路径、连通分量、拓扑排序、回溯</td><td>最短路径（无权图）、层序问题、分层处理</td></tr><tr><td>性能</td><td>空间复杂度受递归深度影响（最坏 O(V)）</td><td>空间复杂度受队列影响（最坏 O(V)）</td></tr></tbody></table><hr><h2 id="二、dfs-能做的事情-bfs-也能做" tabindex="-1"><a class="header-anchor" href="#二、dfs-能做的事情-bfs-也能做"><span>二、DFS 能做的事情 BFS 也能做</span></a></h2><ol><li><strong>遍历整个图</strong></li></ol><div class="language-text line-numbers-mode" data-highlighter="shiki" data-ext="text" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>DFS: 0 → 1 → 3 → 2</span></span>
<span class="line"><span>BFS: 0 → 1 → 2 → 3</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><ol start="2"><li><p><strong>连通性判断</strong></p><ul><li>DFS：判断连通分量时深入访问</li><li>BFS：按层访问，每个节点只访问一次</li></ul></li><li><p><strong>环检测</strong></p><ul><li>DFS 和 BFS 都可以检测环，思路略不同（DFS 用递归栈，BFS 用父节点/队列标记）</li></ul></li></ol><hr><h2 id="三、dfs-做不到-bfs-特定场景的地方" tabindex="-1"><a class="header-anchor" href="#三、dfs-做不到-bfs-特定场景的地方"><span>三、DFS 做不到 BFS 特定场景的地方</span></a></h2><ol><li><p><strong>最短路径（无权图）</strong></p><ul><li>BFS 保证先到达的节点是最短路径（步数最少）</li><li>DFS 没法保证最短路径，因为它可能先走很深的分支</li></ul></li><li><p><strong>按层处理问题</strong></p><ul><li>BFS 天生按层，适合“层序遍历”“每层计算”“传染/扩散模拟”</li><li>DFS 得自己额外记录层数或深度才能模拟层序</li></ul></li><li><p><strong>搜索效率差异</strong></p><ul><li>在宽而浅的图中，DFS 可能先访问很多深分支，而 BFS 先遍历同层节点，往往更快找到目标节点</li><li>在深而窄的图中，DFS 较省内存（递归栈比 BFS 队列小）</li></ul></li></ol><hr><h2 id="四、总结" tabindex="-1"><a class="header-anchor" href="#四、总结"><span>四、总结</span></a></h2><ol><li><p><strong>能用 DFS 遍历的图，理论上都能用 BFS 遍历</strong></p></li><li><p><strong>区别在于：</strong></p><ul><li>BFS → 找最短路径、分层、逐步扩散</li><li>DFS → 深度探索、回溯、拓扑排序、连通性/环检测</li></ul></li><li><p><strong>选择遍历方式的原则</strong></p><ul><li>要求“最短路径/层序” → BFS</li><li>要求“深度搜索/回溯/拓扑排序” → DFS</li></ul></li></ol><h1 id="图遍历-dfs-bfs-和树的区别和联系" tabindex="-1"><a class="header-anchor" href="#图遍历-dfs-bfs-和树的区别和联系"><span>图遍历 DFS BFS 和树的区别和联系</span></a></h1><p>我们来详细分析一下 <strong>图的遍历（DFS/BFS）</strong> 与 <strong>树遍历</strong> 的区别和联系，并用力扣的角度举例说明。</p><hr><h2 id="一、基本区别" tabindex="-1"><a class="header-anchor" href="#一、基本区别"><span>一、基本区别</span></a></h2><table><thead><tr><th>特性</th><th>树</th><th>图</th></tr></thead><tbody><tr><td>节点关系</td><td>每个节点有一个父节点，只有一条路径从根到该节点</td><td>节点可以有多个前驱，可能存在环</td></tr><tr><td>是否有环</td><td>无环</td><td>可能有环（有向图/无向图）</td></tr><tr><td>根节点</td><td>必有根节点</td><td>可以没有明确根节点，可能多个连通分量</td></tr><tr><td>遍历时是否需要标记</td><td>一般不需要（因为无环）</td><td>必须标记访问过的节点，否则可能无限循环</td></tr></tbody></table><hr><h2 id="二、dfs-和-bfs-在树与图的应用" tabindex="-1"><a class="header-anchor" href="#二、dfs-和-bfs-在树与图的应用"><span>二、DFS 和 BFS 在树与图的应用</span></a></h2><h3 id="_1-dfs-depth-first-search" tabindex="-1"><a class="header-anchor" href="#_1-dfs-depth-first-search"><span>1. DFS（Depth-First Search）</span></a></h3><p><strong>树遍历：</strong></p><ul><li>本质上就是 <strong>前序/中序/后序遍历</strong></li><li>不需要额外 <code>visited</code> 数组</li><li>递归或栈都可以</li></ul><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 树的DFS（前序）</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> dfs</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">TreeNode</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> root) {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    if</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(root </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">==</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> null</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">) </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">return</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">    System</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">out</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">println</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">root</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">val</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">    dfs</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">root</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">left</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">)</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">    dfs</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">root</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">right</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">)</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>图遍历：</strong></p><ul><li>可能有环，需要 <strong>visited[]</strong> 避免重复访问</li><li>可以递归或用栈</li></ul><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 图的DFS</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> dfs</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> node) {</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">    visited[node] </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> true</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    for</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> neighbor </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">:</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> graph</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">get</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(node)</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">) {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        if</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">!</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">visited[neighbor]) </span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">dfs</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(neighbor)</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">    }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr><h3 id="_2-bfs-breadth-first-search" tabindex="-1"><a class="header-anchor" href="#_2-bfs-breadth-first-search"><span>2. BFS（Breadth-First Search）</span></a></h3><p><strong>树遍历：</strong></p><ul><li>层序遍历</li><li>队列实现</li><li>无需 visited 数组（因为树无环）</li></ul><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 树的BFS</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">Queue</span><span style="--shiki-light:#E45649;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">TreeNode</span><span style="--shiki-light:#E45649;--shiki-dark:#ABB2BF;">&gt;</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> queue </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> LinkedList</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&lt;&gt;</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">()</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">queue</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">offer</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(root);</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">while</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">!</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">queue</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">isEmpty</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">()</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">) {</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">    TreeNode</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> node </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> queue</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">poll</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">    System</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">out</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">println</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">node</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">val</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    if</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">node</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">left</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> !=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> null</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">) </span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">queue</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">offer</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">node</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">left</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    if</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">node</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">right</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> !=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> null</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">) </span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">queue</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">offer</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">node</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">right</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>图遍历：</strong></p><ul><li>队列实现</li><li>必须 <strong>visited[]</strong> 标记</li><li>常用于最短路径（无权图）</li></ul><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 图的BFS</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">Queue</span><span style="--shiki-light:#E45649;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">Integer</span><span style="--shiki-light:#E45649;--shiki-dark:#ABB2BF;">&gt;</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> queue </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> LinkedList</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&lt;&gt;</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">()</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">queue</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">offer</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(start);</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">visited[start] </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> true</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">while</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">!</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">queue</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">isEmpty</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">()</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">) {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    int</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> node </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> queue</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">poll</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    for</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> neighbor </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">:</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> graph</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">get</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(node)</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">) {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        if</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">!</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">visited[neighbor]) {</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">            visited[neighbor] </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> true</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">            queue</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">offer</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(neighbor);</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">        }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">    }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr><h2 id="三、联系" tabindex="-1"><a class="header-anchor" href="#三、联系"><span>三、联系</span></a></h2><ol><li><p><strong>树是特殊的图</strong></p><ul><li>树是无环连通图</li><li>树的 DFS/BFS 是图 DFS/BFS 的特例</li><li>树中不需要 visited 数组，图中必须要</li></ul></li><li><p><strong>遍历思想相同</strong></p><ul><li>DFS：尽可能深地访问，回溯</li><li>BFS：按层访问</li></ul></li><li><p><strong>代码结构类似</strong></p><ul><li>树 DFS ≈ 图 DFS + 访问标记</li><li>树 BFS ≈ 图 BFS + 访问标记</li></ul></li></ol><hr><h2 id="四、力扣常见应用" tabindex="-1"><a class="header-anchor" href="#四、力扣常见应用"><span>四、力扣常见应用</span></a></h2><table><thead><tr><th>遍历方式</th><th>树题目</th><th>图题目</th></tr></thead><tbody><tr><td>DFS</td><td>LC104 二叉树最大深度, LC112 路径总和</td><td>LC200 岛屿数量, LC130 被围绕的区域</td></tr><tr><td>BFS</td><td>LC102 二叉树层序遍历</td><td>LC127 单词接龙, LC1091 最短路径</td></tr><tr><td>DFS/BFS 的区别在于是否需要访问标记，树不需要，图需要</td><td></td><td></td></tr></tbody></table><hr><p><strong>总结一句话：</strong></p><blockquote><p>树是无环图，图是通用结构；DFS/BFS 是通用遍历思想，树的遍历可以看作图遍历的特例，只是无需访问标记而已。</p></blockquote>`,49)]))}const d=i(h,[["render",l]]),r=JSON.parse('{"path":"/posts/data-struct/2025-10-01-graph-02-travase-vs-tree.html","title":"图遍历 graph dfs bfs","lang":"zh-CN","frontmatter":{"title":"图遍历 graph dfs bfs","date":"2025-10-01T00:00:00.000Z","categories":["Data Struct"],"tags":["data-struct","graph","sh"],"published":true,"description":"图可以用 dfs 遍历，是不是就可以用 BFS 遍历？区别的场景是？ 完全可以先确认一点：在图中，理论上只要能用 DFS 遍历的图，也可以用 BFS 遍历，因为两者都是遍历整个连通分量的算法。 它们的根本区别不在“能否遍历”，而在遍历顺序、应用场景和性能差异。 下面详细分析： 一、DFS 和 BFS 的核心区别 二、DFS 能做的事情 BFS 也能做 ...","head":[["meta",{"property":"og:url","content":"https://houbb.github.io/leetcode-notes/posts/data-struct/2025-10-01-graph-02-travase-vs-tree.html"}],["meta",{"property":"og:site_name","content":"老马啸西风"}],["meta",{"property":"og:title","content":"图遍历 graph dfs bfs"}],["meta",{"property":"og:description","content":"图可以用 dfs 遍历，是不是就可以用 BFS 遍历？区别的场景是？ 完全可以先确认一点：在图中，理论上只要能用 DFS 遍历的图，也可以用 BFS 遍历，因为两者都是遍历整个连通分量的算法。 它们的根本区别不在“能否遍历”，而在遍历顺序、应用场景和性能差异。 下面详细分析： 一、DFS 和 BFS 的核心区别 二、DFS 能做的事情 BFS 也能做 ..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-10-01T12:27:57.000Z"}],["meta",{"property":"article:tag","content":"data-struct"}],["meta",{"property":"article:tag","content":"graph"}],["meta",{"property":"article:tag","content":"sh"}],["meta",{"property":"article:published_time","content":"2025-10-01T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2025-10-01T12:27:57.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"图遍历 graph dfs bfs\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2025-10-01T00:00:00.000Z\\",\\"dateModified\\":\\"2025-10-01T12:27:57.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"老马啸西风\\",\\"url\\":\\"https://houbb.github.io\\"}]}"]]},"git":{"createdTime":1759321677000,"updatedTime":1759321677000,"contributors":[{"name":"bbhou","username":"bbhou","email":"1557740299@qq.com","commits":1,"url":"https://github.com/bbhou"}]},"readingTime":{"minutes":4.17,"words":1251},"filePathRelative":"posts/data-struct/2025-10-01-graph-02-travase-vs-tree.md","localizedDate":"2025年10月1日","excerpt":"\\n<p>完全可以先确认一点：<strong>在图中，理论上只要能用 DFS 遍历的图，也可以用 BFS 遍历</strong>，因为两者都是遍历整个连通分量的算法。</p>\\n<p>它们的根本区别不在“能否遍历”，而在<strong>遍历顺序、应用场景和性能差异</strong>。</p>\\n<p>下面详细分析：</p>\\n<hr>\\n<h2>一、DFS 和 BFS 的核心区别</h2>\\n<table>\\n<thead>\\n<tr>\\n<th>特性</th>\\n<th>DFS</th>\\n<th>BFS</th>\\n</tr>\\n</thead>\\n<tbody>\\n<tr>\\n<td>遍历顺序</td>\\n<td>深度优先，尽可能沿一条路径走到底再回溯</td>\\n<td>广度优先，按层（距离起点的步数）访问</td>\\n</tr>\\n<tr>\\n<td>数据结构</td>\\n<td>栈 / 递归调用栈</td>\\n<td>队列</td>\\n</tr>\\n<tr>\\n<td>访问顺序</td>\\n<td>先访问子节点最深的路径</td>\\n<td>先访问距离起点最近的节点</td>\\n</tr>\\n<tr>\\n<td>适用场景</td>\\n<td>搜索路径、连通分量、拓扑排序、回溯</td>\\n<td>最短路径（无权图）、层序问题、分层处理</td>\\n</tr>\\n<tr>\\n<td>性能</td>\\n<td>空间复杂度受递归深度影响（最坏 O(V)）</td>\\n<td>空间复杂度受队列影响（最坏 O(V)）</td>\\n</tr>\\n</tbody>\\n</table>","autoDesc":true}');export{d as comp,r as data};
