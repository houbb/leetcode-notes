import{_ as r}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as t,a,o}from"./app-DJ0lVsKS.js";const h={};function l(s,e){return o(),t("div",null,e[0]||(e[0]=[a('<h1 id="拓展阅读" tabindex="-1"><a class="header-anchor" href="#拓展阅读"><span>拓展阅读</span></a></h1><p><a href="https://houbb.github.io/2018/08/13/consistent-hash" target="_blank" rel="noopener noreferrer">一致性 hash 算法</a></p><p><a href="https://houbb.github.io/2018/05/30/hash-impl" target="_blank" rel="noopener noreferrer">java hash 实现</a></p><p><a href="https://houbb.github.io/2018/05/30/hash-conflict" target="_blank" rel="noopener noreferrer">hash 冲突处理</a></p><p><a href="https://houbb.github.io/2018/12/05/bloom-filter" target="_blank" rel="noopener noreferrer">bloom filter</a></p><p><a href="https://houbb.github.io/2019/04/01/BloomFilter-best-practice" target="_blank" rel="noopener noreferrer">bloom filter 使用最佳实践，让你少采坑！</a></p><h1 id="todo" tabindex="-1"><a class="header-anchor" href="#todo"><span>todo</span></a></h1><p>工具包包的封装+文档</p><p>资源可视化</p><p>前后端===》项目</p><p>弱点解决===》场景解决方案/技术咨询</p><h1 id="chat" tabindex="-1"><a class="header-anchor" href="#chat"><span>chat</span></a></h1><h1 id="详细介绍一下-bloomfliter" tabindex="-1"><a class="header-anchor" href="#详细介绍一下-bloomfliter"><span>详细介绍一下 BloomFliter</span></a></h1><p>好的！我来给你详细介绍一下 <strong>Merkle Tree（默克尔树）</strong>，尽量讲得清晰易懂。</p><hr><h2 id="什么是-merkle-tree" tabindex="-1"><a class="header-anchor" href="#什么是-merkle-tree"><span>什么是 Merkle Tree？</span></a></h2><p>Merkle Tree，也叫哈希树，是一种<strong>二叉树结构</strong>，它的每个叶子节点存储的是数据块的哈希值（比如一段文件内容的哈希），每个非叶子节点存储的是它的两个子节点哈希值的哈希。</p><p>简单来说，Merkle Tree 就是通过不断把数据块哈希值两两合并并哈希，最终构建成一棵树，树顶节点（根节点）的哈希值能代表整个数据集的完整性。</p><hr><h2 id="merkle-tree-的结构特点" tabindex="-1"><a class="header-anchor" href="#merkle-tree-的结构特点"><span>Merkle Tree 的结构特点</span></a></h2><ul><li><strong>叶子节点</strong>：存放数据块的哈希值</li><li><strong>非叶子节点</strong>：存放左右子节点哈希值拼接后的哈希值</li><li><strong>根节点（Merkle Root）</strong>：整棵树的顶端节点，唯一代表整批数据的摘要</li></ul><hr><h2 id="merkle-tree-的构建过程举例" tabindex="-1"><a class="header-anchor" href="#merkle-tree-的构建过程举例"><span>Merkle Tree 的构建过程举例</span></a></h2><p>假设有 4 个数据块 D1，D2，D3，D4：</p><ol><li><p>对每个数据块做哈希，得到 H1=Hash(D1), H2=Hash(D2), H3=Hash(D3), H4=Hash(D4)</p></li><li><p>两两合并哈希：</p><ul><li>H12 = Hash(H1 + H2)</li><li>H34 = Hash(H3 + H4)</li></ul></li><li><p>根节点哈希 = Hash(H12 + H34)</p></li></ol><p>最终根节点哈希值就是这 4 个数据的摘要。</p><hr><h2 id="为什么要用-merkle-tree" tabindex="-1"><a class="header-anchor" href="#为什么要用-merkle-tree"><span>为什么要用 Merkle Tree？</span></a></h2><ul><li><strong>数据完整性验证</strong>：只要根哈希不变，说明数据没有被篡改</li><li><strong>高效验证子数据</strong>：验证某个数据块是否包含在整批数据里，只需要验证从该叶子节点到根节点路径上的哈希值，不用校验全部数据</li><li><strong>节省传输和存储成本</strong>：只传递必要的哈希路径数据，不用传输完整数据</li></ul><hr><h2 id="merkle-tree-的应用场景" tabindex="-1"><a class="header-anchor" href="#merkle-tree-的应用场景"><span>Merkle Tree 的应用场景</span></a></h2><ul><li><p><strong>区块链</strong><br> 比如比特币，每个区块的交易列表通过 Merkle Tree 构建，根哈希保存在区块头里。这样可以快速验证某笔交易是否存在区块中。</p></li><li><p><strong>分布式存储系统</strong><br> 用来校验文件数据块完整性，比如 IPFS</p></li><li><p><strong>版本控制系统</strong><br> 比如 Git，内部使用类似哈希树的机制管理文件快照</p></li><li><p><strong>P2P 网络文件校验</strong><br> 比如 BitTorrent 使用 Merkle Tree 验证下载文件的每个部分</p></li></ul><hr><h2 id="merkle-tree-的验证流程" tabindex="-1"><a class="header-anchor" href="#merkle-tree-的验证流程"><span>Merkle Tree 的验证流程</span></a></h2><p>假设你想验证数据块 D3 是否属于某个 Merkle Root：</p><ol><li>你有 D3 和哈希路径信息：H4, H12</li><li>你先计算 H3=Hash(D3)</li><li>计算 H34=Hash(H3+H4)</li><li>计算根哈希 = Hash(H12 + H34)</li><li>如果计算结果与已有 Merkle Root 相同，验证通过</li></ol><p>这样，你只需要传输少量的哈希值，验证过程就完成了。</p><hr><h2 id="merkle-tree-的优缺点" tabindex="-1"><a class="header-anchor" href="#merkle-tree-的优缺点"><span>Merkle Tree 的优缺点</span></a></h2><p><strong>优点：</strong></p><ul><li>支持快速完整性校验</li><li>数据验证时无需访问所有数据，节省资源</li><li>可并行计算哈希，效率高</li></ul><p><strong>缺点：</strong></p><ul><li>需要维护额外的哈希节点</li><li>构造和更新时有一定开销（但通常很小）</li></ul><hr><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结"><span>总结</span></a></h2><p>Merkle Tree 是通过层层哈希合并，最终形成一个代表全部数据的“哈希摘要”的二叉树结构。</p><p>它非常适合在分布式系统中保证数据的完整性和验证效率，是区块链和分布式存储的核心基础技术。</p>',47)]))}const p=r(h,[["render",l]]),c=JSON.parse('{"path":"/posts/algorithm/hash/2018-05-30-hash-15-chat-hash-data-struct-merkle-tree.html","title":"Hash-13-聊一聊哈希数据结构之 Merkle Tree（默克尔树）","lang":"zh-CN","frontmatter":{"title":"Hash-13-聊一聊哈希数据结构之 Merkle Tree（默克尔树）","date":"2018-05-30T00:00:00.000Z","categories":["Algorithm"],"tags":["algorithm","hash","hashing","tree"],"published":true,"description":"拓展阅读 一致性 hash 算法 java hash 实现 hash 冲突处理 bloom filter bloom filter 使用最佳实践，让你少采坑！ todo 工具包包的封装+文档 资源可视化 前后端===》项目 弱点解决===》场景解决方案/技术咨询 chat 详细介绍一下 BloomFliter 好的！我来给你详细介绍一下 Merkle ...","head":[["meta",{"property":"og:url","content":"https://houbb.github.io/leetcode-notes/posts/algorithm/hash/2018-05-30-hash-15-chat-hash-data-struct-merkle-tree.html"}],["meta",{"property":"og:site_name","content":"老马啸西风"}],["meta",{"property":"og:title","content":"Hash-13-聊一聊哈希数据结构之 Merkle Tree（默克尔树）"}],["meta",{"property":"og:description","content":"拓展阅读 一致性 hash 算法 java hash 实现 hash 冲突处理 bloom filter bloom filter 使用最佳实践，让你少采坑！ todo 工具包包的封装+文档 资源可视化 前后端===》项目 弱点解决===》场景解决方案/技术咨询 chat 详细介绍一下 BloomFliter 好的！我来给你详细介绍一下 Merkle ..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-08-23T04:59:26.000Z"}],["meta",{"property":"article:tag","content":"algorithm"}],["meta",{"property":"article:tag","content":"hash"}],["meta",{"property":"article:tag","content":"hashing"}],["meta",{"property":"article:tag","content":"tree"}],["meta",{"property":"article:published_time","content":"2018-05-30T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2025-08-23T04:59:26.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Hash-13-聊一聊哈希数据结构之 Merkle Tree（默克尔树）\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2018-05-30T00:00:00.000Z\\",\\"dateModified\\":\\"2025-08-23T04:59:26.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"老马啸西风\\",\\"url\\":\\"https://houbb.github.io\\"}]}"]]},"git":{"createdTime":1755925166000,"updatedTime":1755925166000,"contributors":[{"name":"bbhou","username":"bbhou","email":"1557740299@qq.com","commits":1,"url":"https://github.com/bbhou"}]},"readingTime":{"minutes":3.11,"words":934},"filePathRelative":"posts/algorithm/hash/2018-05-30-hash-15-chat-hash-data-struct-merkle-tree.md","localizedDate":"2018年5月30日","excerpt":"\\n<p><a href=\\"https://houbb.github.io/2018/08/13/consistent-hash\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">一致性 hash 算法</a></p>\\n<p><a href=\\"https://houbb.github.io/2018/05/30/hash-impl\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">java hash 实现</a></p>\\n<p><a href=\\"https://houbb.github.io/2018/05/30/hash-conflict\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">hash 冲突处理</a></p>","autoDesc":true}');export{p as comp,c as data};
