import{_ as a}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as s,a as e,o as i}from"./app-D4n7alqe.js";const p={};function t(r,n){return i(),s("div",null,n[0]||(n[0]=[e(`<h1 id="问题" tabindex="-1"><a class="header-anchor" href="#问题"><span>问题</span></a></h1><p>求一个随机数组的最大值和最小值。</p><h2 id="排序" tabindex="-1"><a class="header-anchor" href="#排序"><span>排序</span></a></h2><p>可以首先对数据排序，然后获取。</p><p>本文暂时不考虑排序的情况，前提是数组乱序。</p><h1 id="常见方式" tabindex="-1"><a class="header-anchor" href="#常见方式"><span>常见方式</span></a></h1><h2 id="遍历" tabindex="-1"><a class="header-anchor" href="#遍历"><span>遍历</span></a></h2><p>最简单的就是直接遍历数组。</p><p>如何从n个数里找到最大值与最小值？</p><p>很容易想到，用一个循环找到最大值和最小值，就能搞定。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>(int, int) find_max_min(int arr[n]){</span></span>
<span class="line"><span>    int max = -infinite;</span></span>
<span class="line"><span>    int min = infinite;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    for(int i=0; i&lt;n; i++){</span></span>
<span class="line"><span>        if(arr[i]&gt;max)</span></span>
<span class="line"><span>            max=arr[i];</span></span>
<span class="line"><span>        if(arr[i]&lt;min)</span></span>
<span class="line"><span>            min=arr[i];</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    return (max, min);</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>算法复杂度：</p><p>这里，需要执行 <code>2*(n-1)=2n-2</code> 次比较。</p><h1 id="分治法" tabindex="-1"><a class="header-anchor" href="#分治法"><span>分治法</span></a></h1><p>当然，还能不能更快呢？</p><p>本篇主要想讲解一下分治法。</p><h2 id="思路" tabindex="-1"><a class="header-anchor" href="#思路"><span>思路</span></a></h2><p>分治法或许可以派上用场，分治法的思路是：</p><p>(1)把大规模拆分成小规模；</p><p>(2)小规模分别求解；</p><p>(3)小规模求解之后，再综合求解大规模；</p><p>看能不能往这个例子里套用：</p><p>(1)将 <code>arr[0,n]</code> 分为 <code>arr[0,n/2]</code> 和 <code>arr[n/2,n]</code>；</p><p>(2)每个子数组分别求解最大值和最小值；</p><p>(3)两个子数组的最大值里再取最大值，两个子数组的最小值里再取最小值，就是最终解；</p><h2 id="伪代码" tabindex="-1"><a class="header-anchor" href="#伪代码"><span>伪代码</span></a></h2><p>伪代码大概是这样：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>(int, int) find_max_min(int arr[0,n]){</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 递归左半区</span></span>
<span class="line"><span>    (max1, min1) = find_max_min(arr[0, n/2]);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 递归右半区</span></span>
<span class="line"><span>    (max2, min2) = find_max_min(arr[n/2, n]);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 再计算两次</span></span>
<span class="line"><span>    max = max1&gt;max2?max1:max2;</span></span>
<span class="line"><span>    min = min1&lt;min2?min1:min2;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    return (max, min);</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>画外音，实际的递归代码要注意：</p><p>(1)入参不是0和n，而是数组的下限和上限；</p><p>(2)递归要收敛，当数组的上下限相差1时，只比较一次，直接返回max和min，而不用再次递归；</p><h2 id="时间复杂度" tabindex="-1"><a class="header-anchor" href="#时间复杂度"><span>时间复杂度</span></a></h2><p>分治法之后，时间复杂度是多少呢？</p><p>当只有2个元素时，只需要1次计算就能知道最大，最小值</p><p>当有n个元素时，</p><p>(1)递归左半区；</p><p>(2)递归右半区；</p><p>(3)再进行两次计算；</p><p>f(2)=1;【式子A】</p><p>f(n)=2*f(n/2)+2;【式子B】</p><p>求解递归式子，得到：</p><p><code>f(n)=1.5n-2;</code></p><h2 id="证明如下" tabindex="-1"><a class="header-anchor" href="#证明如下"><span>证明如下</span></a></h2><p>证明过程如下：</p><p>【式子B】不断展开能得到：</p><p>f(n)=2*f(n/2)+2;【式子1】</p><p>f(n/2)=2*f(n/4)+2;【式子2】</p><p>f(n/4)=2*f(n/8)+2;【式子3】</p><p>...</p><p>f(n/2<sup>(m-1))=2*f(2</sup>m)+2;【式子m】</p><p>通过这m个式子的不断代入，得到：</p><p>f(n)=(2<sup>m)*f(n/2</sup>m)+2^(m+1)-2;【式子C】</p><p>由于f(2)=1【式子A】;</p><p>即【式子C】中n/2<sup>m=2时，f(n/2</sup>m)=f(2)=1;</p><p>此时n=2^(m+1)，代入【式子C】</p><p>即f(n)=n/2 + n -2 = 1.5n-2;</p><h1 id="参考资料" tabindex="-1"><a class="header-anchor" href="#参考资料"><span>参考资料</span></a></h1><p><a href="https://mp.weixin.qq.com/s/hOFzKG9mBUp3TD76mywFYw" target="_blank" rel="noopener noreferrer">再问我最大值最小值了</a></p><p><a href="https://mp.weixin.qq.com/s/pvcpBnnEvjOtL0pMU51GDA" target="_blank" rel="noopener noreferrer">求数组最大值</a></p>`,59)]))}const c=a(p,[["render",t]]),m=JSON.parse('{"path":"/posts/leetcode/2019-01-08-althgorim-min-max.html","title":"算法之最大值、最小值","lang":"zh-CN","frontmatter":{"title":"算法之最大值、最小值","date":"2019-01-07T00:00:00.000Z","categories":["Althgorim"],"tags":["althgorim","sh"],"published":true,"excerpt":"算法之最大值、最小值","description":"问题 求一个随机数组的最大值和最小值。 排序 可以首先对数据排序，然后获取。 本文暂时不考虑排序的情况，前提是数组乱序。 常见方式 遍历 最简单的就是直接遍历数组。 如何从n个数里找到最大值与最小值？ 很容易想到，用一个循环找到最大值和最小值，就能搞定。 算法复杂度： 这里，需要执行 2*(n-1)=2n-2 次比较。 分治法 当然，还能不能更快呢？ ...","head":[["meta",{"property":"og:url","content":"https://houbb.github.io/leetcode-notes/posts/leetcode/2019-01-08-althgorim-min-max.html"}],["meta",{"property":"og:site_name","content":"老马啸西风"}],["meta",{"property":"og:title","content":"算法之最大值、最小值"}],["meta",{"property":"og:description","content":"问题 求一个随机数组的最大值和最小值。 排序 可以首先对数据排序，然后获取。 本文暂时不考虑排序的情况，前提是数组乱序。 常见方式 遍历 最简单的就是直接遍历数组。 如何从n个数里找到最大值与最小值？ 很容易想到，用一个循环找到最大值和最小值，就能搞定。 算法复杂度： 这里，需要执行 2*(n-1)=2n-2 次比较。 分治法 当然，还能不能更快呢？ ..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-08-20T16:08:50.000Z"}],["meta",{"property":"article:tag","content":"althgorim"}],["meta",{"property":"article:tag","content":"sh"}],["meta",{"property":"article:published_time","content":"2019-01-07T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2025-08-20T16:08:50.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"算法之最大值、最小值\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2019-01-07T00:00:00.000Z\\",\\"dateModified\\":\\"2025-08-20T16:08:50.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"老马啸西风\\",\\"url\\":\\"https://houbb.github.io\\"}]}"]]},"git":{"createdTime":1755706130000,"updatedTime":1755706130000,"contributors":[{"name":"bbhou","username":"bbhou","email":"1557740299@qq.com","commits":1,"url":"https://github.com/bbhou"}]},"readingTime":{"minutes":2.44,"words":731},"filePathRelative":"posts/leetcode/2019-01-08-althgorim-min-max.md","localizedDate":"2019年1月7日","autoDesc":true}');export{c as comp,m as data};
